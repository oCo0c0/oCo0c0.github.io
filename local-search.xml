<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kubernetes命令</title>
    <link href="/2024/03/10/Kubernetes%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/03/10/Kubernetes%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="集群信息："><a href="#集群信息：" class="headerlink" title="集群信息："></a><strong>集群信息：</strong></h3><ol><li>显示 Kubernetes 版本：<code>kubectl version</code></li><li>显示集群信息：<code>kubectl cluster-info</code></li><li>列出集群中的所有节点：<code>kubectl get nodes</code></li><li>查看一个具体的节点详情：<code>kubectl describe node &lt;node-name&gt;</code></li><li>列出所有命名空间：<code>kubectl get namespaces</code></li><li>列出所有命名空间中的所有 pod：<code>kubectl get pods --all-namespaces</code></li></ol><h3 id="Pod-诊断："><a href="#Pod-诊断：" class="headerlink" title="Pod 诊断："></a><strong>Pod 诊断：</strong></h3><ol><li>列出特定命名空间中的 pod：<code>kubectl get pods -n &lt;namespace&gt;</code></li><li>查看一个 Pod 详情：<code>kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>查看 Pod 日志：<code>kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>尾部 Pod 日志：<code>kubectl logs -f &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>在 pod 中执行命令：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- &lt;command&gt;</code></li></ol><h3 id="Pod-健康检查："><a href="#Pod-健康检查：" class="headerlink" title="Pod 健康检查："></a><strong>Pod 健康检查：</strong></h3><ol><li>检查 Pod 准备情况：<code>kubectl get pods &lt;pod-name&gt; -n &lt;namespace&gt; -o jsonpath=&#39;&#123;.status.conditions[?(@.type==&quot;Ready&quot;)].status&#125;&#39;</code></li><li>检查 Pod 事件：<code>kubectl get events -n &lt;namespace&gt; --field-selector involvedObject.name=&lt;pod-name&gt;</code></li></ol><h3 id="Service诊断："><a href="#Service诊断：" class="headerlink" title="Service诊断："></a><strong>Service诊断：</strong></h3><ol><li>列出命名空间中的所有服务：<code>kubectl get svc -n &lt;namespace&gt;</code></li><li>查看一个服务详情：<code>kubectl describe svc &lt;service-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="Deployment诊断："><a href="#Deployment诊断：" class="headerlink" title="Deployment诊断："></a><strong>Deployment诊断：</strong></h3><ol><li>列出命名空间中的所有Deployment：<code>kubectl get deployments -n &lt;namespace&gt;</code></li><li>查看一个Deployment详情：<code>kubectl describe deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</code></li><li>查看滚动发布状态：<code>kubectl rollout status deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</code></li><li>查看滚动发布历史记录：<code>kubectl rollout history deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="StatefulSet诊断："><a href="#StatefulSet诊断：" class="headerlink" title="StatefulSet诊断："></a><strong>StatefulSet诊断：</strong></h3><ol><li>列出命名空间中的所有 StatefulSet：<code>kubectl get statefulsets -n &lt;namespace&gt;</code></li><li>查看一个 StatefulSet详情：<code>kubectl describe statefulset &lt;statefulset-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="ConfigMap-和Secret诊断："><a href="#ConfigMap-和Secret诊断：" class="headerlink" title="ConfigMap 和Secret诊断："></a><strong>ConfigMap 和Secret诊断：</strong></h3><ol><li>列出命名空间中的 ConfigMap：<code>kubectl get configmaps -n &lt;namespace&gt;</code></li><li>查看一个ConfigMap详情：<code>kubectl describe configmap &lt;configmap-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的 Secret：<code>kubectl get secrets -n &lt;namespace&gt;</code></li><li>查看一个Secret详情：<code>kubectl describe secret &lt;secret-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="命名空间诊断："><a href="#命名空间诊断：" class="headerlink" title="命名空间诊断："></a><strong>命名空间诊断：</strong></h3><ol><li>查看一个命名空间详情：<code>kubectl describe namespace &lt;namespace-name&gt;</code></li></ol><h3 id="资源使用情况："><a href="#资源使用情况：" class="headerlink" title="资源使用情况："></a><strong>资源使用情况：</strong></h3><ol><li>检查 pod 的资源使用情况：<code>kubectl top pod &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>检查节点资源使用情况：<code>kubectl top nodes</code></li></ol><h3 id="网络诊断："><a href="#网络诊断：" class="headerlink" title="网络诊断："></a><strong>网络诊断：</strong></h3><ol><li>显示命名空间中 Pod 的 IP 地址：<code>kubectl get pods -n &lt;namespace&gt; -o custom-columns=POD:metadata.name,IP:status.podIP --no-headers</code></li><li>列出命名空间中的所有网络策略：<code>kubectl get networkpolicies -n &lt;namespace&gt;</code></li><li>查看一个网络策略详情：<code>kubectl describe networkpolicy &lt;network-policy-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="持久卷-PV-和持久卷声明-PVC-诊断："><a href="#持久卷-PV-和持久卷声明-PVC-诊断：" class="headerlink" title="持久卷 (PV) 和持久卷声明 (PVC) 诊断："></a><strong>持久卷 (PV) 和持久卷声明 (PVC) 诊断：</strong></h3><ol><li>列出PV：<code>kubectl get pv</code></li><li>查看一个PV详情：<code>kubectl describe pv &lt;pv-name&gt;</code></li><li>列出命名空间中的 PVC：<code>kubectl get pvc -n &lt;namespace&gt;</code></li><li>查看PVC详情：<code>kubectl describe pvc &lt;pvc-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="节点诊断："><a href="#节点诊断：" class="headerlink" title="节点诊断："></a><strong>节点诊断：</strong></h3><ol><li>获取特定节点上运行的 Pod 列表：<code>kubectl get pods --field-selector spec.nodeName=&lt;node-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源配额和限制："><a href="#资源配额和限制：" class="headerlink" title="资源配额和限制："></a><strong>资源配额和限制：</strong></h3><ol><li>列出命名空间中的资源配额：<code>kubectl get resourcequotas -n &lt;namespace&gt;</code></li><li>查看一个资源配额详情：<code>kubectl describe resourcequota &lt;resource-quota-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="自定义资源定义-CRD-诊断："><a href="#自定义资源定义-CRD-诊断：" class="headerlink" title="自定义资源定义 (CRD) 诊断："></a><strong>自定义资源定义 (CRD) 诊断：</strong></h3><ol><li>列出命名空间中的自定义资源：<code>kubectl get &lt;custom-resource-name&gt; -n &lt;namespace&gt;</code></li><li>查看自定义资源详情：<code>kubectl describe &lt;custom-resource-name&gt; &lt;custom-resource-instance-name&gt; -n &lt;namespace&gt;</code></li></ol><p>使用这些命令时，请记住将<code>&lt;namespace&gt;</code>, <code>&lt;pod-name&gt;</code>, <code>&lt;service-name&gt;</code>, <code>&lt;deployment-name&gt;</code>, <code>&lt;statefulset-name&gt;</code>, <code>&lt;configmap-name&gt;</code>, <code>&lt;secret-name&gt;</code>, <code>&lt;namespace-name&gt;</code>, <code>&lt;pv-name&gt;</code>, <code>&lt;pvc-name&gt;</code>, <code>&lt;node-name&gt;</code>, <code>&lt;network-policy-name&gt;</code>, <code>&lt;resource-quota-name&gt;</code>, <code>&lt;custom-resource-name&gt;</code>, 和替换为你的特定值。</p><p><code>&lt;custom-resource-instance-name&gt;</code>这些命令应该可以帮助你诊断 Kubernetes 集群以及在其中运行的应用程序。</p><h3 id="资源伸缩和自动伸缩"><a href="#资源伸缩和自动伸缩" class="headerlink" title="资源伸缩和自动伸缩"></a><strong>资源伸缩和自动伸缩</strong></h3><ol><li>Deployment伸缩：<code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replica-count&gt; -n &lt;namespace&gt;</code></li><li>设置Deployment的自动伸缩：<code>kubectl autoscale deployment &lt;deployment-name&gt; --min=&lt;min-pods&gt; --max=&lt;max-pods&gt; --cpu-percent=&lt;cpu-percent&gt; -n &lt;namespace&gt;</code></li><li>检查水平伸缩器状态：<code>kubectl get hpa -n &lt;namespace&gt;</code></li></ol><h3 id="作业和-CronJob-诊断："><a href="#作业和-CronJob-诊断：" class="headerlink" title="作业和 CronJob 诊断："></a><strong>作业和 CronJob 诊断：</strong></h3><ol><li>列出命名空间中的所有作业：<code>kubectl get jobs -n &lt;namespace&gt;</code></li><li>查看一份工作详情：<code>kubectl describe job &lt;job-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的所有 cron 作业：<code>kubectl get cronjobs -n &lt;namespace&gt;</code></li><li>查看一个 cron 作业详情：<code>kubectl describe cronjob &lt;cronjob-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="容量诊断："><a href="#容量诊断：" class="headerlink" title="容量诊断："></a><strong>容量诊断：</strong></h3><ol><li>列出按容量排序的持久卷 (PV)：<code>kubectl get pv --sort-by=.spec.capacity.storage</code></li><li>查看PV回收策略：<code>kubectl get pv &lt;pv-name&gt; -o=jsonpath=&#39;&#123;.spec.persistentVolumeReclaimPolicy&#125;&#39;</code></li><li>列出所有存储类别：<code>kubectl get storageclasses</code></li></ol><h3 id="Ingress和服务网格诊断："><a href="#Ingress和服务网格诊断：" class="headerlink" title="Ingress和服务网格诊断："></a><strong>Ingress和服务网格诊断：</strong></h3><ol><li>列出命名空间中的所有Ingress：<code>kubectl get ingress -n &lt;namespace&gt;</code></li><li>查看一个Ingress详情：<code>kubectl describe ingress &lt;ingress-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的所有 VirtualServices (Istio)：<code>kubectl get virtualservices -n &lt;namespace&gt;</code></li><li>查看一个 VirtualService (Istio)详情：<code>kubectl describe virtualservice &lt;virtualservice-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="Pod-网络故障排除："><a href="#Pod-网络故障排除：" class="headerlink" title="Pod 网络故障排除："></a><strong>Pod 网络故障排除：</strong></h3><ol><li>运行网络诊断 Pod（例如 busybox）进行调试：<code>kubectl run -it --rm --restart=Never --image=busybox net-debug-pod -- /bin/sh</code></li><li>测试从 Pod 到特定端点的连接：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- curl &lt;endpoint-url&gt;</code></li><li>跟踪从一个 Pod 到另一个 Pod 的网络路径：<code>kubectl exec -it &lt;source-pod-name&gt; -n &lt;namespace&gt; -- traceroute &lt;destination-pod-ip&gt;</code></li><li>检查 Pod 的 DNS 解析：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- nslookup &lt;domain-name&gt;</code></li></ol><h3 id="配置和资源验证："><a href="#配置和资源验证：" class="headerlink" title="配置和资源验证："></a><strong>配</strong>置和资源验证：</h3><ol><li>验证 Kubernetes YAML 文件而不应用它：<code>kubectl apply --dry-run=client -f &lt;yaml-file&gt;</code></li><li>验证 pod 的安全上下文和功能：<code>kubectl auth can-i list pods --as=system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccount-name&gt;</code></li></ol><h3 id="RBAC-和安全性："><a href="#RBAC-和安全性：" class="headerlink" title="RBAC 和安全性："></a><strong>RBAC 和安全性：</strong></h3><ol><li>列出命名空间中的角色和角色绑定：<code>kubectl get roles,rolebindings -n &lt;namespace&gt;</code></li><li>查看角色或角色绑定详情：<code>kubectl describe role &lt;role-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="服务帐户诊断："><a href="#服务帐户诊断：" class="headerlink" title="服务帐户诊断："></a><strong>服务帐户诊断：</strong></h3><ol><li>列出命名空间中的服务帐户：<code>kubectl get serviceaccounts -n &lt;namespace&gt;</code></li><li>查看一个服务帐户详情：<code>kubectl describe serviceaccount &lt;serviceaccount-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="清空节点和解除封锁："><a href="#清空节点和解除封锁：" class="headerlink" title="清空节点和解除封锁："></a><strong>清空节点和解除封锁：</strong></h3><ol><li>清空节点以进行维护：<code>kubectl drain &lt;node-name&gt; --ignore-daemonsets</code></li><li>解除对节点的封锁：<code>kubectl uncordon &lt;node-name&gt;</code></li></ol><h3 id="资源清理："><a href="#资源清理：" class="headerlink" title="资源清理："></a><strong>资源清理：</strong></h3><ol><li>强制删除 pod（不推荐）：<code>kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt; --grace-period=0 --force</code></li></ol><h3 id="Pod-亲和性和反亲和性："><a href="#Pod-亲和性和反亲和性：" class="headerlink" title="Pod 亲和性和反亲和性："></a><strong>Pod 亲和性和反亲和性：</strong></h3><ol><li>列出 pod 的 pod 亲和性规则：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.affinity&#125;&#39;</code></li><li>列出 pod 的 pod 反亲和性规则：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.affinity.podAntiAffinity&#125;&#39;</code></li></ol><h3 id="Pod-安全策略-PSP-："><a href="#Pod-安全策略-PSP-：" class="headerlink" title="Pod 安全策略 (PSP)："></a><strong>Pod 安全策略 (PSP)：</strong></h3><ol><li>列出所有 Pod 安全策略（如果启用）：<code>kubectl get psp</code></li></ol><h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a><strong>事件：</strong></h3><ol><li>查看最近的集群事件：<code>kubectl get events --sort-by=.metadata.creationTimestamp</code></li><li>按特定命名空间过滤事件：<code>kubectl get events -n &lt;namespace&gt;</code></li></ol><h3 id="节点故障排除："><a href="#节点故障排除：" class="headerlink" title="节点故障排除："></a><strong>节点故障排除：</strong></h3><ol><li>检查节点情况：<code>kubectl describe node &lt;node-name&gt; | grep Conditions -A5</code></li><li>列出节点容量和可分配资源：<code>kubectl describe node &lt;node-name&gt; | grep -E &quot;Capacity|Allocatable&quot;</code></li></ol><h3 id="临时容器（Kubernetes-1-18-）："><a href="#临时容器（Kubernetes-1-18-）：" class="headerlink" title="临时容器（Kubernetes 1.18+）："></a><strong>临时容器（Kubernetes 1.18+）：</strong></h3><ol><li>运行临时调试容器：<code>kubectl debug -it &lt;pod-name&gt; -n &lt;namespace&gt; --image=&lt;debug-image&gt; -- /bin/sh</code></li></ol><h3 id="资源指标（需要指标服务器）："><a href="#资源指标（需要指标服务器）：" class="headerlink" title="资源指标（需要指标服务器）："></a><strong>资源指标（需要指标服务器）：</strong></h3><ol><li>获取 Pod 的 CPU 和内存使用情况：<code>kubectl top pod -n &lt;namespace&gt;</code></li></ol><h3 id="kuelet诊断："><a href="#kuelet诊断：" class="headerlink" title="kuelet诊断："></a><strong>kuelet诊断：</strong></h3><ol><li>查看节点上的kubelet日志：<code>kubectl logs -n kube-system kubelet-&lt;node-name&gt;</code></li></ol><h3 id="使用Telepresence-进行高级调试："><a href="#使用Telepresence-进行高级调试：" class="headerlink" title="使用Telepresence 进行高级调试："></a><strong>使用Telepresence 进行高级调试：</strong></h3><ol><li>使用 Telepresence 调试 pod：<code>telepresence --namespace &lt;namespace&gt; --swap-deployment &lt;pod-name&gt;</code></li></ol><h3 id="Kubeconfig-和上下文："><a href="#Kubeconfig-和上下文：" class="headerlink" title="Kubeconfig 和上下文："></a><strong>Kubeconfig 和上下文：</strong></h3><ol><li>列出可用的上下文：<code>kubectl config get-contexts</code></li><li>切换到不同的上下文：<code>kubectl config use-context &lt;context-name&gt;</code></li></ol><h3 id="Pod-安全标准（PodSecurity-准入控制器）："><a href="#Pod-安全标准（PodSecurity-准入控制器）：" class="headerlink" title="Pod 安全标准（PodSecurity 准入控制器）："></a><strong>Pod 安全标准（PodSecurity 准入控制器）：</strong></h3><ol><li>列出 PodSecurityPolicy (PSP) 违规行为：<code>kubectl get psp -A | grep -vE &#39;NAME|REVIEWED&#39;</code></li></ol><h3 id="Pod-中断预算-PDB-诊断："><a href="#Pod-中断预算-PDB-诊断：" class="headerlink" title="Pod 中断预算 (PDB) 诊断："></a><strong>Pod 中断预算 (PDB) 诊断：</strong></h3><ol><li>列出命名空间中的所有 PDB：<code>kubectl get pdb -n &lt;namespace&gt;</code></li><li>查看一个PDB详情：<code>kubectl describe pdb &lt;pdb-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源锁诊断（如果使用资源锁）："><a href="#资源锁诊断（如果使用资源锁）：" class="headerlink" title="资源锁诊断（如果使用资源锁）："></a><strong>资源锁诊断（如果使用资源锁）：</strong></h3><ol><li>列出命名空间中的资源锁：<code>kubectl get resourcelocks -n &lt;namespace&gt;</code></li></ol><h3 id="服务端点和-DNS："><a href="#服务端点和-DNS：" class="headerlink" title="服务端点和 DNS："></a><strong>服务端点和 DNS：</strong></h3><ol><li>列出服务的服务端点：<code>kubectl get endpoints &lt;service-name&gt; -n &lt;namespace&gt;</code></li><li>检查 Pod 中的 DNS 配置：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- cat /etc/resolv.conf</code></li></ol><h3 id="自定义指标（Prometheus、Grafana）："><a href="#自定义指标（Prometheus、Grafana）：" class="headerlink" title="自定义指标（Prometheus、Grafana）："></a><strong>自定义指标（Prometheus、Grafana）：</strong></h3><ol><li>查询Prometheus指标：用于<code>kubectl port-forward</code>访问Prometheus和Grafana服务来查询自定义指标。</li></ol><h3 id="Pod-优先级和抢占："><a href="#Pod-优先级和抢占：" class="headerlink" title="Pod 优先级和抢占："></a><strong>Pod 优先级和抢占：</strong></h3><ol><li>列出优先级：<code>kubectl get priorityclasses</code></li></ol><h3 id="Pod-开销（Kubernetes-1-18-）："><a href="#Pod-开销（Kubernetes-1-18-）：" class="headerlink" title="Pod 开销（Kubernetes 1.18+）："></a><strong>Pod 开销（Kubernetes 1.18+）：</strong></h3><ol><li>列出 pod 中的开销：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.overhead&#125;&#39;</code></li></ol><h3 id="存储卷快照诊断（如果使用存储卷快照）："><a href="#存储卷快照诊断（如果使用存储卷快照）：" class="headerlink" title="存储卷快照诊断（如果使用存储卷快照）："></a><strong>存储卷快照诊断（如果使用存储卷快照）：</strong></h3><ol><li>列出存储卷快照：<code>kubectl get volumesnapshot -n &lt;namespace&gt;</code></li><li>查看存储卷快照详情：<code>kubectl describe volumesnapshot &lt;snapshot-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源反序列化诊断："><a href="#资源反序列化诊断：" class="headerlink" title="资源反序列化诊断："></a><strong>资源反序列化诊断：</strong></h3><ol><li>反序列化并打印 Kubernetes 资源：<code>kubectl get &lt;resource-type&gt; &lt;resource-name&gt; -n &lt;namespace&gt; -o=json</code></li></ol><h3 id="节点污点："><a href="#节点污点：" class="headerlink" title="节点污点："></a><strong>节点污点：</strong></h3><ol><li>列出节点污点：<code>kubectl describe node &lt;node-name&gt; | grep Taints</code></li></ol><h3 id="更改和验证-Webhook-配置："><a href="#更改和验证-Webhook-配置：" class="headerlink" title="更改和验证 Webhook 配置："></a><strong>更改和验证 Webhook 配置：</strong></h3><ol><li>列出变异 webhook 配置：<code>kubectl get mutatingwebhookconfigurations</code></li><li>列出验证 Webhook 配置：<code>kubectl get validatingwebhookconfigurations</code></li></ol><h3 id="Pod-网络策略："><a href="#Pod-网络策略：" class="headerlink" title="Pod 网络策略："></a><strong>Pod 网络策略：</strong></h3><ol><li>列出命名空间中的 pod 网络策略：<code>kubectl get networkpolicies -n &lt;namespace&gt;</code></li></ol><h3 id="节点条件（Kubernetes-1-17-）："><a href="#节点条件（Kubernetes-1-17-）：" class="headerlink" title="节点条件（Kubernetes 1.17+）："></a><strong>节点条件（Kubernetes 1.17+）：</strong></h3><ol><li>自定义查询输出：<code>kubectl get nodes -o custom-columns=NODE:.metadata.name,READY:.status.conditions[?(@.type==&quot;Ready&quot;)].status -l &#39;node-role.kubernetes.io/worker=&#39;</code></li></ol><h3 id="审核日志："><a href="#审核日志：" class="headerlink" title="审核日志："></a><strong>审核日志：</strong></h3><ol><li>检索审核日志（如果启用）：检查 Kubernetes 审核日志配置以了解审核日志的位置。</li></ol><h3 id="节点操作系统详细信息："><a href="#节点操作系统详细信息：" class="headerlink" title="节点操作系统详细信息："></a><strong>节点操作系统详细信息：</strong></h3><ol><li>获取节点的操作系统信息：<code>kubectl get node &lt;node-name&gt; -o jsonpath=&#39;&#123;.status.nodeInfo.osImage&#125;&#39;</code></li></ol><p>这些命令应该涵盖 Kubernetes 中的各种诊断场景。确保将<code>&lt;namespace&gt;</code>、<code>&lt;pod-name&gt;</code>、<code>&lt;deployment-name&gt;</code>等占位符替换为你的集群和用例的实际值。</p>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令总结</title>
    <link href="/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令总结"><a href="#Linux命令总结" class="headerlink" title="Linux命令总结"></a>Linux命令总结</h1><p>[TOC]</p><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><blockquote><ul><li>uname -m <ul><li>显示机器的处理器架构</li></ul></li><li>uname -r<ul><li> 显示正在使用的内核版本</li></ul></li><li>dmidecode -q<ul><li> 显示硬件系统部件</li></ul></li><li>(SMBIOS / DMI) hdparm -i /dev/hda<ul><li> 罗列一个磁盘的架构特性</li></ul></li><li>hdparm -tT /dev/sda<ul><li> 在磁盘上执行测试性读取操作系统信息</li></ul></li><li>arch<ul><li> 显示机器的处理器架构</li></ul></li><li>uname -m<ul><li> 显示机器的处理器架构</li></ul></li><li>uname -r<ul><li> 显示正在使用的内核版本</li></ul></li><li>dmidecode -q<ul><li> 显示硬件系统部件 - (SMBIOS / DMI)</li></ul></li><li>hdparm -i /dev/hda<ul><li> 罗列一个磁盘的架构特性</li></ul></li><li>hdparm -tT /dev/sda<ul><li> 在磁盘上执行测试性读取操作</li></ul></li><li>cat /proc/cpuinfo<ul><li> 显示CPU info的信息</li></ul></li><li>cat /proc/interrupts<ul><li> 显示中断</li></ul></li><li>cat /proc/meminfo<ul><li> 校验内存使用</li></ul></li><li>cat /proc/swaps<ul><li> 显示哪些swap被使用</li></ul></li><li>cat /proc/version<ul><li> 显示内核的版本</li></ul></li><li>cat /proc/net/dev<ul><li> 显示网络适配器及统计</li></ul></li><li>cat /proc/mounts<ul><li> 显示已加载的文件系统</li></ul></li><li>lspci -tv <ul><li>罗列 PCI 设备</li></ul></li><li>lsusb -tv<ul><li> 显示 USB 设备</li></ul></li><li>date 显示系统日期</li><li>cal 2007 显示2007年的日历表</li><li>date 041217002007.00 设置日期和时间 - 月日时分年.秒</li><li>clock -w 将时间修改保存到 BIOS</li></ul></blockquote><h2 id="2-关机"><a href="#2-关机" class="headerlink" title="2. 关机"></a>2. 关机</h2><blockquote><ul><li>shutdown -h now 关闭系统(1)</li><li>init 0 关闭系统(2)</li><li>telinit 0 关闭系统(3)</li><li>shutdown -h hours:minutes &amp; 按预定时间关闭系统</li><li>shutdown -c 取消按预定时间关闭系统</li><li>shutdown -r now 重启(1)</li><li>reboot 重启(2)</li><li>logout 注销</li></ul></blockquote><h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3. 文件和目录"></a>3. 文件和目录</h2><blockquote><ul><li>cd /home <ul><li>进入 ‘/ home’ 目录’</li></ul></li><li>cd .. <ul><li>返回上一级目录</li></ul></li><li>cd ../.. <ul><li>返回上两级目录</li></ul></li><li>cd <ul><li>进入个人的主目录</li></ul></li><li>cd ~user1<ul><li>进入个人的主目录</li></ul></li><li>cd -<ul><li>返回上次所在的目录</li></ul></li><li>pwd <ul><li>显示工作路径</li></ul></li><li>ls<ul><li>查看目录中的文件</li></ul></li><li>ls -F<ul><li>查看目录中的文件</li></ul></li><li>ls -l<ul><li>显示文件和目录的详细资料</li></ul></li><li>ls -a<ul><li>显示隐藏文件</li></ul></li><li>ls <em>[0-9]</em><ul><li>显示包含数字的文件名和目录名</li></ul></li><li>tree<ul><li>显示文件和目录由根目录开始的树形结构(1)</li></ul></li><li>lstree<ul><li>显示文件和目录由根目录开始的树形结构(2)</li></ul></li><li>mkdir dir1<ul><li>创建一个叫做 ‘dir1’ 的目录’</li></ul></li><li>mkdir dir1 dir2<ul><li>同时创建两个目录</li></ul></li><li>mkdir -p /tmp/dir1/dir2<ul><li>创建一个目录树</li></ul></li><li>rm -f file1<ul><li>删除一个叫做 ‘file1’ 的文件’</li></ul></li><li>rmdir dir1<ul><li>删除一个叫做 ‘dir1’ 的目录’</li></ul></li><li>rm -rf dir1<ul><li>删除一个叫做 ‘dir1’ 的目录并同时删除其内容</li></ul></li><li>rm -rf dir1 dir2<ul><li>同时删除两个目录及它们的内容</li></ul></li><li>mv dir1 new_dir<ul><li>重命名/移动 一个目录</li></ul></li><li>cp file1 file2<ul><li>复制一个文件</li></ul></li><li>cp dir/* .<ul><li>复制一个目录下的所有文件到当前工作目录</li></ul></li><li>cp -a /tmp/dir1 .<ul><li>复制一个目录到当前工作目录</li></ul></li><li>cp -a dir1 dir2 <ul><li>复制一个目录</li></ul></li><li>ln -s file1 lnk1 <ul><li>创建一个指向文件或目录的软链接</li></ul></li><li>ln file1 lnk1 <ul><li>创建一个指向文件或目录的物理链接</li></ul></li><li>touch -t 0712250000 file1 <ul><li>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</li></ul></li><li>file file1 outputs the mime type of the file as text</li><li>iconv -l <ul><li>列出已知的编码</li></ul></li><li>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</li><li>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</li></ul></blockquote><h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4. 文件搜索"></a>4. 文件搜索</h2><blockquote><ul><li>find / -name file1<ul><li>从 ‘/‘ 开始进入根文件系统搜索文件和目录</li></ul></li><li>find / -user user1<ul><li>搜索属于用户 ‘user1’ 的文件和目录</li></ul></li><li>find /home/user1 -name *.bin<ul><li>在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件</li></ul></li><li>find /usr/bin -type f -atime<ul><li>+100 搜索在过去100天内未被使用过的执行文件</li></ul></li><li>find /usr/bin -type f -mtime -10<ul><li>搜索在10天内被创建或者修改过的文件</li></ul></li><li>find / -name *.rpm -exec chmod 755 ‘{}’ ;<ul><li>搜索以 ‘.rpm’ 结尾的文件并定义其权限</li></ul></li><li>find / -xdev -name *.rpm<ul><li>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</li></ul></li><li>locate *.ps<ul><li>寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</li></ul></li><li>whereis halt<ul><li>显示一个二进制文件、源码或man的位置</li></ul></li><li>which halt<ul><li>显示一个二进制文件或可执行文件的完整路径</li></ul></li></ul></blockquote><h2 id="5-挂载一个文件系统"><a href="#5-挂载一个文件系统" class="headerlink" title="5. 挂载一个文件系统"></a>5. 挂载一个文件系统</h2><blockquote><ul><li>mount /dev/hda2 /mnt/hda2<ul><li>挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在</li></ul></li><li>umount /dev/hda2<ul><li>卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出</li></ul></li><li>fuser -km /mnt/hda2<ul><li>当设备繁忙时强制卸载</li></ul></li><li>umount -n /mnt/hda2<ul><li>运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</li></ul></li><li>mount /dev/fd0 /mnt/floppy<ul><li>挂载一个软盘</li></ul></li><li>mount /dev/cdrom /mnt/cdrom<ul><li>挂载一个cdrom或dvdrom</li></ul></li><li>mount /dev/hdc /mnt/cdrecorder<ul><li>挂载一个cdrw或dvdrom</li></ul></li><li>mount /dev/hdb /mnt/cdrecorder<ul><li>挂载一个cdrw或dvdrom</li></ul></li><li>mount -o loop file.iso /mnt/cdrom<ul><li>挂载一个文件或ISO镜像文件</li></ul></li><li>mount -t vfat /dev/hda5 /mnt/hda5<ul><li>挂载一个Windows FAT32文件系统</li></ul></li><li>mount /dev/sda1 /mnt/usbdisk<ul><li>挂载一个usb 捷盘或闪存设备</li></ul></li><li>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share<ul><li>挂载一个windows网络共享</li></ul></li></ul></blockquote><h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6. 磁盘空间"></a>6. 磁盘空间</h2><blockquote><ul><li>df -h <ul><li>显示已经挂载的分区列表</li></ul></li><li>ls -lSr |more <ul><li>以尺寸大小排列文件和目录</li></ul></li><li>du -sh dir1 <ul><li>估算目录 ‘dir1’ 已经使用的磁盘空间’</li></ul></li><li>du -sk * | sort -rn <ul><li>以容量大小为依据依次显示文件和目录的大小</li></ul></li><li>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n <ul><li>以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</li></ul></li><li>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n <ul><li>以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</li></ul></li></ul></blockquote><h2 id="7-用户和群组"><a href="#7-用户和群组" class="headerlink" title="7. 用户和群组"></a>7. 用户和群组</h2><blockquote><ul><li>groupadd group_name <ul><li>创建一个新用户组</li></ul></li><li>groupdel group_name <ul><li>删除一个用户组</li></ul></li><li>groupmod -n new_group_name old_group_name <ul><li>重命名一个用户组</li></ul></li><li>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” <ul><li>用户组的用户</li></ul></li><li>useradd user1 <ul><li>创建一个新用户</li></ul></li><li>userdel -r user1 <ul><li>删除一个用户 ( ‘-r’ 排除主目录)</li></ul></li><li>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 <ul><li>修改用户属性</li></ul></li><li>passwd <ul><li>修改口令</li></ul></li><li>passwd user1 <ul><li>修改一个用户的口令 (只允许root执行)</li></ul></li><li>chage -E 2005-12-31 user1 <ul><li>设置用户口令的失效期限</li></ul></li><li>pwck <ul><li>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户</li></ul></li><li>grpck <ul><li>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组</li></ul></li><li>newgrp group_name <ul><li>登陆进一个新的群组以改变新创建文件的预设群组</li></ul></li></ul></blockquote><h2 id="8-文件的权限-使用-“-”-设置权限，使用-“-”-用于取消"><a href="#8-文件的权限-使用-“-”-设置权限，使用-“-”-用于取消" class="headerlink" title="8. 文件的权限 使用 “+” 设置权限，使用 “-” 用于取消"></a>8. 文件的权限 使用 “+” 设置权限，使用 “-” 用于取消</h2><blockquote><ul><li>ls -lh <ul><li>显示权限</li></ul></li><li>ls /tmp | pr -T5 -W$COLUMNS <ul><li>将终端划分成5栏显示</li></ul></li><li>chmod ugo+rwx directory1 <ul><li>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</li></ul></li><li>chmod go-rwx directory1 <ul><li>删除群组(g)与其他人(o)对目录的读写执行权限</li></ul></li><li>chown user1 file1 <ul><li>改变一个文件的所有人属性</li></ul></li><li>chown -R user1 directory1 <ul><li>改变一个目录的所有人属性并同时改变改目录下所有文件的属性</li></ul></li><li>chgrp group1 file1 <ul><li>改变文件的群组</li></ul></li><li>chown user1:group1 file1 <ul><li>改变一个文件的所有人和群组属性</li></ul></li><li>find / -perm -u+s <ul><li>罗列一个系统中所有使用了SUID控制的文件</li></ul></li><li>chmod u+s /bin/file1 <ul><li>设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</li></ul></li><li>chmod u-s /bin/file1 <ul><li>禁用一个二进制文件的 SUID位</li></ul></li><li>chmod g+s /home/public <ul><li>设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</li></ul></li><li>chmod g-s /home/public <ul><li>禁用一个目录的 SGID 位</li></ul></li><li>chmod o+t /home/public <ul><li>设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</li></ul></li><li>chmod o-t /home/public <ul><li>禁用一个目录的 STIKY 位</li></ul></li><li>chmod +x <ul><li>文件路径 为所有者、所属组和其他用户添加执行的权限</li></ul></li><li>chmod -x <ul><li>文件路径 为所有者、所属组和其他用户删除执行的权限</li></ul></li><li>chmod u+x <ul><li>文件路径 为所有者添加执行的权限</li></ul></li><li>chmod g+x <ul><li>文件路径 为所属组添加执行的权限</li></ul></li><li>chmod o+x <ul><li>文件路径 为其他用户添加执行的权限</li></ul></li><li>chmod ug+x <ul><li>文件路径 为所有者、所属组添加执行的权限</li></ul></li><li>chmod =wx <ul><li>文件路径 为所有者、所属组和其他用户添加写、执行的权限，取消读权限</li></ul></li><li>chmod ug=wx <ul><li>文件路径 为所有者、所属组添加写、执行的权限，取消读权限</li></ul></li></ul></blockquote><h2 id="9-文件的特殊属性-，使用-“-”-设置权限，使用-“-”-用于取消"><a href="#9-文件的特殊属性-，使用-“-”-设置权限，使用-“-”-用于取消" class="headerlink" title="9. 文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消"></a>9. 文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消</h2><blockquote><ul><li>chattr +a file1 只允许以追加方式读写文件</li><li>chattr +c file1 允许这个文件能被内核自动压缩/解压</li><li>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件</li><li>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接</li><li>chattr +s file1 允许一个文件被安全地删除</li><li>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</li><li>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件</li><li>lsattr 显示特殊的属性</li></ul></blockquote><h2 id="10-打包和压缩文件"><a href="#10-打包和压缩文件" class="headerlink" title="10. 打包和压缩文件"></a>10. 打包和压缩文件</h2><blockquote><ul><li>bunzip2 file1.bz2<ul><li> 解压一个叫做 ‘file1.bz2’的文件</li></ul></li><li>bzip2 file1<ul><li> 压缩一个叫做 ‘file1’ 的文件</li></ul></li><li>gunzip file1.gz<ul><li> 解压一个叫做 ‘file1.gz’的文件</li></ul></li><li>gzip file1<ul><li> 压缩一个叫做 ‘file1’的文件</li></ul></li><li>gzip -9 file1<ul><li> 最大程度压缩</li></ul></li><li>rar a file1.rar test_file<ul><li> 创建一个叫做 ‘file1.rar’ 的包</li></ul></li><li>rar a file1.rar file1 file2 dir1<ul><li> 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</li></ul></li><li>rar x file1.rar<ul><li> 解压rar包</li></ul></li><li>unrar x file1.rar<ul><li> 解压rar包</li></ul></li><li>tar -cvf archive.tar file1<ul><li> 创建一个非压缩的 tarball</li></ul></li><li>tar -cvf archive.tar file1 file2 dir1<ul><li> 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</li></ul></li><li>tar -tf archive.tar<ul><li> 显示一个包中的内容</li></ul></li><li>tar -xvf archive.tar<ul><li> 释放一个包</li></ul></li><li>tar -xvf archive.tar -C /tmp<ul><li> 将压缩包释放到 /tmp目录下</li></ul></li><li>tar -cvfj archive.tar.bz2 dir1<ul><li> 创建一个bzip2格式的压缩包</li></ul></li><li>tar -xvfj archive.tar.bz2<ul><li> 解压一个bzip2格式的压缩包</li></ul></li><li>tar -cvfz archive.tar.gz dir1<ul><li> 创建一个gzip格式的压缩包</li></ul></li><li>tar -xvfz archive.tar.gz<ul><li> 解压一个gzip格式的压缩包</li></ul></li><li>zip file1.zip file1<ul><li> 创建一个zip格式的压缩包</li></ul></li><li>zip -r file1.zip file1 file2 dir1<ul><li> 将几个文件和目录同时压缩成一个zip格式的压缩包</li></ul></li><li>unzip file1.zip <ul><li>解压一个zip格式压缩包</li></ul></li></ul></blockquote><h2 id="11-RPM-包"><a href="#11-RPM-包" class="headerlink" title="11. RPM 包"></a>11. RPM 包</h2><blockquote><ul><li>rpm -ivh package.rpm<ul><li> 安装一个rpm包</li></ul></li><li>rpm -ivh –nodeeps package.rpm<ul><li> 安装一个rpm包而忽略依赖关系警告</li></ul></li><li>rpm -U package.rpm<ul><li> 更新一个rpm包但不改变其配置文件</li></ul></li><li>rpm -F package.rpm<ul><li> 更新一个确定已经安装的rpm包</li></ul></li><li>rpm -e package_name.rpm<ul><li> 删除一个rpm包</li></ul></li><li>rpm -qa <ul><li>显示系统中所有已经安装的rpm包</li></ul></li><li>rpm -qa | grep httpd<ul><li> 显示所有名称中包含 “httpd” 字样的rpm包</li></ul></li><li>rpm -qi package_name<ul><li> 获取一个已安装包的特殊信息</li></ul></li><li>rpm -qg “System Environment/Daemons”<ul><li> 显示一个组件的rpm包</li></ul></li><li>rpm -ql package_name<ul><li> 显示一个已经安装的rpm包提供的文件列表</li></ul></li><li>rpm -qc package_name<ul><li> 显示一个已经安装的rpm包提供的配置文件列表</li></ul></li><li>rpm -q package_name –whatrequires<ul><li> 显示与一个rpm包存在依赖关系的列表</li></ul></li><li>rpm -q package_name –whatprovides<ul><li> 显示一个rpm包所占的体积</li></ul></li><li>rpm -q package_name –scripts<ul><li> 显示在安装/删除期间所执行的脚本l</li></ul></li><li>rpm -q package_name –changelog<ul><li> 显示一个rpm包的修改历史</li></ul></li><li>rpm -qf /etc/httpd/conf/httpd.conf<ul><li> 确认所给的文件由哪个rpm包所提供</li></ul></li><li>rpm -qp package.rpm -l<ul><li> 显示由一个尚未安装的rpm包提供的文件列表</li></ul></li><li>rpm –import /media/cdrom/RPM-GPG-KEY<ul><li> 导入公钥数字证书</li></ul></li><li>rpm –checksig package.rpm<ul><li> 确认一个rpm包的完整性</li></ul></li><li>rpm -qa gpg-pubkey<ul><li> 确认已安装的所有rpm包的完整性</li></ul></li><li>rpm -V package_name<ul><li> 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</li></ul></li><li>rpm -Va<ul><li> 检查系统中所有已安装的rpm包- 小心使用</li></ul></li><li>rpm -Vp package.rpm<ul><li> 确认一个rpm包还未安装</li></ul></li><li>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em><ul><li> 从一个rpm包运行可执行文件</li></ul></li><li>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm<ul><li> 从一个rpm源码安装一个构建好的包</li></ul></li><li>rpmbuild –rebuild package_name.src.rpm<ul><li> 从一个rpm源码构建一个 rpm 包</li></ul></li></ul></blockquote><h2 id="12-YUM-软件包升级器"><a href="#12-YUM-软件包升级器" class="headerlink" title="12. YUM 软件包升级器"></a>12. YUM 软件包升级器</h2><blockquote><ul><li>yum install package_name<ul><li>下载并安装一个rpm包</li></ul></li><li>yum localinstall package_name.rpm <ul><li>将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</li></ul></li><li>yum update package_name.rpm<ul><li>更新当前系统中所有安装的rpm包</li></ul></li><li>yum update package_name<ul><li>更新一个rpm包</li></ul></li><li>yum remove package_name<ul><li>删除一个rpm包</li></ul></li><li>yum list<ul><li>列出当前系统中安装的所有包</li></ul></li><li>yum search package_name<ul><li>在rpm仓库中搜寻软件包</li></ul></li><li>yum clean packages<ul><li>清理rpm缓存删除下载的包</li></ul></li><li>yum clean headers<ul><li>删除所有头文件</li></ul></li><li>yum clean all<ul><li>删除所有缓存的包和头文件yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件</li></ul></li></ul></blockquote><h2 id="13-deb-包"><a href="#13-deb-包" class="headerlink" title="13. deb 包"></a>13. deb 包</h2><blockquote><ul><li>dpkg -i package.deb<ul><li>安装/更新一个 deb 包</li></ul></li><li>dpkg -r package_name<ul><li>从系统删除一个 deb 包</li></ul></li><li>dpkg -l <ul><li>显示系统中所有已经安装的 deb 包</li></ul></li><li>dpkg -l | grep httpd<ul><li>显示所有名称中包含 “httpd” 字样的deb包</li></ul></li><li>dpkg -s package_name<ul><li>获得已经安装在系统中一个特殊包的信息</li></ul></li><li>dpkg -L package_name<ul><li>显示系统中已经安装的一个deb包所提供的文件列表</li></ul></li><li>dpkg –contents package.deb<ul><li>显示尚未安装的一个包所提供的文件列表</li></ul></li><li>dpkg -S /bin/ping<ul><li>确认所给的文件由哪个deb包提供</li></ul></li><li>APT 软件工具 (Debian, Ubuntu 以及类似系统)</li><li>apt-get install package_name<ul><li>安装/更新一个 deb 包</li></ul></li><li>apt-cdrom install package_name<ul><li>从光盘安装/更新一个 deb 包</li></ul></li><li>apt-get update<ul><li>升级列表中的软件包</li></ul></li><li>apt-get upgrade<ul><li>升级所有已安装的软件</li></ul></li><li>apt-get remove package_name<ul><li>从系统删除一个deb包</li></ul></li><li>apt-get check<ul><li>确认依赖的软件仓库正确</li></ul></li><li>apt-get clean <ul><li>从下载的软件包中清理缓存</li></ul></li><li>apt-cache search searched-package <ul><li>返回包含所要搜索字符串的软件包名称</li></ul></li></ul></blockquote><h2 id="14-查看文件内容"><a href="#14-查看文件内容" class="headerlink" title="14. 查看文件内容"></a>14. 查看文件内容</h2><blockquote><ul><li>cat file1 <ul><li>从第一个字节开始正向查看文件的内容</li></ul></li><li>tac file1 <ul><li>从最后一行开始反向查看一个文件的内容</li></ul></li><li>more file1 <ul><li>查看一个长文件的内容</li></ul></li><li>less file1 <ul><li>类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</li></ul></li><li>head -2 file1 <ul><li>查看一个文件的前两行</li></ul></li><li>tail -2 file1 <ul><li>查看一个文件的最后两行</li></ul></li><li>tail -f /var/log/messages <ul><li>实时查看被添加到一个文件中的内容</li></ul></li></ul></blockquote><h2 id="15-文本处理"><a href="#15-文本处理" class="headerlink" title="15. 文本处理"></a>15. 文本处理</h2><blockquote><ul><li>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</li><li>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt <ul><li>合并一个文件的详细说明文本，并将简介写入一个新文件中</li></ul></li><li>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt <ul><li>合并一个文件的详细说明文本，并将简介写入一个已有的文件中</li></ul></li><li>grep Aug /var/log/messages <ul><li>在文件 ‘/var/log/messages’中查找关键词”Aug”</li></ul></li><li>grep ^Aug /var/log/messages <ul><li>在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇</li></ul></li><li>grep [0-9] /var/log/messages <ul><li>选择 ‘/var/log/messages’ 文件中所有包含数字的行</li></ul></li><li>grep Aug -R /var/log/* <ul><li>在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”</li></ul></li><li>sed ‘s/stringa1/stringa2/g’ example.txt <ul><li>将example.txt文件中的 “string1” 替换成 “string2”</li></ul></li><li>sed ‘/^$/d’ example.txt <ul><li>从example.txt文件中删除所有空白行</li></ul></li><li>sed ‘/ *#/d; /^$/d’ example.txt <ul><li>从example.txt文件中删除所有注释和空白行</li></ul></li><li>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ <ul><li>合并上下单元格内容</li></ul></li><li>sed -e ‘1d’ result.txt <ul><li>从文件example.txt 中排除第一行</li></ul></li><li>sed -n ‘/stringa1/p’ <ul><li>查看只包含词汇 “string1”的行</li></ul></li><li>sed -e ‘s/ *$//‘ example.txt <ul><li>删除每一行最后的空白字符</li></ul></li><li>sed -e ‘s/stringa1//g’ example.txt <ul><li>从文档中只删除词汇 “string1” 并保留剩余全部</li></ul></li><li>sed -n ‘1,5p;5q’ example.txt <ul><li>查看从第一行到第5行内容</li></ul></li><li>sed -n ‘5p;5q’ example.txt <ul><li>查看第5行</li></ul></li><li>sed -e ‘s/00*/0/g’ example.txt <ul><li>用单个零替换多个零</li></ul></li><li>cat -n file1 <ul><li>标示文件的行数</li></ul></li><li>cat example.txt | awk ‘NR%2==1’ <ul><li>删除example.txt文件中的所有偶数行</li></ul></li><li>echo a b c | awk ‘{print $1}’ <ul><li>查看一行第一栏</li></ul></li><li>echo a b c | awk ‘{print $1,$3}’ <ul><li>查看一行的第一和第三栏</li></ul></li><li>paste file1 file2 <ul><li>合并两个文件或两栏的内容</li></ul></li><li>paste -d ‘+’ file1 file2 <ul><li>合并两个文件或两栏的内容，中间用”+”区分</li></ul></li><li>sort file1 file2 <ul><li>排序两个文件的内容</li></ul></li><li>sort file1 file2 | uniq <ul><li>取出两个文件的并集(重复的行只保留一份)</li></ul></li><li>sort file1 file2 | uniq -u <ul><li>删除交集，留下其他的行</li></ul></li><li>sort file1 file2 | uniq -d <ul><li>取出两个文件的交集(只留下同时存在于两个文件中的文件)</li></ul></li><li>comm -1 file1 file2 <ul><li>比较两个文件的内容只删除 ‘file1’ 所包含的内容</li></ul></li><li>comm -2 file1 file2 <ul><li>比较两个文件的内容只删除 ‘file2’ 所包含的内容</li></ul></li><li>comm -3 file1 file2 <ul><li>比较两个文件的内容只删除两个文件共有的部分</li></ul></li></ul></blockquote><h2 id="16-字符设置和文件格式转换"><a href="#16-字符设置和文件格式转换" class="headerlink" title="16. 字符设置和文件格式转换"></a>16. 字符设置和文件格式转换</h2><blockquote><ul><li>dos2unix filedos.txt fileunix.txt <ul><li>将一个文本文件的格式从MSDOS转换成UNIX</li></ul></li><li>unix2dos fileunix.txt filedos.txt <ul><li>将一个文本文件的格式从UNIX转换成MSDOS</li></ul></li><li>recode ..HTML &lt; page.txt &gt; page.html <ul><li>将一个文本文件转换成html</li></ul></li><li>recode -l | more <ul><li>显示所有允许的转换格式</li></ul></li></ul></blockquote><h2 id="17-文件系统分析"><a href="#17-文件系统分析" class="headerlink" title="17. 文件系统分析"></a>17. 文件系统分析</h2><blockquote><ul><li>badblocks -v /dev/hda1 <ul><li>检查磁盘hda1上的坏磁块</li></ul></li><li>fsck /dev/hda1 <ul><li>修复/检查hda1磁盘上linux文件系统的完整性</li></ul></li><li>fsck.ext2 /dev/hda1 <ul><li>修复/检查hda1磁盘上ext2文件系统的完整性</li></ul></li><li>e2fsck /dev/hda1 <ul><li>修复/检查hda1磁盘上ext2文件系统的完整性</li></ul></li><li>e2fsck -j /dev/hda1 <ul><li>修复/检查hda1磁盘上ext3文件系统的完整性</li></ul></li><li>fsck.ext3 /dev/hda1 <ul><li>修复/检查hda1磁盘上ext3文件系统的完整性</li></ul></li><li>fsck.vfat /dev/hda1 <ul><li>修复/检查hda1磁盘上fat文件系统的完整性</li></ul></li><li>fsck.msdos /dev/hda1 <ul><li>修复/检查hda1磁盘上dos文件系统的完整性</li></ul></li><li>dosfsck /dev/hda1 <ul><li>修复/检查hda1磁盘上dos文件系统的完整性</li></ul></li></ul></blockquote><h2 id="18-初始化一个文件系统"><a href="#18-初始化一个文件系统" class="headerlink" title="18. 初始化一个文件系统"></a>18. 初始化一个文件系统</h2><blockquote><ul><li>mkfs /dev/hda1 <ul><li>在hda1分区创建一个文件系统</li></ul></li><li>mke2fs /dev/hda1 <ul><li>在hda1分区创建一个linux ext2的文件系统</li></ul></li><li>mke2fs -j /dev/hda1 <ul><li>在hda1分区创建一个linux ext3(日志型)的文件系统</li></ul></li><li>mkfs -t vfat 32 -F /dev/hda1 <ul><li>创建一个 FAT32 文件系统</li></ul></li><li>fdformat -n /dev/fd0 <ul><li>格式化一个软盘</li></ul></li><li>mkswap /dev/hda3 <ul><li>创建一个swap文件系统</li></ul></li></ul></blockquote><h2 id="19-SWAP-文件系统"><a href="#19-SWAP-文件系统" class="headerlink" title="19. SWAP 文件系统"></a>19. SWAP 文件系统</h2><blockquote><ul><li>mkswap /dev/hda3 <ul><li>创建一个swap文件系统</li></ul></li><li>swapon /dev/hda3 <ul><li>启用一个新的swap文件系统</li></ul></li><li>swapon /dev/hda2 /dev/hdb3 <ul><li>启用两个swap分区</li></ul></li></ul></blockquote><h2 id="20-备份"><a href="#20-备份" class="headerlink" title="20. 备份"></a>20. 备份</h2><blockquote><ul><li>dump -0aj -f /tmp/home0.bak /home <ul><li>制作一个 ‘/home’ 目录的完整备份</li></ul></li><li>dump -1aj -f /tmp/home0.bak /home <ul><li>制作一个 ‘/home’ 目录的交互式备份</li></ul></li><li>restore -if /tmp/home0.bak <ul><li>还原一个交互式备份</li></ul></li><li>rsync -rogpav –delete /home /tmp <ul><li>同步两边的目录</li></ul></li><li>rsync -rogpav -e ssh –delete /home ip_address:/tmp <ul><li>通过SSH通道rsync</li></ul></li><li>rsync -az -e ssh –delete ip_addr:/home/public /home/local <ul><li>通过ssh和压缩将一个远程目录同步到本地目录</li></ul></li><li>rsync -az -e ssh –delete /home/local ip_addr:/home/public <ul><li>通过ssh和压缩将本地目录同步到远程目录</li></ul></li><li>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ <ul><li>通过ssh在远程主机上执行一次备份本地磁盘的操作</li></ul></li><li>dd if=/dev/sda of=/tmp/file1 <ul><li>备份磁盘内容到一个文件</li></ul></li><li>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ <ul><li>目录的交互式备份操作</li></ul></li><li>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ <ul><li>通过ssh在远程目录中复制一个目录内容</li></ul></li><li>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ <ul><li>通过ssh在远程目录中复制一个本地目录</li></ul></li><li>tar cf - . | (cd /tmp/backup ; tar xf - ) <ul><li>本地将一个目录复制到另一个地方，保留原有权限及链接</li></ul></li><li>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents <ul><li>从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录</li></ul></li><li>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 <ul><li>查找所有以 ‘.log’ 结尾的文件并做成一个bzip包</li></ul></li><li>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 <ul><li>做一个将 MBR (Master Boot Record)内容复制到软盘的动作</li></ul></li><li>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 <ul><li>从已经保存到软盘的备份中恢复MBR内容</li></ul></li></ul></blockquote><h2 id="21-光盘"><a href="#21-光盘" class="headerlink" title="21. 光盘"></a>21. 光盘</h2><blockquote><ul><li>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force <ul><li>清空一个可复写的光盘内容</li></ul></li><li>mkisofs /dev/cdrom &gt; cd.iso <ul><li>在磁盘上创建一个光盘的iso镜像文件</li></ul></li><li>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz <ul><li>在磁盘上创建一个压缩了的光盘iso镜像文件</li></ul></li><li>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd <ul><li>创建一个目录的iso镜像文件</li></ul></li><li>cdrecord -v dev=/dev/cdrom cd.iso <ul><li>刻录一个ISO镜像文件</li></ul></li><li>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - <ul><li>刻录一个压缩了的ISO镜像文件</li></ul></li><li>mount -o loop cd.iso /mnt/iso <ul><li>挂载一个ISO镜像文件</li></ul></li><li>cd-paranoia -B <ul><li>从一个CD光盘转录音轨到 wav 文件中</li></ul></li><li>cd-paranoia – “-3” <ul><li>从一个CD光盘转录音轨到 wav 文件中（参数-3）</li></ul></li><li>cdrecord –scanbus <ul><li>扫描总线以识别scsi通道</li></ul></li><li>dd if=/dev/hdc | md5sum <ul><li>校验一个设备的md5sum编码，例如一张 CD</li></ul></li></ul></blockquote><h2 id="22-网络（以太网和-WIFI-无线）"><a href="#22-网络（以太网和-WIFI-无线）" class="headerlink" title="22. 网络（以太网和 WIFI 无线）"></a>22. 网络（以太网和 WIFI 无线）</h2><blockquote><ul><li>ifconfig eth0 <ul><li>显示一个以太网卡的配置</li></ul></li><li>ifup eth0 <ul><li>启用一个 ‘eth0’ 网络设备</li></ul></li><li>ifdown eth0 <ul><li>禁用一个 ‘eth0’ 网络设备</li></ul></li><li>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 <ul><li>控制IP地址</li></ul></li><li>ifconfig eth0 promisc <ul><li>设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)</li></ul></li><li>dhclient eth0 <ul><li>以dhcp模式启用 ‘eth0’</li></ul></li><li>route -n show routing table</li><li>route add -net 0/0 gw IP_Gateway configura default gateway</li><li>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’</li><li>route del 0/0 gw IP_gateway remove static route</li><li>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing</li><li>hostname show hostname of system</li><li>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(1)</li><li>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(2)</li><li>ip link show show link status of all interfaces</li><li>mii-tool eth0 show link status of ‘eth0’</li><li>ethtool eth0 show statistics of network card ‘eth0’</li><li>netstat -tup show all active network connections and their PID</li><li>netstat -tupl show all network services listening on the system and their PID</li><li>tcpdump tcp port 80 show all HTTP traffic</li><li>iwlist scan show wireless networks</li><li>iwconfig eth1 show configuration of a wireless network card</li><li>hostname show hostname</li><li>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</li><li>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</li><li>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database</li></ul></blockquote><h2 id="23-列出目录内容"><a href="#23-列出目录内容" class="headerlink" title="23. 列出目录内容"></a>23. 列出目录内容</h2><blockquote><ul><li>ls -a：显示所有文件（包括隐藏文件）；</li><li>ls -l：显示详细信息；</li><li>ls -R：递归显示子目录结构；</li><li>ls -ld：显示目录和链接信息；</li><li>ctrl+r：历史记录中所搜命令（输入命令中的任意一个字符）；</li><li>Linux中以.开头的文件是隐藏文件；</li><li>pwd:显示当前目录</li></ul></blockquote><h2 id="24-查看文件的类型"><a href="#24-查看文件的类型" class="headerlink" title="24. 查看文件的类型"></a>24. 查看文件的类型</h2><ul><li><blockquote><p>file:查看文件的类型</p></blockquote></li></ul><h2 id="25-复制文件目录"><a href="#25-复制文件目录" class="headerlink" title="25. 复制文件目录"></a>25. 复制文件目录</h2><p>1、<strong>cp</strong>：复制文件和目录 cp 源文件（文件夹）目标文件（文件夹）</p><blockquote><ul><li><p>常用参数：</p></li><li><p>-r:递归复制整个目录树；</p></li><li><p>-v：显示详细信息；</p></li><li><p>复制文件夹时要在 cp 命令后面加一个-r 参数：</p><p>如：cp -r 源文件夹 目标文件夹</p></li></ul></blockquote><p>2、<strong>touch+文件名</strong>：当文件不存在的时候，创建相应的文件；当文件存在的时候，修改文件的创建时间。</p><blockquote><ul><li><p>功能：生成一个空文件或修改文件的存取/修改的时间记录值。</p></li><li><p>touch *：将当前下的文件时间修改为系统的当前时间</p></li><li><p>touch –d 20040210 test：将 test 文件的日期改为 20040210</p></li><li><p>touch abc：若 abc 文件存在，则修改为系统的当前时间；若不存在，则生成一个为当前时间的空文件</p></li></ul></blockquote><p>3、<strong>mv 文件 目标目录</strong>：移动或重命名文件或目录（如果指定文件名，则可以重命名文件）。可以将文件及目录移到另一目录下，或更改文件及目录的名称。</p><blockquote><ul><li><p>格式为：mv [参数]&lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p></li><li><p>mva.txt ../：将 a.txt 文件移动上层目录</p></li><li><p>mv a.txt b.txt：将 a.txt 改名为 b.txt</p></li><li><p>mvdir2 ../：将 dir2 目录上移一层</p></li></ul></blockquote><p>4、<strong>rm</strong>：删除文件；</p><blockquote><p>常用参数：</p><ul><li>-i：交互式 </li><li>-r：递归的删除包括目录中的所有内容</li></ul></blockquote><p>5、<strong>mkdir +文件夹名称</strong>：创建文件夹；</p><p>6、<strong>rm -r +文件夹名称</strong>：删除文件夹（空文件夹和非空文件夹都可删除）</p><blockquote><ul><li>rmdir 文件夹名称：删除文件夹（只能删除空文件夹）</li></ul></blockquote><p>7、<strong>mkdir -p dir1/dir2</strong>：在当前目录下创建 dir1 目录，并在 dir1 目录下创建 dir2 目录， 也就是连续创建两个目录（dir1/和 dir1/dir2）</p><p>8、<strong>rmdir –p dir1/dir2</strong>：删除 dir1 下的 dir2 目录，若 dir1 目录为空也删除它</p><p>9、**rm ***：删除当前目录下的所有文件</p><p>10、**-f 参数**：强迫删除文件 rm –f *.txt：强迫删除所有以后缀名为 txt 文件</p><p>11、**-i 参数**：删除文件时询问</p><blockquote><ul><li><p>rm 　–i * ：删除当前目录下的所有文件会有如下提示：</p></li><li><p>rm:backup:is a directory  遇到目录会略过</p></li><li><p>rm: remove ‘myfiles.txt’ ? Y</p></li><li><p>删除文件时会询问,可按 Y 或 N 键表示允许或拒绝删除文件</p></li></ul></blockquote><p>12、**-r 参数**：递归删除（连子目录一同删除，这是一个相当常用的参数）</p><blockquote><ul><li><p>rm -r test ：删除 test 目录（含 test 目录下所有文件和子目录）</p></li><li><p>rm -r *：删除所有文件（含当前目录所有文件、所有子目录和子目录下的文件） </p></li><li><p>一般在删除目录时 r 和 f 一起用，避免麻烦</p></li><li><p>rm -rf test ：强行删除、不加询问</p></li></ul></blockquote><p>13、<strong>grep</strong>：功能：在文件中搜索匹配的字符并进行输出</p><blockquote><ul><li><p>格式：grep[参数] &lt;要找的字串&gt; &lt;要寻找字 串的源文件&gt;</p></li><li><p>greplinux test.txt：搜索 test.txt 文件中字符串 linux 并输出</p></li></ul></blockquote><p>14、<strong>ln 命令</strong></p><blockquote><ul><li><p>功能：在文件和目录之间建立链接</p></li><li><p>格式：ln [参数] &lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p></li><li><p>链接分“软链接”和“硬链接”</p></li><li><p>1.软链接:</p></li><li><p>ln–s /usr/share/do doc ：创建一个链接文件 doc,并指向目录/usr/share/do</p></li><li><p>2.硬链接:</p></li><li><p>ln /usr/share/test hard：创建一个硬链接文件 hard，这时对于 test 文件对应 的存储区域来说，又多了一个文件指向它</p></li></ul></blockquote><h2 id="26-系统常用命令"><a href="#26-系统常用命令" class="headerlink" title="26. 系统常用命令"></a>26. 系统常用命令</h2><h3 id="26-1、显示命令"><a href="#26-1、显示命令" class="headerlink" title="26.1、显示命令"></a>26.1、显示命令</h3><blockquote><ul><li><p>date:查看或设置当前系统的时间：格式化显示时间：+%Y–%m–%d；</p></li><li><p>date -s:设置当前系统的时间</p></li><li><p>hwclock(clock)：显示硬件时钟时间(需要管理员权限)；</p></li><li><p>cal：查看日历 格式 cal [参数] 月年</p></li><li><p>cal：显示当月的日历 cal7 2023：显示 2023 年 7 月的日历</p></li><li><p>cal- y 2023：显示 2023年的日历</p></li><li><p>uptime：查看系统运行时间</p></li></ul></blockquote><h3 id="26-2、输出查看命令"><a href="#26-2、输出查看命令" class="headerlink" title="26.2、输出查看命令"></a>26.2、输出查看命令</h3><blockquote><ul><li><p>echo：显示输入的内容 追加文件 echo “文件名” &gt;&gt; 文件名.txt</p></li><li><p>cat：显示文件内容,也可以将数个文件合并成一个文件。格式：格式：cat[参数]&lt;文件名&gt;</p></li><li><p>cat test.txt：显示 test.txt 文件内容</p></li><li><p>cat test.txt | more ：逐页显示 test.txt 文件中的内容</p></li><li><p>cat test.txt &gt;&gt; test1.txt ：将 test.txt 的内容附加到 test1.txt 文件之后</p></li><li><p>cat test.txt test2.txt &gt;readme.txt 　: 将 test.txt 和 test2.txt 文件合并成 readme.txt 文件</p></li><li><p>head:显示文件的头几行（默认 10 行） -n:指定显示的行数格式：head -n 文件名</p></li><li><p>tail：显示文件的末尾几行（默认 10 行）-n：指定显示的行数 -f：追踪显示文件更新 （一般用于查看日志，命令不会退出，而是持续显示新加入的内容）格式：格式：tail[参数]&lt;文件名&gt;</p></li><li><p>tail-10 /etc/passwd ：显示/etc/passwd/文件的倒数 10 行内容</p></li><li><p>tail+10 /etc/passwd ：显示/etc/passwd/文件从第 10 行开始到末尾的内容</p></li><li><p>more：用于翻页显示文件内容（只能向下翻页）</p></li><li><p>more 命令是一般用于要显示的内容会超过一个画面长度的情况。为了避免画 面显示时瞬间就闪过去，用户可以使用 more 命令，让画面在显示满一页时暂停，此时可按空格键继续显示下一个画面，或按 Q 键停止显示。</p></li><li><p>ls -al |more：以长格形式显示 etc 目录下的文件列表，显示满一个画面便暂停，可 按空格键继续显示下一画面，或按 Q 键跳离</p></li><li><p>less：翻页显示文件内容（带上下翻页）按下上键分页，按 q 退出、‘</p></li><li><p>less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同 的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 Q 键即可。</p></li><li><p>ls -al | less：以长格形式列出/etc 目录中所有的内容。用户可按上下键浏览或按 Q 键跳离</p></li></ul></blockquote><h3 id="26-3、查看硬件信息"><a href="#26-3、查看硬件信息" class="headerlink" title="26.3、查看硬件信息"></a>26.3、查看硬件信息</h3><blockquote><ul><li><p>Ispci：查看 PCI 设备 -v：查看详细信息</p></li><li><p>Isusb：查看 USB 设备 -v：查看详细信息</p></li><li><p>Ismod：查看加载的模块(驱动)</p></li></ul></blockquote><h3 id="26-4、关机、重启"><a href="#26-4、关机、重启" class="headerlink" title="26.4、关机、重启"></a>26.4、关机、重启</h3><blockquote><ul><li><p>shutdown 关闭、重启计算机</p></li><li><p>shutdown[关机、重启]时间 -h 关闭计算机 -r：重启计算机</p><ul><li>如：<ul><li>立即关机：shutdown -h now</li><li>10 分钟后关机：shutdown -h +10</li><li>23:30 分关机：shutdown -h 23:30</li><li>立即重启：shutdown -r now</li></ul></li></ul></li><li><p>poweroff：立即关闭计算机</p></li><li><p>reboot：立即重启计算机</p></li></ul></blockquote><h3 id="26-5、归档、压缩"><a href="#26-5、归档、压缩" class="headerlink" title="26.5、归档、压缩"></a>26.5、归档、压缩</h3><blockquote><ul><li><p>zip:压缩文件 zip liuyazhuang.zip myfile 格式为：“zip 压缩后的 zip 文件文件名”</p></li><li><p>unzip：解压文件 unzip liuyazhuang.zip</p></li><li><p>gzip：压缩文件 gzip 文件名</p></li><li><p>tar：归档文件</p></li><li><p>tar -cvf out.tar liuyazhuang 打包一个归档（将文件”liuyazhuang”打包成一个归档）</p></li><li><p>tar -xvf liuyazhuang.tar 释放一个归档（释放 liuyazhuang.tar 归档）</p></li><li><p>tar -cvzf backup.tar.gz/etc</p></li><li><p>-z 参数将归档后的归档文件进行 gzip 压缩以减少大小。</p></li><li><p>-c：创建一个新 tar 文件</p></li><li><p>-v：显示运行过程的信息</p></li><li><p>-f：指定文件名</p></li><li><p>-z：调用 gzip 压缩命令进行压缩</p></li><li><p>-t：查看压缩文件的内容</p></li><li><p>-x：解开 tar 文件</p></li><li><p>tar -cvf test.tar *：将所有文件打包成 test.tar,扩展名.tar 需自行加上</p></li><li><p>tar -zcvf test.tar.gz *：将所有文件打包成 test.tar,再用 gzip 命令压缩</p></li><li><p>tar -tf test.tar ：查看 test.tar 文件中包括了哪些文件</p></li><li><p>tar -xvf test.tar 将 test.tar 解开</p></li><li><p>tar -zxvf foo.tar.gz 解压缩</p></li><li><p>gzip 各 gunzip 命令</p></li><li><p>gziptest.txt ：压缩文件时，不需要任何参数</p></li><li><p>gizp–l test.txt.gz：显示压缩率</p></li></ul></blockquote><h3 id="26-6、查找"><a href="#26-6、查找" class="headerlink" title="26.6、查找"></a>26.6、查找</h3><blockquote><ul><li><p>locate：快速查找文件、文件夹：locate keyword</p></li><li><p>此命令需要预先建立数据库，数据库默认每天更新一次，可用 updatedb 命令手工建立、更新数据库。</p></li><li><p>find 查找位置查找参数</p><ul><li>如：<ul><li>find . -name<em>XXX</em>查找当前目录下名称中含有”XXX”的文件</li><li>find / -name *.conf 查找根目录下（整个硬盘）下后缀为.conf 的文件</li><li>find / -perm 777 查找所有权限是 777 的文件</li><li>find / -type d 返回根目录下所有的目录</li><li>find . -name “a*”-exec ls -l {} ;</li><li>find 功能：用来寻找文件或目录。</li><li>格式：find [&lt;路径&gt;][匹配条件]</li><li>find / -name httpd.conf 搜索系统根目录下名为 httpd.conf 的文件</li></ul></li></ul></li></ul></blockquote><h3 id="26-7、ctrl-c-终止当前的命令"><a href="#26-7、ctrl-c-终止当前的命令" class="headerlink" title="26.7、ctrl+c :终止当前的命令"></a>26.7、ctrl+c :终止当前的命令</h3><h3 id="26-8、who-或-w-命令"><a href="#26-8、who-或-w-命令" class="headerlink" title="26.8、who 或 w 命令"></a>26.8、who 或 w 命令</h3><blockquote><ul><li><p>功能：查看当前系统中有哪些用户登录</p></li><li><p>格式：who/w[参数]</p></li></ul></blockquote><h3 id="26-9、dmesg-命令"><a href="#26-9、dmesg-命令" class="headerlink" title="26.9、dmesg 命令"></a>26.9、dmesg 命令</h3><ul><li><blockquote><p>功能：显示系统诊断信息、操作系统版本号、物理内存的大小以及其它信息</p></blockquote></li></ul><h3 id="26-10、df-命令"><a href="#26-10、df-命令" class="headerlink" title="26.10、df 命令"></a>26.10、df 命令</h3><ul><li><blockquote><p>功能：用于查看文件系统的各个分区的占用情况</p></blockquote></li></ul><h3 id="26-11、du-命令"><a href="#26-11、du-命令" class="headerlink" title="26.11、du 命令"></a>26.11、du 命令</h3><blockquote><ul><li><p>功能：查看某个目录中各级子目录所使用的硬盘空间数</p></li><li><p>格式：du [参数] &lt;目录名&gt;</p></li></ul></blockquote><h3 id="26-12、free-命令"><a href="#26-12、free-命令" class="headerlink" title="26.12、free 命令"></a>26.12、free 命令</h3><ul><li><blockquote><p>功能：用于查看系统内存，虚拟内存（交换空间）的大小占用情况</p></blockquote></li></ul><h2 id="27-VIM"><a href="#27-VIM" class="headerlink" title="27. VIM"></a>27. VIM</h2><p>VIM 是一款功能强大的命令行文本编辑器，在 Linux 中通过 vim 命令可以启动 vim 编辑器。</p><p>一般使用 vim + 目标文件路径 的形式使用 vim</p><p>如果目标文件存在，则 vim 打开目标文件，如果目标文件不存在，则 vim 新建并打开该文件</p><p>:q：退出 vim 编辑器</p><p><strong>VIM 模式</strong></p><p>vim 拥有三种模式：</p><p><strong>（1）命令模式（常规模式）</strong></p><p>vim 启动后，默认进入命令模式，任何模式都可以通过 esc 键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。</p><p>命名模式常用命令如下：</p><blockquote><ul><li><p>i : 在光标前插入文本</p></li><li><p>o:在当前行的下面插入新行</p></li><li><p>dd:删除整行</p></li><li><p>yy：将当前行的内容放入缓冲区（复制当前行）</p></li><li><p>n+yy :将 n 行的内容放入缓冲区（复制 n 行）</p></li><li><p>p:将缓冲区中的文本放入光标后（粘贴）</p></li><li><p>u：撤销上一个操作</p></li><li><p>r:替换当前字符</p></li><li><p>/ 查找关键字</p></li></ul></blockquote><p><strong>（2）插入模式</strong></p><p>在命令模式下按 “ i “键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用 esc 键可以返回命令模式。</p><p><strong>（3）ex 模式</strong></p><p>在命令模式中按” : “键可以进入 ex 模式，光标会移动到底部，在这里可以保存修改或退出 vim.</p><p>ext 模式常用命令如下：</p><blockquote><ul><li><p>:w ：保存当前的修改</p></li><li><p>:q ：退出</p></li><li><p>:q! ：强制退出，保存修改</p></li><li><p>:x :保存并退出，相当于:wq</p></li><li><p>:set number 显示行号</p></li><li><p>:! 系统命令 执行一个系统命令并显示结果</p></li><li><p>:sh ：切换到命令行，使用 ctrl+d 切换回 vim</p></li></ul></blockquote><h2 id="28-软件包管理命令-RPM"><a href="#28-软件包管理命令-RPM" class="headerlink" title="28. 软件包管理命令(RPM)"></a>28. 软件包管理命令(RPM)</h2><h3 id="28-1、软件包的安装"><a href="#28-1、软件包的安装" class="headerlink" title="28.1、软件包的安装"></a>28.1、软件包的安装</h3><p>使用 RPM 命令的安装模式可以将软件包内所有的组件放到系统中的正确路径</p><p>命令:</p><blockquote><ul><li>rpm –ivh xxx-2.6.2-8.i386.rpm</li><li>i：作用 rpm 的安装模式 </li><li>v: 校验文件信息 </li><li>h: 以＃号显示安装进度</li></ul></blockquote><h3 id="28-2、软件包的删除"><a href="#28-2、软件包的删除" class="headerlink" title="28.2、软件包的删除"></a>28.2、软件包的删除</h3><p>删除模式会将指定软件包的内容全部删除，但并不包括已更改过的配置文件，删除 RPM 软件包</p><p>命令：</p><ul><li><blockquote><p>rpm –e xxx</p></blockquote></li></ul><p>注意：</p><ul><li><blockquote><p>这里必须使用软件名“xxx”或”xxx-2.6.2-8 而不是使用当初安装时的软件包名.xxx-2.6.2-8.i386.rpm</p></blockquote></li></ul><h3 id="28-3、软件包升级"><a href="#28-3、软件包升级" class="headerlink" title="28.3、软件包升级"></a>28.3、软件包升级</h3><p>升级模式会安装用户所指定的更新版本，并删除已安装在系统中的相同软件包，升级软件包</p><p>命令：</p><ul><li><blockquote><p>rpm –Uvh xxx-2.6.2-8.i386.rpm –Uvh：升级参数</p></blockquote></li></ul><h3 id="28-4、软件包更新"><a href="#28-4、软件包更新" class="headerlink" title="28.4、软件包更新"></a>28.4、软件包更新</h3><p>更新模式下，rpm 命令会检查在命令行中所指定的软件包是否比系统中原有的软件 包更新。如果情况属实，rpm 命令会自动更新指定的软件包；反之，若系统中并没有指定软件包的较旧版本，rpm 命令并不会安装此软件包。而在升级模式下，不管系统中是否有较旧的版本，rpm 命令都会安装指定的软件包。</p><ul><li><blockquote><p>rpm –Fvhxxx-2.6.2-8.i386.rpm -Fvh：更新参数</p></blockquote></li></ul><h3 id="28-5、软件包查询"><a href="#28-5、软件包查询" class="headerlink" title="28.5、软件包查询"></a>28.5、软件包查询</h3><p>若要获取 RPM 软件包的相关信息，可以使用查询模式。</p><blockquote><ul><li>使用-q 参数可查询一个已安装的软件包的内容<ul><li>rpm –q xxx</li></ul></li><li>查询软件包所安装的位置<ul><li>rpm –ql package-name</li><li>rpm –ql xv (l 参数：显示文件列表)</li></ul></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存溢出-String</title>
    <link href="/2023/06/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-String/"/>
    <url>/2023/06/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-String/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内存溢出-String"><a href="#内存溢出-String" class="headerlink" title="内存溢出-String"></a>内存溢出-String</h1><h3 id="JDK1-6方法举例："><a href="#JDK1-6方法举例：" class="headerlink" title="JDK1.6方法举例："></a>JDK1.6方法举例：</h3><p>String.substring(int beginIndex, int endIndex);源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a string that is a substring of this string. The</span><br><span class="hljs-comment">     * substring begins at the specified &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; and</span><br><span class="hljs-comment">     * extends to the character at index &#123;<span class="hljs-doctag">@code</span> endIndex - 1&#125;.</span><br><span class="hljs-comment">     * Thus the length of the substring is &#123;<span class="hljs-doctag">@code</span> endIndex-beginIndex&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Examples:</span><br><span class="hljs-comment">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment">     * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment">     * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment">     * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      beginIndex   the beginning index, inclusive.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      endIndex     the ending index, exclusive.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>     the specified substring.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  IndexOutOfBoundsException  if the</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is negative, or</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125; is larger than the length of</span><br><span class="hljs-comment">     *             this &#123;<span class="hljs-doctag">@code</span> String&#125; object, or</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is larger than</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> bedinIndex, <span class="hljs-type">int</span> endIndex)</span>&#123;<br>    <span class="hljs-keyword">if</span>(beginIndex &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(endIndex &gt; count)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(beginIndex &gt; endIndex)&#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex - beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(offset + beginIndex, endIndex - beginIndex, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>由源码分析可看出，substring方法在使用时，会构造一个新的String对象，问题所在也在此。</p><p>JDK1.6 String构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String(<span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count, <span class="hljs-type">char</span>[] value)&#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>    <span class="hljs-built_in">this</span>.offset = offset;<br>    <span class="hljs-built_in">this</span>.count = count;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.6中，String类的构造函数创建时非简单拷贝对象，而是将整个value引用。问题导致较大字符串就算不再被引用，内存也不会释放。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456789&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.substring(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">return</span> b;<br></code></pre></td></tr></table></figure><p>此处，字符串a只是临时的，而真正所用到的字符串b的内存数组，其实是从字符串a中共享所得。虽然字符串a本身可被回收，但其内存数据却不可释放，导致内存泄露。</p><h3 id="JDK1-8源码分析"><a href="#JDK1-8源码分析" class="headerlink" title="JDK1.8源码分析"></a>JDK1.8源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a string that is a substring of this string. The</span><br><span class="hljs-comment"> * substring begins at the specified &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; and</span><br><span class="hljs-comment"> * extends to the character at index &#123;<span class="hljs-doctag">@code</span> endIndex - 1&#125;.</span><br><span class="hljs-comment"> * Thus the length of the substring is &#123;<span class="hljs-doctag">@code</span> endIndex-beginIndex&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Examples:</span><br><span class="hljs-comment"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment"> * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment"> * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      beginIndex   the beginning index, inclusive.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      endIndex     the ending index, exclusive.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>     the specified substring.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@exception</span>  IndexOutOfBoundsException  if the</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is negative, or</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125; is larger than the length of</span><br><span class="hljs-comment"> *             this &#123;<span class="hljs-doctag">@code</span> String&#125; object, or</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is larger than</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-built_in">this</span><br>            : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.8 String构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allocates a new &#123;<span class="hljs-doctag">@code</span> String&#125; that contains characters from a subarray</span><br><span class="hljs-comment"> * of the character array argument. The &#123;<span class="hljs-doctag">@code</span> offset&#125; argument is the</span><br><span class="hljs-comment"> * index of the first character of the subarray and the &#123;<span class="hljs-doctag">@code</span> count&#125;</span><br><span class="hljs-comment"> * argument specifies the length of the subarray. The contents of the</span><br><span class="hljs-comment"> * subarray are copied; subsequent modification of the character array does</span><br><span class="hljs-comment"> * not affect the newly created string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  value</span><br><span class="hljs-comment"> *         Array that is the source of characters</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  offset</span><br><span class="hljs-comment"> *         The initial offset</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  count</span><br><span class="hljs-comment"> *         The length</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IndexOutOfBoundsException</span><br><span class="hljs-comment"> *          If the &#123;<span class="hljs-doctag">@code</span> offset&#125; and &#123;<span class="hljs-doctag">@code</span> count&#125; arguments index</span><br><span class="hljs-comment"> *          characters outside the bounds of the &#123;<span class="hljs-doctag">@code</span> value&#125; array</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span> value[], <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset + count);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在JDK1.8中，当我们需要一个子字符串的时候，substring 生成了一个新的字符串，这个字符串通过构造函数的 Arrays.copyOfRange 函数进行构造。此优化在JDK1.7时就已实现，新的实现虽然损失了性能，而且浪费了一些存储空间，但却保证了字符串的内部数组可以和字符串对象一起被回收，从而防止发生内存泄漏。</p>]]></content>
    
    
    <categories>
      
      <category>&lt;JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存溢出 JVM调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream流操作</title>
    <link href="/2023/06/10/JAVA%20Stream%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/10/JAVA%20Stream%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JAVA-Stream流操作"><a href="#JAVA-Stream流操作" class="headerlink" title="JAVA Stream流操作"></a>JAVA Stream流操作</h1><ul><li><p>Stream流操作分为<strong>3种类型</strong>：</p><ul><li><p>创建Stream</p></li><li><p>Stream中间处理</p></li><li><p>终止Steam</p></li></ul></li></ul><h3 id="Stream特性"><a href="#Stream特性" class="headerlink" title="Stream特性"></a>Stream特性</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1.stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。<br>2.stream不会改变数据源，通常情况下会产生一个新的集合或一个值。<br>3.stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。<br></code></pre></td></tr></table></figure><h3 id="Stream特点"><a href="#Stream特点" class="headerlink" title="Stream特点"></a>Stream特点</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.</span>代码简洁：函数编程写出的代码简洁且意图明确，使用stream接口让你从此告别<span class="hljs-keyword">for</span>循环。<br><span class="hljs-number">2.</span>多核友好：Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下方法。<br><span class="hljs-number">3.</span><span class="hljs-built_in">Stream</span>不存储数据。<br><span class="hljs-number">4.</span><span class="hljs-built_in">Stream</span>不会改变源对象。相反，他们会返回一个持有结果的新<span class="hljs-built_in">Stream</span>。<br><span class="hljs-number">5.</span><span class="hljs-built_in">Stream</span>是惰性求值的（延迟执行）<br></code></pre></td></tr></table></figure><h3 id="Stream创建"><a href="#Stream创建" class="headerlink" title="Stream创建"></a>Stream创建</h3><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1.创建 Stream一个数据源（如： 集合、数组）， 获取一个流。<br>2.中间操作一个中间操作链，对数据源的数据进行处理。<br>3.终止操作(终端操作)一个终止操作，执行中间操作链，并产生结果 。<br></code></pre></td></tr></table></figure><h4 id="创建示例"><a href="#创建示例" class="headerlink" title="创建示例"></a>创建示例</h4><ul><li>通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//获取一个顺序流</span><br>Stream&lt;String&gt; stream = list.stream();<br><span class="hljs-comment">//获取一个并行流</span><br>Stream&lt;String&gt; parallelStream = list.parallelStream();<br></code></pre></td></tr></table></figure><ul><li>使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br></code></pre></td></tr></table></figure><ul><li>使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>stream.forEach(System.out::println);<br>Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">3</span>).limit(<span class="hljs-number">4</span>);<br>stream2.forEach(System.out::println);<br>Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="hljs-number">3</span>);<br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h4 id="开始管道"><a href="#开始管道" class="headerlink" title="开始管道"></a>开始管道</h4><ul><li>主要负责新建一个Stream流，或者基于现有的数组、List、Set、Map等集合类型对象创建出新的Stream流。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>stream()</td><td>创建出一个新的stream串行流对象</td></tr><tr><td>parallelStream()</td><td>创建出一个可并行执行的stream流对象</td></tr><tr><td>Stream.of()</td><td>通过给定的一系列元素创建一个新的Stream串行流对象</td></tr></tbody></table><h4 id="中间管道"><a href="#中间管道" class="headerlink" title="中间管道"></a>中间管道</h4><ul><li>负责对Stream进行处理操作，并返回一个新的Stream对象，中间管道操作可以进行<strong>叠加</strong>。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>filter()</td><td>按照条件过滤符合要求的元素， 返回新的stream流</td></tr><tr><td>map()</td><td>将已有元素转换为另一个对象类型，一对一逻辑，返回新的stream流</td></tr><tr><td>flatMap()</td><td>将已有元素转换为另一个对象类型，一对多逻辑，即原来一个元素对象可能会转换为1个或者多个新类型的元素，返回新的stream流</td></tr><tr><td>limit()</td><td>仅保留集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>skip()</td><td>跳过集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>concat()</td><td>将两个流的数据合并起来为1个新的流，返回新的stream流</td></tr><tr><td>distinct()</td><td>对Stream中所有元素进行去重，返回新的stream流</td></tr><tr><td>sorted()</td><td>对stream中所有的元素按照指定规则进行排序，返回新的stream流</td></tr><tr><td>peek()</td><td>对stream流中的每个元素进行逐个遍历处理，返回处理后的stream流</td></tr></tbody></table><h4 id="终止管道"><a href="#终止管道" class="headerlink" title="终止管道"></a>终止管道</h4><ul><li>顾名思义，通过终止管道操作之后，Stream流将<strong>会结束</strong>，最后可能会执行某些逻辑处理，或者是按照要求返回某些执行后的结果数据。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>count()</td><td>返回stream处理后最终的元素个数</td></tr><tr><td>max()</td><td>返回stream处理后的元素最大值</td></tr><tr><td>min()</td><td>返回stream处理后的元素最小值</td></tr><tr><td>findFirst()</td><td>找到第一个符合条件的元素时则终止流处理</td></tr><tr><td>findAny()</td><td>找到任何一个符合条件的元素时则退出流处理，这个<strong>对于串行流时与findFirst相同，对于并行流时比较高效</strong>，任何分片中找到都会终止后续计算逻辑</td></tr><tr><td>anyMatch()</td><td>返回一个boolean值，类似于isContains(),用于判断是否有符合条件的元素</td></tr><tr><td>allMatch()</td><td>返回一个boolean值，用于判断是否所有元素都符合条件</td></tr><tr><td>noneMatch()</td><td>返回一个boolean值， 用于判断是否所有元素都不符合条件</td></tr><tr><td>collect()</td><td>将流转换为指定的类型，通过Collectors进行指定</td></tr><tr><td>toArray()</td><td>将流转换为数组</td></tr><tr><td>iterator()</td><td>将流转换为Iterator对象</td></tr><tr><td>foreach()</td><td>无返回值，对元素进行逐个遍历，然后执行给定的处理逻辑</td></tr></tbody></table><h2 id="Stream方法使用"><a href="#Stream方法使用" class="headerlink" title="Stream方法使用"></a>Stream方法使用</h2><h4 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h4><ul><li><p>map与flatMap都是用于转换已有的元素为其它元素，区别点在于：</p><ul><li><p>map <strong>必须是一对一的</strong>，即每个元素都只能转换为1个新的元素</p></li><li><p>flatMap <strong>可以是一对多的</strong>，即每个元素都可以转换为1个或者多个新的元素</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringToIntMap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;105&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;469&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>    <span class="hljs-comment">// 使用流操作</span><br>    List&lt;User&gt; results = ids.stream()<br>            .map(id -&gt; &#123;<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                user.setId(id);<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;)<br>            .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>[User&#123;id=<span class="hljs-string">&#x27;205&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;105&#x27;</span>&#125;,<br> User&#123;id=<span class="hljs-string">&#x27;308&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;469&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;627&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;193&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;111&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringToIntFlatmap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; sentences = Arrays.asList(<span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-string">&quot;coco&quot;</span>);<br>    <span class="hljs-comment">// 使用流操作</span><br>    List&lt;String&gt; results = sentences.stream()<br>            .flatMap(sentence -&gt; Arrays.stream(sentence.split(<span class="hljs-string">&quot; &quot;</span>)))<br>            .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>[hello, world, coco]<br></code></pre></td></tr></table></figure><ul><li>flatMap操作的时候是先将每个元素处理并返回一个新的Stream，然后将多个Stream展开合并为了一个完整的新的Stream。</li></ul><h4 id="peek和foreach"><a href="#peek和foreach" class="headerlink" title="peek和foreach"></a>peek和foreach</h4><ul><li><p>对元素进行遍历然后逐个的进行处理。</p></li><li><p>peek属于中间方法，只能作为管道中途的一个处理步骤，而没法直接执行得到结果，其后面必须还要有其它终止操作的时候才会被执行；</p></li><li><p>foreach属于终止方法，可以直接执行相关操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPeekAndforeach</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; sentences = Arrays.asList(<span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-string">&quot;coco&quot;</span>);<br>    <span class="hljs-comment">// 演示点1：仅peek操作，最终不会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before peek----&quot;</span>);<br>    sentences.stream().peek(sentence -&gt; System.out.println(sentence));<br>    System.out.println(<span class="hljs-string">&quot;----after peek----&quot;</span>);<br>    <span class="hljs-comment">// 演示点2：仅foreach操作，最终会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before foreach----&quot;</span>);<br>    sentences.stream().forEach(sentence -&gt; System.out.println(sentence));<br>    System.out.println(<span class="hljs-string">&quot;----after foreach----&quot;</span>);<br>    <span class="hljs-comment">// 演示点3：peek操作后面增加终止操作，peek会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before peek and count----&quot;</span>);<br>    sentences.stream().peek(sentence -&gt; System.out.println(sentence)).count();<br>    System.out.println(<span class="hljs-string">&quot;----after peek and count----&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>----before peek----<br>----after peek----<br>----before foreach----<br>hello world<br>coco<br>----after foreach----<br>----before peek and count----<br>hello world<br>coco<br>----after peek and count----<br></code></pre></td></tr></table></figure><h4 id="filter、sorted、distinct、limit"><a href="#filter、sorted、distinct、limit" class="headerlink" title="filter、sorted、distinct、limit"></a>filter、sorted、distinct、limit</h4><ul><li>都是常用的Stream的中间操作方法,可以根据需要选择一个或者多个进行组合使用，或者同时使用多个相同方法的组合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetTargetUsers</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Dept&gt; ids = Arrays.asList(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;99&quot;</span>,<span class="hljs-string">&quot;999&quot;</span>,<span class="hljs-string">&quot;9999&quot;</span>,<span class="hljs-string">&quot;99999&quot;</span>)<br>        .stream()<br>        <span class="hljs-comment">// 使用filter过滤掉不符合条件的数据</span><br>        .filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-comment">// 通过distinct对存量元素进行去重操作</span><br>        .distinct()<br>        <span class="hljs-comment">// 通过map操作将字符串转成整数类型</span><br>        .map(Integer::valueOf)<br>        <span class="hljs-comment">// 指定按照数字大小正序排列</span><br>        .sorted(Comparator.comparingInt(o -&gt; o))<br>        <span class="hljs-comment">// 使用limit截取排在前3位的元素</span><br>        .limit(<span class="hljs-number">3</span>)<br>        <span class="hljs-comment">// 使用map将id转为Dept对象类型</span><br>        .map(id -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(id))<br>        <span class="hljs-comment">// 使用collect终止操作将最终处理后的数据收集到list中</span><br>        .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="简单结果终止方法"><a href="#简单结果终止方法" class="headerlink" title="简单结果终止方法"></a>简单结果终止方法</h4><ul><li>count、max、min、findAny、findFirst、anyMatch、allMatch、nonneMatch,结果形式是数字、布尔值或者Optional对象值等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleStopOptions</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>);<br>    <span class="hljs-comment">// 统计stream操作后剩余的元素个数</span><br>    System.out.println(ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>).count());<br>    <span class="hljs-comment">// 判断是否有元素值等于205</span><br>    System.out.println(ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>).anyMatch(<span class="hljs-string">&quot;205&quot;</span>::equals));<br>    <span class="hljs-comment">// findFirst操作</span><br>    ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>            .findFirst()<br>            .ifPresent(s -&gt; System.out.println(<span class="hljs-string">&quot;findFirst:&quot;</span> + s));<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">6</span><br><span class="hljs-literal">true</span><br>findFirst:<span class="hljs-number">205</span><br></code></pre></td></tr></table></figure><p><strong>一旦被执行了终止操作之后，后续便不可以再读这个流执行其他的操作</strong></p><h4 id="结果收集终止方法"><a href="#结果收集终止方法" class="headerlink" title="结果收集终止方法"></a>结果收集终止方法</h4><ul><li><p>结果数据：</p><ul><li>一个集合类，比如List、Set或者HashMap等;</li><li>StringBuilder对象，支持将多个字符串进行拼接处理并输出拼接后结果;</li><li>一个可以记录个数或者计算总和的对象（数据批量运算统计）。</li></ul></li></ul><h5 id="◆生成集合"><a href="#◆生成集合" class="headerlink" title="◆生成集合"></a>◆生成集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCollectStopOptions</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Dept&gt; ids = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">17</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">22</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">23</span>));<br>    <span class="hljs-comment">// collect成list</span><br>    List&lt;Dept&gt; collectList = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toList());<br>    System.out.println(<span class="hljs-string">&quot;collectList:&quot;</span> + collectList);<br>    <span class="hljs-comment">// collect成Set</span><br>    Set&lt;Dept&gt; collectSet = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toSet());<br>    System.out.println(<span class="hljs-string">&quot;collectSet:&quot;</span> + collectSet);<br>    <span class="hljs-comment">// collect成HashMap，key为id，value为Dept对象</span><br>    Map&lt;Integer, Dept&gt; collectMap = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));<br>    System.out.println(<span class="hljs-string">&quot;collectMap:&quot;</span> + collectMap);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="◆生成拼接字符串"><a href="#◆生成拼接字符串" class="headerlink" title="◆生成拼接字符串"></a>◆生成拼接字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCollectJoinStrings</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinResult</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;拼接后：&quot;</span> + joinResult);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="◆数据批量数学运算"><a href="#◆数据批量数学运算" class="headerlink" title="◆数据批量数学运算"></a>◆数据批量数学运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNumberCalculate</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; ids = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>);<br>    <span class="hljs-comment">// 计算平均值</span><br>    <span class="hljs-type">Double</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.averagingInt(value -&gt; value));<br>    System.out.println(<span class="hljs-string">&quot;平均值：&quot;</span> + average);<br>    <span class="hljs-comment">// 数据统计信息</span><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">summary</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.summarizingInt(value -&gt; value));<br>    System.out.println(<span class="hljs-string">&quot;数据统计信息：&quot;</span> + summary);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并行Stream"><a href="#并行Stream" class="headerlink" title="并行Stream"></a>并行Stream</h4><h5 id="◆Stream-API代替for循环"><a href="#◆Stream-API代替for循环" class="headerlink" title="◆Stream API代替for循环"></a>◆Stream API代替for循环</h5><ul><li>省略</li></ul><h5 id="◆将数组转换为管道流"><a href="#◆将数组转换为管道流" class="headerlink" title="◆将数组转换为管道流"></a>◆将数组转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>Stream&lt;String&gt; nameStrs2 = Stream.of(array);<br>Stream&lt;String&gt; nameStrs3 = Stream.of(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="◆将集合类对象转换为管道流"><a href="#◆将集合类对象转换为管道流" class="headerlink" title="◆将集合类对象转换为管道流"></a>◆将集合类对象转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;&quot;</span>);<br>Stream&lt;String&gt; streamFromList = list.stream();<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(list);<br>Stream&lt;String&gt; streamFromSet = set.stream();<br></code></pre></td></tr></table></figure><h5 id="◆将文本文件转换为管道流"><a href="#◆将文本文件转换为管道流" class="headerlink" title="◆将文本文件转换为管道流"></a>◆将文本文件转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="hljs-string">&quot;file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="◆filter与谓语逻辑"><a href="#◆filter与谓语逻辑" class="headerlink" title="◆filter与谓语逻辑"></a>◆filter与谓语逻辑</h5><ul><li>Predicate接口</li></ul><h5 id="◆and语法（并集）"><a href="#◆and语法（并集）" class="headerlink" title="◆and语法（并集）"></a>◆and语法（并集）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.and(Employee.genderM))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆or语法（交集）"><a href="#◆or语法（交集）" class="headerlink" title="◆or语法（交集）"></a>◆or语法（交集）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.or(Employee.genderM))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆negate语法（取反）"><a href="#◆negate语法（取反）" class="headerlink" title="◆negate语法（取反）"></a>◆negate语法（取反）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.or(Employee.genderM).negate())<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="Stream管道流的map操作"><a href="#Stream管道流的map操作" class="headerlink" title="Stream管道流的map操作"></a>Stream管道流的map操作</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 全部转换成大写</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Coco&quot;</span>, <span class="hljs-string">&quot;Liming&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-string">&quot;lisa&quot;</span>);<br>List&lt;String&gt; collect = list.stream().map(String::toUpperCase).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="处理非字符串类型集合元素"><a href="#处理非字符串类型集合元素" class="headerlink" title="处理非字符串类型集合元素"></a>处理非字符串类型集合元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; lengths = alpha.stream()<br>        .map(String::length)<br>        .collect(Collectors.toList());<br><span class="hljs-comment">// [6, 4, 7, 5]</span><br>Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .mapToInt(String::length);<br><span class="hljs-number">6</span><br><span class="hljs-number">4</span><br><span class="hljs-number">7</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="处理对象数据格式转换"><a href="#处理对象数据格式转换" class="headerlink" title="处理对象数据格式转换"></a>处理对象数据格式转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将每一个Employee的年龄增加一岁</span><br><span class="hljs-comment">// 将性别中的“M”换成“male”，F换成Female</span><br> List&lt;Employee&gt; maped = list.stream()<br>            .peek(e -&gt; &#123;<br>                e.setAge(e.getAge() + <span class="hljs-number">1</span>);<br>                e.setGender(e.getGender().equals(<span class="hljs-string">&quot;M&quot;</span>)?<span class="hljs-string">&quot;male&quot;</span>:<span class="hljs-string">&quot;female&quot;</span>);<br>            &#125;).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;word&quot;</span>);<br><span class="hljs-comment">// map处理</span><br>words.stream()<br>        .map(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)));<br><span class="hljs-comment">// 输出</span><br>[[h,e,l,l,o],[w,o,r,l,d]]<br><span class="hljs-comment">// flatMap处理</span><br>words.stream()<br>        .flatMap(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)));<br><span class="hljs-comment">// 输出</span><br>[h,e,l,l,o,w,o,r,l,d]<br></code></pre></td></tr></table></figure><h3 id="状态与并行操作"><a href="#状态与并行操作" class="headerlink" title="状态与并行操作"></a>状态与并行操作</h3><h4 id="中间操作：有状态与无状态"><a href="#中间操作：有状态与无状态" class="headerlink" title="中间操作：有状态与无状态"></a>中间操作：有状态与无状态</h4><ul><li><p>filter与map操作，不需要管道流的前面后面元素相关，所以不需要额外的记录元素之间的关系。输入一个元素，获得一个结果。</p></li><li><p>sorted是排序操作、distinct是去重操作。像这种操作都是和别的元素相关的操作，我自己无法完成整体操作。就像班级点名就是无状态的，喊到你你就答到就可以了。如果是班级同学按大小个排序，那就不是你自己的事了，你得和周围的同学比一下身高并记住，你记住的这个身高比较结果就是一种“状态”。所以这种操作就是有状态操作。</p><h5 id="◆Limit与Skip管道数据截取"><a href="#◆Limit与Skip管道数据截取" class="headerlink" title="◆Limit与Skip管道数据截取"></a>◆Limit与Skip管道数据截取</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; limitN = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .limit(<span class="hljs-number">2</span>)<br>        .collect(Collectors.toList());<br>List&lt;String&gt; skipN = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .skip(<span class="hljs-number">2</span>)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li><p>limt方法传入一个整数n，用于截取管道中的前n个元素。经过管道处理之后的数据是：[Monkey, Lion]。</p></li><li><p>skip方法与limit方法的使用相反，用于跳过前n个元素，截取从n到末尾的元素。经过管道处理之后的数据是：[Giraffe, Lemur]。</p><h5 id="◆Distinct元素去重"><a href="#◆Distinct元素去重" class="headerlink" title="◆Distinct元素去重"></a>◆Distinct元素去重</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; uniqueAnimals = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>)<br>    .distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆Sorted排序"><a href="#◆Sorted排序" class="headerlink" title="◆Sorted排序"></a>◆Sorted排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; alphabeticOrder = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .sorted()<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆串行、并行与顺序"><a href="#◆串行、并行与顺序" class="headerlink" title="◆串行、并行与顺序"></a>◆串行、并行与顺序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>)<br>    .parallel()<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure><ul><li>parallel()函数表示对管道中的元素进行并行处理,元素的顺序无法保证。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparator接口</span><br>list.stream().sorted(Comparator.naturalOrder());<br><span class="hljs-comment">// Comparator.naturalOrder()-&gt;自然排序</span><br><span class="hljs-comment">// Comparator.reverseOrder()-&gt;倒序排序</span><br></code></pre></td></tr></table></figure><ul><li>对象字段排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(Comparator.comparing(User::getAge));<br><span class="hljs-comment">// 倒序</span><br>users.sort(Comparator.comparing(User::getAge).reversed());<br></code></pre></td></tr></table></figure><ul><li>Comparator链对List排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(<br>        Comparator.comparing(User::getGender)<br>        .thenComparing(User::getAge)<br>        .reversed()<br>);<br><span class="hljs-comment">// 都是正序 ，不加reversed</span><br><span class="hljs-comment">// 都是倒序，最后面加一个reserved</span><br><span class="hljs-comment">// 先是倒序（加reserved），然后正序</span><br><span class="hljs-comment">// 先是正序（加reserved），然后倒序（加reserved）</span><br></code></pre></td></tr></table></figure><h3 id="函数式接口Comparator"><a href="#函数式接口Comparator" class="headerlink" title="函数式接口Comparator"></a>函数式接口Comparator</h3><h4 id="只能有一个抽象方法的接口"><a href="#只能有一个抽象方法的接口" class="headerlink" title="只能有一个抽象方法的接口"></a><strong>只能有一个抽象方法的接口</strong></h4><h5 id="◆函数式接口的特点"><a href="#◆函数式接口的特点" class="headerlink" title="◆函数式接口的特点"></a>◆函数式接口的特点</h5><ul><li>接口有且仅有一个抽象方法；</li><li>允许定义静态非抽象方法；</li><li>允许定义默认defalut非抽象方法（default方法也是java8才有的，见下文）；</li><li>允许java.lang.Object中的public方法，如：equals方法；</li><li>FunctionInterface注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错,见源码查看。</li><li><strong>lambda表达式是只实现接口中唯一的抽象方法的匿名实现类</strong>。</li></ul><h5 id="◆default关键字"><a href="#◆default关键字" class="headerlink" title="◆default关键字"></a>◆default关键字</h5><ul><li><p>java8之前</p><ul><li>接口是不能有方法的实现，所有方法全都是抽象方法</li><li>实现接口就必须实现接口里面的所有方法</li><li>问题：<strong>当一个接口有很多的实现类的时候,修改这个接口就变成了一个非常麻烦的事,需要修改这个接口的所有实现类</strong>。</li></ul></li><li><p>java8引入default方法</p><ul><li><p>default方法可以有自己的默认实现，即有方法体。</p></li><li><p>接口实现类可以不去实现default方法，并且可以使用default方法。</p></li></ul></li></ul><h5 id="◆JDK中的函数式接口举例"><a href="#◆JDK中的函数式接口举例" class="headerlink" title="◆JDK中的函数式接口举例"></a>◆JDK中的函数式接口举例</h5><ul><li><p>java.lang.Runnable,</p></li><li><p>java.util.Comparator,</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.util.function包下的接口，如Consumer、Predicate、Supplier等</p></li></ul><h5 id="◆自定义Comparator排序"><a href="#◆自定义Comparator排序" class="headerlink" title="◆自定义Comparator排序"></a>◆自定义Comparator排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User u1, User u2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(u1.getAge() == u2.getAge())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge() &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// lambda</span><br>users.sort((u1,u2) -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(u1.getAge() == u2.getAge())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge() &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="查找与匹配元素"><a href="#查找与匹配元素" class="headerlink" title="查找与匹配元素"></a>查找与匹配元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// anyMatch 一个符合就可以</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan70</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(Employee.ageGreaterThan70);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan72</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">72</span>);<br><span class="hljs-comment">// allMatch 全部符合</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan10</span> <span class="hljs-operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">10</span>);<br><span class="hljs-comment">// noneMatch 全部不符合</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeLess18</span> <span class="hljs-operator">=</span> employees.stream().noneMatch(e -&gt; e.getAge() &lt; <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h4 id="元素查找与Optional"><a href="#元素查找与Optional" class="headerlink" title="元素查找与Optional"></a>元素查找与Optional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查找第一个年龄大于40的员工</span><br>Optional&lt;Employee&gt; employeeOptional = employees.stream()<br>    .filter(e -&gt; e.getAge() &gt; <span class="hljs-number">40</span>).findFirst();<br></code></pre></td></tr></table></figure><ul><li>Optional类代表一个值存在或者不存在</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">isPresent() 将在 Optional 包含值的时候返回 true,否则返回 false;<br>ifPresent(Consumer block) 会在值存在的时候执行给定的代码块;<br>T get() 会在值存在时返回值，否则?出一个 NoSuchElement 异常;<br>T orElse(T other) 会在值存在时返回值,否则返回一个默认值;<br>findFirst用于查找第一个符合“匹配规则”的元素，返回值为Optional;<br>findAny用于查找任意一个符合“匹配规则”的元素，返回值为Optional。<br></code></pre></td></tr></table></figure><h3 id="元素归约"><a href="#元素归约" class="headerlink" title="元素归约"></a>元素归约</h3><ul><li><p>Stream.reduce用来实现集合元素的归约，reduce函数有三个参数：</p><ul><li>Identity标识：一个元素，它是归约操作的初始值，如果流为空，则为默认结果。</li><li>Accumulator累加器：具有两个参数的函数：归约运算的部分结果和流的下一个元素。</li><li>Combiner合并器（可选）：当归约并行化时，或当累加器参数的类型与累加器实现的类型不匹配时，用于合并归约操作的部分结果的函数。累加器：阶段累加结果作为累加器的第一个参数；集合遍历元素作为累加器的第二个参数。</li><li>reduce初始值为0，累加器可以是lambda表达式，也可以是方法引用。</li></ul></li></ul><h4 id="Integer类型归约"><a href="#Integer类型归约" class="headerlink" title="Integer类型归约"></a>Integer类型归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers<br>        .stream()<br>        .reduce(<span class="hljs-number">0</span>, (subtotal, element) -&gt; subtotal + element);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers<br>        .stream()<br>        .reduce(<span class="hljs-number">0</span>, Integer::sum);<br><span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h4 id="String类型归约"><a href="#String类型归约" class="headerlink" title="String类型归约"></a>String类型归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; letters = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> letters<br>        .stream()<br>        .reduce(<span class="hljs-string">&quot;&quot;</span>, (partialString, element) -&gt; partialString + element);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> letters<br>        .stream()<br>        .reduce(<span class="hljs-string">&quot;&quot;</span>, String::concat);<br><span class="hljs-comment">// abcde</span><br></code></pre></td></tr></table></figure><h4 id="复杂对象归约"><a href="#复杂对象归约" class="headerlink" title="复杂对象归约"></a>复杂对象归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算所有的员工的年龄总和。</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees.stream().map(Employee::getAge).reduce(<span class="hljs-number">0</span>,Integer::sum);<br></code></pre></td></tr></table></figure><h4 id="Combiner合并器的使用"><a href="#Combiner合并器的使用" class="headerlink" title="Combiner合并器的使用"></a>Combiner合并器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees.stream()<br>        .reduce(<span class="hljs-number">0</span>,(totalAge,emp) -&gt; totalAge + emp.getAge(),Integer::sum); <br><span class="hljs-comment">// 并行</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees<br>        .parallelStream()<br>        .map(Employee::getAge)<br>        .reduce(<span class="hljs-number">0</span>,Integer::sum,Integer::sum);<br></code></pre></td></tr></table></figure><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收集为Set，Set会去重</span><br>Set&lt;String&gt; collectToSet = Stream.of(...).collect(Collectors.toSet());<br><span class="hljs-comment">// 收集为List</span><br>List&lt;String&gt; collectToList = Stream.of(...).collect(Collectors.toList());<br><span class="hljs-comment">// 通用的收集</span><br>LinkedList&lt;String&gt; collectToCollection = Stream.of(...)<br>    .collect(Collectors.toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br><span class="hljs-comment">// 收集到Array</span><br>String[] toArray = Stream.of(...).toArray(String[]::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">// 收集到Map</span><br>Map&lt;String, Integer&gt; toMap = Stream.of(...)<br>.distinct()<br>.collect(Collectors.toMap(<br>       Function.identity(),   <span class="hljs-comment">// key</span><br>       s -&gt; (<span class="hljs-type">int</span>) s.chars().distinct().count()<span class="hljs-comment">// value</span><br>));<br><span class="hljs-comment">// 分组收集groupingBy</span><br>Map&lt;Character, List&lt;String&gt;&gt; groupingByList = Stream.of(...)<br>.collect(Collectors.groupingBy(<br>       s -&gt; 条件, 收集器<br>));<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断管道中是否包含2，结果是: true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">containsTwo</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).anyMatch(i -&gt; i == <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 管道中元素数据总计结果nrOfAnimals: 4</span><br><span class="hljs-type">long</span> <span class="hljs-variable">nrOfAnimals</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>).count();<br><br><span class="hljs-comment">// 管道中元素数据累加结果sum: 6</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br><br><span class="hljs-comment">// 管道中元素数据平均值average: OptionalDouble[2.0]</span><br><span class="hljs-type">OptionalDouble</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).average();<br><br><span class="hljs-comment">// 管道中元素数据最大值max: 3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).max().orElse(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 全面统计的结果statistics: IntSummaryStatistics&#123;count=3, sum=6, min=1, average=2.000000, max=3&#125;</span><br><span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).summaryStatistics();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;流</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2023/05/27/mybatis/"/>
    <url>/2023/05/27/mybatis/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="用来循环容器的标签forEach-查看例子"><a href="#用来循环容器的标签forEach-查看例子" class="headerlink" title="用来循环容器的标签forEach,查看例子"></a><strong>用来循环容器的标签forEach,查看例子</strong></h3><ul><li><p>foreach元素的属性主要有item，index，collection，open，separator，close。</p><ul><li><p>item：集合中元素迭代时的别名，</p></li><li><p>index：集合中元素迭代时的索引</p></li><li><p>open：常用语where语句中，表示以什么开始，比如以’(‘开始</p></li><li><p>separator：表示在每次进行迭代时的分隔符，</p></li><li><p>close 常用语where语句中，表示以什么结束，</p></li></ul></li></ul><ul><li><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p><ul><li><p>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</p></li><li><p>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</p></li><li><p>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</p></li></ul></li></ul><ul><li><p>针对最后一条，我们来看一下官方说法：</p></li><li><blockquote><p>注意 你可以将一个 List 实例或者数组作为参数对象传给 MyBatis，当你这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。</p></blockquote><p>所以，不管是多参数还是单参数的list,array类型，都可以封装为map进行传递。如果传递的是一个List，则mybatis会封装为一个list为key，list值为object的map，如果是array，则封装成一个array为key，array的值为object的map，如果自己封装呢，则colloection里放的是自己封装的map里的key值</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">//mapper中我们要为这个方法传递的是一个容器,将容器中的元素一个一个的//拼接到xml的方法中就要使用这个forEach这个标签了public List<span class="hljs-tag">&lt;<span class="hljs-name">Entity</span>&gt;</span> queryById(List<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> userids);<br>    //对应的xml中如下<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseReslutMap&quot;</span> &gt;</span><br>    select * FROM entity<br>    where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;userids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;userid&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;userid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="concat模糊查询"><a href="#concat模糊查询" class="headerlink" title="concat模糊查询"></a><strong>concat模糊查询</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">//比如说我们想要进行条件查询,但是几个条件不是每次都要使用,那么我们就可以//通过判断是否拼接到sql中       <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BascResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;entity&quot;</span>&gt;</span><br>    SELECT * from entity<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span><br>                name like concat(&#x27;%&#x27;,concat(#&#123;name&#125;,&#x27;%&#x27;))<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="choose-when-otherwise-标签"><a href="#choose-when-otherwise-标签" class="headerlink" title="choose (when, otherwise)标签"></a><strong>choose (when, otherwise)标签</strong></h3><p>choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。</p><p>例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_user&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.yiibai.pojo.User&quot;</span>&gt;</span><br>      SELECT *<br>        FROM User u<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username !=null &quot;</span>&gt;</span><br>                    u.username LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;username, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex != &#x27;&#x27; &quot;</span>&gt;</span><br>                    AND u.sex = #&#123;sex, jdbcType=INTEGER&#125;<br>                &lt;/when &gt;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null &quot;</span>&gt;</span><br>                    AND u.age = #&#123;age, jdbcType=INTEGER&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>          <br>                <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>          <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>      <br>         <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="selectKey-标签"><a href="#selectKey-标签" class="headerlink" title="selectKey 标签"></a><strong>selectKey 标签</strong></h3><p>在insert语句中，在Oracle经常使用序列、在MySQL中使用函数来自动生成插入表的主键，而且需要方法能返回这个生成主键。使用myBatis的selectKey标签可以实现这个效果。</p><p>下面例子，使用mysql数据库自定义函数nextval(‘student’)，用来生成一个key，并把他设置到传入的实体类中的studentId属性上。所以在执行完此方法后，边可以通过这个实体类获取生成的key。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 插入学生 自动主键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;createStudentAutoKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;liming.student.manager.data.model.StudentEntity&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;studentId&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;studentId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        select nextval(&#x27;student&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span>&gt;</span><br>    INSERT INTO<br>M_STUDENT(STUDENT_ID,STUDENT_SEX,STUDENT_BIRTHDAY,STUDENT_PHOTO,CLASS_ID,PLACE_ID)   VALUES (#&#123;studentId&#125;,#&#123;studentName&#125;,#&#123;studentSex&#125;,#&#123;studentBirthday&#125;,#&#123;studentPhoto,javaType=byte[],jdbcType=BLOB,typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,#&#123;classId&#125;,#&#123;placeId&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用接口方法，和获取自动生成key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>entity.setStudentName(<span class="hljs-string">&quot;黎明你好&quot;</span>);<br>entity.setStudentSex(<span class="hljs-number">1</span>);<br>entity.setStudentBirthday(DateUtil.parse(<span class="hljs-string">&quot;1985-05-28&quot;</span>));<br>entity.setClassId(<span class="hljs-string">&quot;20000001&quot;</span>);<br>entity.setPlaceId(<span class="hljs-string">&quot;70000001&quot;</span>);<br><span class="hljs-built_in">this</span>.dynamicSqlMapper.createStudentAutoKey(entity);<br>System.out.println(<span class="hljs-string">&quot;新增学生ID: &quot;</span> + entity.getStudentId());<br></code></pre></td></tr></table></figure><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a><strong>if标签</strong></h3><p>if标签可用在许多类型的sql语句中，我们以查询为例。首先看一个很普通的查询：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 查询学生list，like姓名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListLikeName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;StudentEntity&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>    SELECT * from M_STUDENT ms<br>    WHERE ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName&#125;),&#x27;%&#x27;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>但是此时如果studentName为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。</p><p>参数为实体类StudentEntity。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2 if(判断参数) - 将实体类不为空的属性作为where条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;liming.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID, ms.STUDENT_NAME, ms.STUDENT_SEX, ms.STUDENT_BIRTHDAY,      ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID <br>    FROM M_STUDENT ms<br>    WHERE<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>        ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>        AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>        AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span>      <br>        AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用时比较灵活， new一个这样的实体类，我们需要限制那个条件，只需要附上相应的值就会where这个条件，相反不去赋值就可以不在where中判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>    entity.setStudentName(<span class="hljs-string">&quot;&quot;</span>);<br>    entity.setStudentSex(<span class="hljs-number">1</span>);<br>    entity.setStudentBirthday(DateUtil.parse(<span class="hljs-string">&quot;2023-05-28&quot;</span>));                 <br>    entity.setClassId(<span class="hljs-string">&quot;20000001&quot;</span>);<br> entity.setPlaceId(<span class="hljs-string">&quot;70000001&quot;</span>);<br> List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentList(entity);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>     System.out.println(e.toString());<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-where-的条件判断"><a href="#if-where-的条件判断" class="headerlink" title="if + where 的条件判断"></a><strong>if + where 的条件判断</strong></h3><p>当where中的条件使用的if标签较多时，这样的组合可能会导致错误。我们以在3.1中的查询语句为例子，当java代码按如下方法调用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>    entity.setStudentName(<span class="hljs-literal">null</span>);<br>    entity.setStudentSex(<span class="hljs-number">1</span>);<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentList(entity);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上面例子，参数studentName为null，将不会进行STUDENT_NAME列的判断，则会直接导“WHERE AND”关键字多余的错误SQL。</p><p>这时我们可以使用where动态语句来解决。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><p>上面例子修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 3 select - where/if(判断参数) - 将实体类不为空的属性作为where条件 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,    ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>            ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="if-set实现修改语句"><a href="#if-set实现修改语句" class="headerlink" title="if + set实现修改语句"></a><strong>if + set实现修改语句</strong></h3><p>当update语句中没有使用if标签时，如果有一个参数为null，都会导致错误。</p><p>当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。使用if+set标签修改后，如果某项为null则不进行更新，而是保持数据库原值。</p><p>如下示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 4 if/set(判断参数) - 将实体类不为空的属性更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    UPDATE M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName != null and studentName != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_NAME = #&#123;studentName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_SEX = #&#123;studentSex&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            ms.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentPhoto != null &quot;</span>&gt;</span><br>            ms.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.CLASS_ID = #&#123;classId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.PLACE_ID = #&#123;placeId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    WHERE ms.STUDENT_ID = #&#123;studentId&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="if-trim代替where-set标签"><a href="#if-trim代替where-set标签" class="headerlink" title="if + trim代替where/set标签"></a><strong>if + trim代替where/set标签</strong></h3><p>trim是更灵活的去处多余关键字的标签，他可以实践where和set的效果。</p><h4 id="trim代替where"><a href="#trim代替where" class="headerlink" title="trim代替where"></a><strong>trim代替where</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.1 if/trim代替where(判断参数) -将实体类不为空的属性作为where条件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,       ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND|OR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>            ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="trim代替set"><a href="#trim代替set" class="headerlink" title="trim代替set"></a><strong>trim代替set</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.2 if/trim代替set(判断参数) - 将实体类不为空的属性更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    UPDATE M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName != null and studentName != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_NAME = #&#123;studentName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_SEX = #&#123;studentSex&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>        ms.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentPhoto != null &quot;</span>&gt;</span><br>            ms.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.CLASS_ID = #&#123;classId&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.PLACE_ID = #&#123;placeId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    WHERE ms.STUDENT_ID = #&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h3><p>对于动态SQL 非常必须的，主是要迭代一个集合，通常是用于IN 条件。List 实例将使用“list”做为键，数组实例以“array” 做为键。</p><p>foreach元素是非常强大的，它允许你指定一个集合，声明集合项和索引变量，它们可以用在元素体内。它也允许你指定开放和关闭的字符串，在迭代之间放置分隔符。这个元素是很智能的，它不会偶然地附加多余的分隔符。</p><blockquote><p>注意：你可以传递一个List实例或者数组作为参数对象传给MyBatis。当你这么做的时候，MyBatis会自动将它包装在一个Map中，用名称在作为键。List实例将会以“list”作为键，而数组实例将会以“array”作为键。</p></blockquote><p>这个部分是对关于XML配置文件和XML映射文件的而讨论的。下一部分将详细讨论Java API，所以你可以得到你已经创建的最有效的映射。</p><h4 id="参数为array示例的写法"><a href="#参数为array示例的写法" class="headerlink" title="参数为array示例的写法"></a><strong>参数为array示例的写法</strong></h4><p>接口的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title function_">getStudentListByClassIds_foreach_array</span><span class="hljs-params">(String[] classIds)</span>;<br></code></pre></td></tr></table></figure><p>动态SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 7.1 foreach(循环array参数) - 作为where中in的条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListByClassIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,     ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    WHERE ms.CLASS_ID IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;classIds&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;classIds&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码，查询学生中，在20000001、20000002这两个班级的学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>    String[] classIds = &#123; <span class="hljs-string">&quot;20000001&quot;</span>, <span class="hljs-string">&quot;20000002&quot;</span> &#125;;<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentListByClassIds(classIds);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数为list示例的写法"><a href="#参数为list示例的写法" class="headerlink" title="参数为list示例的写法"></a><strong>参数为list示例的写法</strong></h4><p>接口的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title function_">getStudentListByClassIds</span><span class="hljs-params">(List&lt;String&gt; classIdList)</span>;<br></code></pre></td></tr></table></figure><p>动态SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 7.2 foreach(循环List&lt;String&gt;参数) - 作为where中in的条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListByClassIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,     ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    WHERE ms.CLASS_ID IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;classIdList&quot;</span>  <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>          #&#123;classIdList&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码，查询学生中，在20000001、20000002这两个班级的学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>    ArrayList&lt;String&gt; classIdList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    classIdList.add(<span class="hljs-string">&quot;20000001&quot;</span>);<br>    classIdList.add(<span class="hljs-string">&quot;20000002&quot;</span>);<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentListByClassIds(classIdList);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sql片段标签<code>&lt;sql&gt;</code>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性</p><p>需要配置的属性：id=”” &gt;&gt;&gt;表示需要改sql语句片段的唯一标识</p><p>引用：通过<code>&lt;include refid=&quot;&quot; /&gt;</code>标签引用，refid=”” 中的值指向需要引用的<code>&lt;sql&gt;</code>中的id=“”属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义sql片段--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderAndItem&quot;</span>&gt;</span>   t1.order_id,t1.cid,t1.address,t1.create_date,t1.item,t2.item,t2.product_id,t2.count<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findOrderAndItemsByOid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>    select  <span class="hljs-comment">&lt;!--引用sql片段--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;orderAndItem&quot;</span> /&gt;</span><br>    from table1 t1<br>    join table2 t2 on t1.item = t2.item<br>    where t1.order_id = #&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口优化</title>
    <link href="/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
    <url>/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="接口优化方案总结"><a href="#接口优化方案总结" class="headerlink" title="接口优化方案总结"></a><strong>接口优化方案总结</strong></h2><p>近期接口优化的一些总结：</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="1-批处理"><a href="#1-批处理" class="headerlink" title="1.批处理"></a><strong>1.批处理</strong></h3><p>批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//for循环单笔入库</span><br>list.stream().forEatch(l -&gt; &#123;<br>insert();<br>&#125;);<br><span class="hljs-comment">//批量入库batchInsert();</span><br></code></pre></td></tr></table></figure><h3 id="2-异步处理"><a href="#2-异步处理" class="headerlink" title="2. 异步处理"></a><strong>2. 异步处理</strong></h3><p>异步思想：针对耗时比较长且不是结果必须的逻辑，我们可以考虑放到异步执行，这样能降低接口耗时。</p><h3 id="3-空间换时间"><a href="#3-空间换时间" class="headerlink" title="3. 空间换时间"></a><strong>3. 空间换时间</strong></h3><p>合理使用缓存，针对一些频繁使用且不频繁变更的数据，可以提前缓存起来，需要时直接查缓存，避免频繁地查询数据库或者重复计算。需要注意空间换时间也是一把双刃剑，需要综合考虑使用场景，缓存带来的数据一致性问题也挺令人头疼。</p><h3 id="4-预处理"><a href="#4-预处理" class="headerlink" title="4. 预处理"></a><strong>4. 预处理</strong></h3><p>预取思想，提前把查询的数据计算好，封装好，放入缓存或者表中的某个字段，用的时候会大幅提高接口性能。</p><h3 id="5-池化思想"><a href="#5-池化思想" class="headerlink" title="5. 池化思想"></a><strong>5. 池化思想</strong></h3><p>我们都用过数据库连接池，线程池等，这就是池思想的体现，它们解决的问题就是避免重复创建对象或创建连接，可以重复利用，避免不必要的损耗，因为创建销毁也会占用时间。</p><p>池化思想包含但并不局限于以上两种，总的来说池化思想的本质是<strong>预分配与循环使用</strong>。</p><h3 id="6-串行改并行"><a href="#6-串行改并行" class="headerlink" title="6. 串行改并行"></a><strong>6. 串行改并行</strong></h3><p>串行就是，当前执行逻辑必须等上一个执行逻辑结束之后才执行，并行就是两个执行逻辑互不干扰，所以并行相对来说就比较节省时间，当然是建立在没有结果参数依赖的前提下。</p><h3 id="7-索引"><a href="#7-索引" class="headerlink" title="7. 索引"></a><strong>7. 索引</strong></h3><p>加索引能大大提高数据查询效率，这个在接口设计之出也会考虑到</p><p>索引失效常见情景：</p><p>① 隐式类型转换；</p><p>② select * ；</p><p>③ 对索引进行列运算(+、-、*、/)；</p><p>④ 不满足最左匹配原则；</p><p>⑤ 使用or关键字；</p><p>⑥ not in 和 not exists；</p><p>⑦ order by 和搜索列不匹配；</p><p>⑧ 使用&lt;、&gt;、!=;</p><p>⑨ like以通配符开头(‘%xxx’)</p><h3 id="8-避免大事务"><a href="#8-避免大事务" class="headerlink" title="8. 避免大事务"></a><strong>8. 避免大事务</strong></h3><p>所谓大事务问题，就是<strong>运行时间较长的事务，</strong>由于事务一致不提交，会导致数据库连接被占用，影响到别的请求访问数据库，影响别的接口性能。事务中嵌套 RPC 调用，即非 DB 操作，这些非 DB 操作如果耗时较大的话，可能会出现大事务问题。大数据引发的问题主要有：死锁、接口超时、主从延迟等。所以为避免大事务问题，我们可以通过以下方案规避：</p><p>① RPC调用不放到事务里面;</p><p>② 查询操作尽量放到事务之外;</p><p>③ 事务中避免处理太多数据。</p><h3 id="9-优化程序结构"><a href="#9-优化程序结构" class="headerlink" title="9. 优化程序结构"></a><strong>9. 优化程序结构</strong></h3><p>程序结构问题一般出现在多次需求迭代后，代码叠加形成。会造成一些重复查询、多次创建对象等耗时问题。在多人维护一个项目时比较多见。解决起来也比较简单，我们需要针对接口整体做重构，评估每个代码块的作用和用途，调整执行顺序。</p><h3 id="10-深分页问题"><a href="#10-深分页问题" class="headerlink" title="10. 深分页问题"></a><strong>10. 深分页问题</strong></h3><p>深分页问题比较常见，分页我们一般最先想到的就是 limit，为什么会慢，如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderTime <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>,<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>limit 100000,200 意味着会扫描 100200 行，然后返回 200 行，丢弃掉前 100000 行。所以执行速度很慢。一般可以采用标签记录法来优化，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <br><span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> limit <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>这样优化的好处是命中了主键索引，无论多少页，性能都还不错，但是局限性是需要一个连续自增的字段。</p><p>避免使用select *，其实select后字段名全写，也比 * 效率高很多。</p><h3 id="11-SQL-优化"><a href="#11-SQL-优化" class="headerlink" title="11.SQL 优化"></a><strong>11.SQL 优化</strong></h3><p>sql优化能大幅提高接口的查询性能，结合索引、分页等关注点制定优化方案。</p><h3 id="12-锁粒度避免过粗"><a href="#12-锁粒度避免过粗" class="headerlink" title="12. 锁粒度避免过粗"></a><strong>12. 锁粒度避免过粗</strong></h3><p>锁一般是为了在高并发场景下保护共享资源采用的一种手段，但是如果锁的粒度太粗，会很影响接口性能。</p><p>关于锁粒度：就是要锁的范围有多大，不管是 synchronized 还是 redis 分布式锁，只需要在临界资源处加锁即可，不涉及共享资源的，不必要加锁，就好比你要上卫生间，只需要把卫生间的门锁上就可以，不需要把客厅的门也锁上。</p><p>错误的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intwrong</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>    share();<br>        notShare();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intright</span><span class="hljs-params">()</span>&#123;    <br>notShare();<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>share(); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;接口调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储过程</title>
    <link href="/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程介绍"><a href="#存储过程介绍" class="headerlink" title="存储过程介绍"></a>存储过程介绍</h1><p>[TOC]</p><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h3 id="1-带参存储过程语法"><a href="#1-带参存储过程语法" class="headerlink" title="1.带参存储过程语法"></a>1.带参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字(<br>    <span class="hljs-comment">--输入参数 IN NUMBER,</span><br>    <span class="hljs-comment">--输出参数 OUT NUMBER, --可以有多个输入参数和输出参数</span><br>                <span class="hljs-comment">--输入输出 INOUT NUMBER</span><br>) <span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>     <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>      <span class="hljs-keyword">rollback</span>;<br>      dbms_output.put_line(sqlcode);<br>      dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><blockquote><ul><li>​        注意：</li><li>​            其中参数IN表示输入参数，是参数的默认模式。</li><li>​            OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。</li><li>​            OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程</li><li>​            IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。</li></ul></blockquote><h3 id="2-无参存储过程语法"><a href="#2-无参存储过程语法" class="headerlink" title="2.无参存储过程语法"></a>2.无参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字<br><span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>    <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>   <span class="hljs-keyword">rollback</span>;<br>   dbms_output.put_line(sqlcode);<br>   dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1-带参存储过程语法-1"><a href="#1-带参存储过程语法-1" class="headerlink" title="1.带参存储过程语法"></a>1.带参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字([<span class="hljs-keyword">in</span>,<span class="hljs-keyword">out</span>,<span class="hljs-keyword">inout</span>] 参数名 数据类型)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><h3 id="2-无参存储过程语法-1"><a href="#2-无参存储过程语法-1" class="headerlink" title="2.无参存储过程语法"></a>2.无参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><h3 id="流程控制-判断语句"><a href="#流程控制-判断语句" class="headerlink" title="流程控制-判断语句"></a>流程控制-判断语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">if 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br>elseif 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">case</span> 参数<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure><h3 id="流程控制-循环语句"><a href="#流程控制-循环语句" class="headerlink" title="流程控制-循环语句"></a>流程控制-循环语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>while 循环条件<br>do 循环体;<br><span class="hljs-keyword">end</span> while 标签;<br></code></pre></td></tr></table></figure><h4 id="repeat语句"><a href="#repeat语句" class="headerlink" title="repeat语句"></a>repeat语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>repeat 循环体;<br>until 条件表达式<br><span class="hljs-keyword">end</span> repeat 标签;<br></code></pre></td></tr></table></figure><h4 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签:<br>loop 循环体;<br>if 条件表达式 <span class="hljs-keyword">then</span><br>leave 标签;<br><span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span> loop;<br>loop<br>    执行语句;<br>    exit <span class="hljs-keyword">when</span> <span class="hljs-operator">&lt;</span>条件语句<span class="hljs-operator">&gt;</span> <span class="hljs-comment">--条件满足，退出循环语句;</span><br><span class="hljs-keyword">end</span> loop;<br></code></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">for</span> 循环计数器 <span class="hljs-keyword">in</span> [REVERSE] 下限 .. 上限 loop<br>要执行的语句;<br><span class="hljs-keyword">end</span> loop [循环标签];<br>每循环一次，循环变量自动加<span class="hljs-number">1</span>；使用关键字REVERSE，循环变量自动减<span class="hljs-number">1</span>。<br><span class="hljs-keyword">in</span> REVERSE 后面的数字必须是从小到大的顺序，而且必须是整数，不能是变量或表达式,也可以使用EXIT退出循环，见loop语句。<br></code></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h4 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h4><blockquote><ul><li>MySQL:<ul><li>declare 游标名称 cursor for 传给游标的结果集;</li><li>open 游标名称;</li><li>fetch 游标名称 into 自定义变量;</li><li>close 游标名称;</li></ul></li><li>Oracle:<ul><li>cursor 游标名称 is 传给游标的结果集;</li><li>open 游标名称;</li><li>fetch 游标名称 into 自定义变量;</li><li>close 游标名称;</li></ul></li></ul></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th align="left">类别描述</th><th align="left">MySQL</th><th align="left">Oracle</th><th align="left">注解</th></tr></thead><tbody><tr><td align="left">创建存储过程/函数语句</td><td align="left">DROP PROCEDURE IF EXISTS <code>存储过程名称</code>;<br/>create procedure 存储过程名称()<br/>DROP FUNCTION IF EXISTS <code>函数名称</code>;<br/>CREATE  FUNCTION <code>函数名称</code>()<br/> RETURNS varchar(1000)</td><td align="left">create or replace procedure 存储过程名称（） is<br/>create or replace function 函数名称()<br/>RETURN VARCHAR2</td><td align="left">1.在创建存储过程时如果存在同名的存储过程,会删除老的存储过程. <br/>  Oracle使用create or replace.<br/>  MySQL使用先删除老的存储过程,然后再创建新的存储过程.<br/>2. Oracle存储过程可以定义在package中,也可以定义在Procedures中. 如果定义在包中,一个包中可以包含多个存储过程和方法.如果定义在Procedures中,存储过程中不可以定义多个存储过程. <br/>   MySQL存储过程中不可以定义多个存储过程.</td></tr><tr><td align="left">传参</td><td align="left">存储过程名称(参数类型  参数  参数属性)</td><td align="left">存储过程名称(参数  参数类型  参数属性)</td><td align="left">1. oracle存储过程参数可以定义为表的字段类型.<br/>   Mysql存储过程不支持这种定义方法.需要定义变量的实际类型和长度.<br/>2. oracle 参数类型in/out/inout写在参数名后面. <br/>   Mysql  参数类型in/out/inout写在参数名前面.<br/>3. oracle 参数类型in/out/inout 都必须写.<br/>   Mysql  参数类型默认in,可省略，out或inout不可省略.</td></tr><tr><td align="left">包</td><td align="left">多个存储过程或函数</td><td align="left">create or replace package/package body package name</td><td align="left">oracle可以创建包,包中可以包含多个存储过程和方法. <br/>mysql没有包，需分别创建存储过程和方法. 每个存储过程或方法都需要放在一个文件中.</td></tr><tr><td align="left">存储过程返回语句</td><td align="left">LEAVE  xx;</td><td align="left">return;</td><td align="left">oracle存储过程和方法都可以使用return退出当前过程和方法. <br/>Mysql存储过程中只能使用leave退出当前存储过程.不可以使用return. <br/>Mysql方法可以使用return退出当前方法.</td></tr><tr><td align="left">声明变量的位置</td><td align="left">begin…end内</td><td align="left">begin之前</td><td align="left"></td></tr><tr><td align="left">调用方式</td><td align="left">call 存储过程名称();</td><td align="left">存储过程名称();</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>&lt;数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储过程 Oracle MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/02/hello-world/"/>
    <url>/2023/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>欢迎来到我的个人博客</strong></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
