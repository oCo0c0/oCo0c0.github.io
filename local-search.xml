<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>接口优化</title>
    <link href="/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
    <url>/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="接口优化方案总结"><a href="#接口优化方案总结" class="headerlink" title="接口优化方案总结"></a><strong>接口优化方案总结</strong></h2><p>近期接口优化的一些总结：</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="1-批处理"><a href="#1-批处理" class="headerlink" title="1.批处理"></a><strong>1.批处理</strong></h3><p>批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//for循环单笔入库</span><br>list.stream().forEatch(l -&gt; &#123;<br>insert();<br>&#125;);<br><span class="hljs-comment">//批量入库batchInsert();</span><br></code></pre></td></tr></table></figure><h3 id="2-异步处理"><a href="#2-异步处理" class="headerlink" title="2. 异步处理"></a><strong>2. 异步处理</strong></h3><p>异步思想：针对耗时比较长且不是结果必须的逻辑，我们可以考虑放到异步执行，这样能降低接口耗时。</p><h3 id="3-空间换时间"><a href="#3-空间换时间" class="headerlink" title="3. 空间换时间"></a><strong>3. 空间换时间</strong></h3><p>合理使用缓存，针对一些频繁使用且不频繁变更的数据，可以提前缓存起来，需要时直接查缓存，避免频繁地查询数据库或者重复计算。需要注意空间换时间也是一把双刃剑，需要综合考虑使用场景，缓存带来的数据一致性问题也挺令人头疼。</p><h3 id="4-预处理"><a href="#4-预处理" class="headerlink" title="4. 预处理"></a><strong>4. 预处理</strong></h3><p>预取思想，提前把查询的数据计算好，封装好，放入缓存或者表中的某个字段，用的时候会大幅提高接口性能。</p><h3 id="5-池化思想"><a href="#5-池化思想" class="headerlink" title="5. 池化思想"></a><strong>5. 池化思想</strong></h3><p>我们都用过数据库连接池，线程池等，这就是池思想的体现，它们解决的问题就是避免重复创建对象或创建连接，可以重复利用，避免不必要的损耗，因为创建销毁也会占用时间。</p><p>池化思想包含但并不局限于以上两种，总的来说池化思想的本质是<strong>预分配与循环使用</strong>。</p><h3 id="6-串行改并行"><a href="#6-串行改并行" class="headerlink" title="6. 串行改并行"></a><strong>6. 串行改并行</strong></h3><p>串行就是，当前执行逻辑必须等上一个执行逻辑结束之后才执行，并行就是两个执行逻辑互不干扰，所以并行相对来说就比较节省时间，当然是建立在没有结果参数依赖的前提下。</p><h3 id="7-索引"><a href="#7-索引" class="headerlink" title="7. 索引"></a><strong>7. 索引</strong></h3><p>加索引能大大提高数据查询效率，这个在接口设计之出也会考虑到</p><p>索引失效常见情景：</p><p>① 隐式类型转换；</p><p>② select * ；</p><p>③ 对索引进行列运算(+、-、*、/)；</p><p>④ 不满足最左匹配原则；</p><p>⑤ 使用or关键字；</p><p>⑥ not in 和 not exists；</p><p>⑦ order by 和搜索列不匹配；</p><p>⑧ 使用&lt;、&gt;、!=;</p><p>⑨ like以通配符开头(‘%xxx’)</p><h3 id="8-避免大事务"><a href="#8-避免大事务" class="headerlink" title="8. 避免大事务"></a><strong>8. 避免大事务</strong></h3><p>所谓大事务问题，就是<strong>运行时间较长的事务，</strong>由于事务一致不提交，会导致数据库连接被占用，影响到别的请求访问数据库，影响别的接口性能。事务中嵌套 RPC 调用，即非 DB 操作，这些非 DB 操作如果耗时较大的话，可能会出现大事务问题。大数据引发的问题主要有：死锁、接口超时、主从延迟等。所以为避免大事务问题，我们可以通过以下方案规避：</p><p>① RPC调用不放到事务里面;</p><p>② 查询操作尽量放到事务之外;</p><p>③ 事务中避免处理太多数据。</p><h3 id="9-优化程序结构"><a href="#9-优化程序结构" class="headerlink" title="9. 优化程序结构"></a><strong>9. 优化程序结构</strong></h3><p>程序结构问题一般出现在多次需求迭代后，代码叠加形成。会造成一些重复查询、多次创建对象等耗时问题。在多人维护一个项目时比较多见。解决起来也比较简单，我们需要针对接口整体做重构，评估每个代码块的作用和用途，调整执行顺序。</p><h3 id="10-深分页问题"><a href="#10-深分页问题" class="headerlink" title="10. 深分页问题"></a><strong>10. 深分页问题</strong></h3><p>深分页问题比较常见，分页我们一般最先想到的就是 limit，为什么会慢，如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderTime <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>,<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>limit 100000,200 意味着会扫描 100200 行，然后返回 200 行，丢弃掉前 100000 行。所以执行速度很慢。一般可以采用标签记录法来优化，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <br><span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> limit <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>这样优化的好处是命中了主键索引，无论多少页，性能都还不错，但是局限性是需要一个连续自增的字段。</p><p>避免使用select *，其实select后字段名全写，也比 * 效率高很多。</p><h3 id="11-SQL-优化"><a href="#11-SQL-优化" class="headerlink" title="11.SQL 优化"></a><strong>11.SQL 优化</strong></h3><p>sql优化能大幅提高接口的查询性能，结合索引、分页等关注点制定优化方案。</p><h3 id="12-锁粒度避免过粗"><a href="#12-锁粒度避免过粗" class="headerlink" title="12. 锁粒度避免过粗"></a><strong>12. 锁粒度避免过粗</strong></h3><p>锁一般是为了在高并发场景下保护共享资源采用的一种手段，但是如果锁的粒度太粗，会很影响接口性能。</p><p>关于锁粒度：就是要锁的范围有多大，不管是 synchronized 还是 redis 分布式锁，只需要在临界资源处加锁即可，不涉及共享资源的，不必要加锁，就好比你要上卫生间，只需要把卫生间的门锁上就可以，不需要把客厅的门也锁上。</p><p>错误的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intwrong</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>    share();<br>        notShare();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intright</span><span class="hljs-params">()</span>&#123;    <br>notShare();<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>share(); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;接口优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储过程</title>
    <link href="/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>存储过程介绍<br>    Oracle:<br>        1.带参存储过程语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字(<br>    <span class="hljs-comment">--输入参数 IN NUMBER,</span><br>    <span class="hljs-comment">--输出参数 OUT NUMBER, --可以有多个输入参数和输出参数</span><br>                <span class="hljs-comment">--输入输出 INOUT NUMBER</span><br>) <span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>     <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>      <span class="hljs-keyword">rollback</span>;<br>      dbms_output.put_line(sqlcode);<br>      dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><p>​        注意：<br>​            其中参数IN表示输入参数，是参数的默认模式。<br>​            OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。<br>​            OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程<br>​            IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。<br>​    2.无参存储过程语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字<br><span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>    <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>   <span class="hljs-keyword">rollback</span>;<br>   dbms_output.put_line(sqlcode);<br>   dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><p>​    MySQL:</p><p>​        1.带参存储过程语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字([<span class="hljs-keyword">in</span>,<span class="hljs-keyword">out</span>,<span class="hljs-keyword">inout</span>] 参数名 数据类型)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><p>​        2.无参存储过程语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><p>​    流程控制-判断语句</p><p>​        1.if语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">if 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br>elseif 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><p>​        2.case语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">case</span> 参数<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure><p>​    流程控制-循环语句</p><p>​        1.while语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>while 循环条件<br>do 循环体;<br><span class="hljs-keyword">end</span> while 标签;<br></code></pre></td></tr></table></figure><p>​        2.repeat语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>repeat 循环体;<br>until 条件表达式<br><span class="hljs-keyword">end</span> repeat 标签;<br></code></pre></td></tr></table></figure><p>​        3.loop语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签:<br>loop 循环体;<br>if 条件表达式 <span class="hljs-keyword">then</span><br>leave 标签;<br><span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span> loop;<br>loop<br>    执行语句;<br>    exit <span class="hljs-keyword">when</span> <span class="hljs-operator">&lt;</span>条件语句<span class="hljs-operator">&gt;</span> <span class="hljs-comment">--条件满足，退出循环语句;</span><br><span class="hljs-keyword">end</span> loop;<br></code></pre></td></tr></table></figure><p>​        4.for语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">for</span> 循环计数器 <span class="hljs-keyword">in</span> [REVERSE] 下限 .. 上限 loop<br>要执行的语句;<br><span class="hljs-keyword">end</span> loop [循环标签];<br>每循环一次，循环变量自动加<span class="hljs-number">1</span>；使用关键字REVERSE，循环变量自动减<span class="hljs-number">1</span>。<br><span class="hljs-keyword">in</span> REVERSE 后面的数字必须是从小到大的顺序，而且必须是整数，不能是变量或表达式,也可以使用EXIT退出循环，见loop语句。<br></code></pre></td></tr></table></figure><p>​    游标</p><p>​        声明语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">MySQL:<br><span class="hljs-keyword">declare</span> 游标名称 <span class="hljs-keyword">cursor</span> <span class="hljs-keyword">for</span> 传给游标的结果集;<br><span class="hljs-keyword">open</span> 游标名称;<br><span class="hljs-keyword">fetch</span> 游标名称 <span class="hljs-keyword">into</span> 自定义变量;<br><span class="hljs-keyword">close</span> 游标名称;<br>Oracle:<br><span class="hljs-keyword">cursor</span> 游标名称 <span class="hljs-keyword">is</span> 传给游标的结果集;<br><span class="hljs-keyword">open</span> 游标名称;<br><span class="hljs-keyword">fetch</span> 游标名称 <span class="hljs-keyword">into</span> 自定义变量;<br><span class="hljs-keyword">close</span> 游标名称;<br></code></pre></td></tr></table></figure><p>​    区别</p><table><thead><tr><th align="left">类别描述</th><th align="left">MySQL</th><th align="left">Oracle</th><th align="left">注解</th></tr></thead><tbody><tr><td align="left">创建存储过程/函数语句</td><td align="left">DROP PROCEDURE IF EXISTS <code>存储过程名称</code>;<br/>create procedure 存储过程名称()<br/>DROP FUNCTION IF EXISTS <code>函数名称</code>;<br/>CREATE  FUNCTION <code>函数名称</code>()<br/> RETURNS varchar(1000)</td><td align="left">create or replace procedure 存储过程名称（） is<br/>create or replace function 函数名称()<br/>RETURN VARCHAR2</td><td align="left">1.在创建存储过程时如果存在同名的存储过程,会删除老的存储过程. <br/>  Oracle使用create or replace.<br/>  MySQL使用先删除老的存储过程,然后再创建新的存储过程.<br/>2. Oracle存储过程可以定义在package中,也可以定义在Procedures中. 如果定义在包中,一个包中可以包含多个存储过程和方法.如果定义在Procedures中,存储过程中不可以定义多个存储过程. <br/>   MySQL存储过程中不可以定义多个存储过程.</td></tr><tr><td align="left">传参</td><td align="left">存储过程名称(参数类型  参数  参数属性)</td><td align="left">存储过程名称(参数  参数类型  参数属性)</td><td align="left">1. oracle存储过程参数可以定义为表的字段类型.<br/>   Mysql存储过程不支持这种定义方法.需要定义变量的实际类型和长度.<br/>2. oracle 参数类型in/out/inout写在参数名后面. <br/>   Mysql  参数类型in/out/inout写在参数名前面.<br/>3. oracle 参数类型in/out/inout 都必须写.<br/>   Mysql  参数类型默认in,可省略，out或inout不可省略.</td></tr><tr><td align="left">包</td><td align="left">多个存储过程或函数</td><td align="left">create or replace package/package body package name</td><td align="left">oracle可以创建包,包中可以包含多个存储过程和方法. <br/>mysql没有包，需分别创建存储过程和方法. 每个存储过程或方法都需要放在一个文件中.</td></tr><tr><td align="left">存储过程返回语句</td><td align="left">LEAVE  xx;</td><td align="left">return;</td><td align="left">oracle存储过程和方法都可以使用return退出当前过程和方法. <br/>Mysql存储过程中只能使用leave退出当前存储过程.不可以使用return. <br/>Mysql方法可以使用return退出当前方法.</td></tr><tr><td align="left">声明变量的位置</td><td align="left">begin…end内</td><td align="left">begin之前</td><td align="left"></td></tr><tr><td align="left">调用方式</td><td align="left">call 存储过程名称();</td><td align="left">存储过程名称();</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>&lt;数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储过程 Oracle MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/02/hello-world/"/>
    <url>/2023/04/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的个人博客</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
