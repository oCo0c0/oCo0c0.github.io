<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Kubernetes命令</title>
    <link href="/2024/03/10/Kubernetes%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/03/10/Kubernetes%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="集群信息："><a href="#集群信息：" class="headerlink" title="集群信息："></a><strong>集群信息：</strong></h3><ol><li>显示 Kubernetes 版本：<code>kubectl version</code></li><li>显示集群信息：<code>kubectl cluster-info</code></li><li>列出集群中的所有节点：<code>kubectl get nodes</code></li><li>查看一个具体的节点详情：<code>kubectl describe node &lt;node-name&gt;</code></li><li>列出所有命名空间：<code>kubectl get namespaces</code></li><li>列出所有命名空间中的所有 pod：<code>kubectl get pods --all-namespaces</code></li></ol><h3 id="Pod-诊断："><a href="#Pod-诊断：" class="headerlink" title="Pod 诊断："></a><strong>Pod 诊断：</strong></h3><ol><li>列出特定命名空间中的 pod：<code>kubectl get pods -n &lt;namespace&gt;</code></li><li>查看一个 Pod 详情：<code>kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>查看 Pod 日志：<code>kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>尾部 Pod 日志：<code>kubectl logs -f &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>在 pod 中执行命令：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- &lt;command&gt;</code></li></ol><h3 id="Pod-健康检查："><a href="#Pod-健康检查：" class="headerlink" title="Pod 健康检查："></a><strong>Pod 健康检查：</strong></h3><ol><li>检查 Pod 准备情况：<code>kubectl get pods &lt;pod-name&gt; -n &lt;namespace&gt; -o jsonpath=&#39;&#123;.status.conditions[?(@.type==&quot;Ready&quot;)].status&#125;&#39;</code></li><li>检查 Pod 事件：<code>kubectl get events -n &lt;namespace&gt; --field-selector involvedObject.name=&lt;pod-name&gt;</code></li></ol><h3 id="Service诊断："><a href="#Service诊断：" class="headerlink" title="Service诊断："></a><strong>Service诊断：</strong></h3><ol><li>列出命名空间中的所有服务：<code>kubectl get svc -n &lt;namespace&gt;</code></li><li>查看一个服务详情：<code>kubectl describe svc &lt;service-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="Deployment诊断："><a href="#Deployment诊断：" class="headerlink" title="Deployment诊断："></a><strong>Deployment诊断：</strong></h3><ol><li>列出命名空间中的所有Deployment：<code>kubectl get deployments -n &lt;namespace&gt;</code></li><li>查看一个Deployment详情：<code>kubectl describe deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</code></li><li>查看滚动发布状态：<code>kubectl rollout status deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</code></li><li>查看滚动发布历史记录：<code>kubectl rollout history deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="StatefulSet诊断："><a href="#StatefulSet诊断：" class="headerlink" title="StatefulSet诊断："></a><strong>StatefulSet诊断：</strong></h3><ol><li>列出命名空间中的所有 StatefulSet：<code>kubectl get statefulsets -n &lt;namespace&gt;</code></li><li>查看一个 StatefulSet详情：<code>kubectl describe statefulset &lt;statefulset-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="ConfigMap-和Secret诊断："><a href="#ConfigMap-和Secret诊断：" class="headerlink" title="ConfigMap 和Secret诊断："></a><strong>ConfigMap 和Secret诊断：</strong></h3><ol><li>列出命名空间中的 ConfigMap：<code>kubectl get configmaps -n &lt;namespace&gt;</code></li><li>查看一个ConfigMap详情：<code>kubectl describe configmap &lt;configmap-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的 Secret：<code>kubectl get secrets -n &lt;namespace&gt;</code></li><li>查看一个Secret详情：<code>kubectl describe secret &lt;secret-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="命名空间诊断："><a href="#命名空间诊断：" class="headerlink" title="命名空间诊断："></a><strong>命名空间诊断：</strong></h3><ol><li>查看一个命名空间详情：<code>kubectl describe namespace &lt;namespace-name&gt;</code></li></ol><h3 id="资源使用情况："><a href="#资源使用情况：" class="headerlink" title="资源使用情况："></a><strong>资源使用情况：</strong></h3><ol><li>检查 pod 的资源使用情况：<code>kubectl top pod &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>检查节点资源使用情况：<code>kubectl top nodes</code></li></ol><h3 id="网络诊断："><a href="#网络诊断：" class="headerlink" title="网络诊断："></a><strong>网络诊断：</strong></h3><ol><li>显示命名空间中 Pod 的 IP 地址：<code>kubectl get pods -n &lt;namespace&gt; -o custom-columns=POD:metadata.name,IP:status.podIP --no-headers</code></li><li>列出命名空间中的所有网络策略：<code>kubectl get networkpolicies -n &lt;namespace&gt;</code></li><li>查看一个网络策略详情：<code>kubectl describe networkpolicy &lt;network-policy-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="持久卷-PV-和持久卷声明-PVC-诊断："><a href="#持久卷-PV-和持久卷声明-PVC-诊断：" class="headerlink" title="持久卷 (PV) 和持久卷声明 (PVC) 诊断："></a><strong>持久卷 (PV) 和持久卷声明 (PVC) 诊断：</strong></h3><ol><li>列出PV：<code>kubectl get pv</code></li><li>查看一个PV详情：<code>kubectl describe pv &lt;pv-name&gt;</code></li><li>列出命名空间中的 PVC：<code>kubectl get pvc -n &lt;namespace&gt;</code></li><li>查看PVC详情：<code>kubectl describe pvc &lt;pvc-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="节点诊断："><a href="#节点诊断：" class="headerlink" title="节点诊断："></a><strong>节点诊断：</strong></h3><ol><li>获取特定节点上运行的 Pod 列表：<code>kubectl get pods --field-selector spec.nodeName=&lt;node-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源配额和限制："><a href="#资源配额和限制：" class="headerlink" title="资源配额和限制："></a><strong>资源配额和限制：</strong></h3><ol><li>列出命名空间中的资源配额：<code>kubectl get resourcequotas -n &lt;namespace&gt;</code></li><li>查看一个资源配额详情：<code>kubectl describe resourcequota &lt;resource-quota-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="自定义资源定义-CRD-诊断："><a href="#自定义资源定义-CRD-诊断：" class="headerlink" title="自定义资源定义 (CRD) 诊断："></a><strong>自定义资源定义 (CRD) 诊断：</strong></h3><ol><li>列出命名空间中的自定义资源：<code>kubectl get &lt;custom-resource-name&gt; -n &lt;namespace&gt;</code></li><li>查看自定义资源详情：<code>kubectl describe &lt;custom-resource-name&gt; &lt;custom-resource-instance-name&gt; -n &lt;namespace&gt;</code></li></ol><p>使用这些命令时，请记住将<code>&lt;namespace&gt;</code>, <code>&lt;pod-name&gt;</code>, <code>&lt;service-name&gt;</code>, <code>&lt;deployment-name&gt;</code>, <code>&lt;statefulset-name&gt;</code>, <code>&lt;configmap-name&gt;</code>, <code>&lt;secret-name&gt;</code>, <code>&lt;namespace-name&gt;</code>, <code>&lt;pv-name&gt;</code>, <code>&lt;pvc-name&gt;</code>, <code>&lt;node-name&gt;</code>, <code>&lt;network-policy-name&gt;</code>, <code>&lt;resource-quota-name&gt;</code>, <code>&lt;custom-resource-name&gt;</code>, 和替换为你的特定值。</p><p><code>&lt;custom-resource-instance-name&gt;</code>这些命令应该可以帮助你诊断 Kubernetes 集群以及在其中运行的应用程序。</p><h3 id="资源伸缩和自动伸缩"><a href="#资源伸缩和自动伸缩" class="headerlink" title="资源伸缩和自动伸缩"></a><strong>资源伸缩和自动伸缩</strong></h3><ol><li>Deployment伸缩：<code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replica-count&gt; -n &lt;namespace&gt;</code></li><li>设置Deployment的自动伸缩：<code>kubectl autoscale deployment &lt;deployment-name&gt; --min=&lt;min-pods&gt; --max=&lt;max-pods&gt; --cpu-percent=&lt;cpu-percent&gt; -n &lt;namespace&gt;</code></li><li>检查水平伸缩器状态：<code>kubectl get hpa -n &lt;namespace&gt;</code></li></ol><h3 id="作业和-CronJob-诊断："><a href="#作业和-CronJob-诊断：" class="headerlink" title="作业和 CronJob 诊断："></a><strong>作业和 CronJob 诊断：</strong></h3><ol><li>列出命名空间中的所有作业：<code>kubectl get jobs -n &lt;namespace&gt;</code></li><li>查看一份工作详情：<code>kubectl describe job &lt;job-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的所有 cron 作业：<code>kubectl get cronjobs -n &lt;namespace&gt;</code></li><li>查看一个 cron 作业详情：<code>kubectl describe cronjob &lt;cronjob-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="容量诊断："><a href="#容量诊断：" class="headerlink" title="容量诊断："></a><strong>容量诊断：</strong></h3><ol><li>列出按容量排序的持久卷 (PV)：<code>kubectl get pv --sort-by=.spec.capacity.storage</code></li><li>查看PV回收策略：<code>kubectl get pv &lt;pv-name&gt; -o=jsonpath=&#39;&#123;.spec.persistentVolumeReclaimPolicy&#125;&#39;</code></li><li>列出所有存储类别：<code>kubectl get storageclasses</code></li></ol><h3 id="Ingress和服务网格诊断："><a href="#Ingress和服务网格诊断：" class="headerlink" title="Ingress和服务网格诊断："></a><strong>Ingress和服务网格诊断：</strong></h3><ol><li>列出命名空间中的所有Ingress：<code>kubectl get ingress -n &lt;namespace&gt;</code></li><li>查看一个Ingress详情：<code>kubectl describe ingress &lt;ingress-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的所有 VirtualServices (Istio)：<code>kubectl get virtualservices -n &lt;namespace&gt;</code></li><li>查看一个 VirtualService (Istio)详情：<code>kubectl describe virtualservice &lt;virtualservice-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="Pod-网络故障排除："><a href="#Pod-网络故障排除：" class="headerlink" title="Pod 网络故障排除："></a><strong>Pod 网络故障排除：</strong></h3><ol><li>运行网络诊断 Pod（例如 busybox）进行调试：<code>kubectl run -it --rm --restart=Never --image=busybox net-debug-pod -- /bin/sh</code></li><li>测试从 Pod 到特定端点的连接：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- curl &lt;endpoint-url&gt;</code></li><li>跟踪从一个 Pod 到另一个 Pod 的网络路径：<code>kubectl exec -it &lt;source-pod-name&gt; -n &lt;namespace&gt; -- traceroute &lt;destination-pod-ip&gt;</code></li><li>检查 Pod 的 DNS 解析：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- nslookup &lt;domain-name&gt;</code></li></ol><h3 id="配置和资源验证："><a href="#配置和资源验证：" class="headerlink" title="配置和资源验证："></a><strong>配</strong>置和资源验证：</h3><ol><li>验证 Kubernetes YAML 文件而不应用它：<code>kubectl apply --dry-run=client -f &lt;yaml-file&gt;</code></li><li>验证 pod 的安全上下文和功能：<code>kubectl auth can-i list pods --as=system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccount-name&gt;</code></li></ol><h3 id="RBAC-和安全性："><a href="#RBAC-和安全性：" class="headerlink" title="RBAC 和安全性："></a><strong>RBAC 和安全性：</strong></h3><ol><li>列出命名空间中的角色和角色绑定：<code>kubectl get roles,rolebindings -n &lt;namespace&gt;</code></li><li>查看角色或角色绑定详情：<code>kubectl describe role &lt;role-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="服务帐户诊断："><a href="#服务帐户诊断：" class="headerlink" title="服务帐户诊断："></a><strong>服务帐户诊断：</strong></h3><ol><li>列出命名空间中的服务帐户：<code>kubectl get serviceaccounts -n &lt;namespace&gt;</code></li><li>查看一个服务帐户详情：<code>kubectl describe serviceaccount &lt;serviceaccount-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="清空节点和解除封锁："><a href="#清空节点和解除封锁：" class="headerlink" title="清空节点和解除封锁："></a><strong>清空节点和解除封锁：</strong></h3><ol><li>清空节点以进行维护：<code>kubectl drain &lt;node-name&gt; --ignore-daemonsets</code></li><li>解除对节点的封锁：<code>kubectl uncordon &lt;node-name&gt;</code></li></ol><h3 id="资源清理："><a href="#资源清理：" class="headerlink" title="资源清理："></a><strong>资源清理：</strong></h3><ol><li>强制删除 pod（不推荐）：<code>kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt; --grace-period=0 --force</code></li></ol><h3 id="Pod-亲和性和反亲和性："><a href="#Pod-亲和性和反亲和性：" class="headerlink" title="Pod 亲和性和反亲和性："></a><strong>Pod 亲和性和反亲和性：</strong></h3><ol><li>列出 pod 的 pod 亲和性规则：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.affinity&#125;&#39;</code></li><li>列出 pod 的 pod 反亲和性规则：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.affinity.podAntiAffinity&#125;&#39;</code></li></ol><h3 id="Pod-安全策略-PSP-："><a href="#Pod-安全策略-PSP-：" class="headerlink" title="Pod 安全策略 (PSP)："></a><strong>Pod 安全策略 (PSP)：</strong></h3><ol><li>列出所有 Pod 安全策略（如果启用）：<code>kubectl get psp</code></li></ol><h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a><strong>事件：</strong></h3><ol><li>查看最近的集群事件：<code>kubectl get events --sort-by=.metadata.creationTimestamp</code></li><li>按特定命名空间过滤事件：<code>kubectl get events -n &lt;namespace&gt;</code></li></ol><h3 id="节点故障排除："><a href="#节点故障排除：" class="headerlink" title="节点故障排除："></a><strong>节点故障排除：</strong></h3><ol><li>检查节点情况：<code>kubectl describe node &lt;node-name&gt; | grep Conditions -A5</code></li><li>列出节点容量和可分配资源：<code>kubectl describe node &lt;node-name&gt; | grep -E &quot;Capacity|Allocatable&quot;</code></li></ol><h3 id="临时容器（Kubernetes-1-18-）："><a href="#临时容器（Kubernetes-1-18-）：" class="headerlink" title="临时容器（Kubernetes 1.18+）："></a><strong>临时容器（Kubernetes 1.18+）：</strong></h3><ol><li>运行临时调试容器：<code>kubectl debug -it &lt;pod-name&gt; -n &lt;namespace&gt; --image=&lt;debug-image&gt; -- /bin/sh</code></li></ol><h3 id="资源指标（需要指标服务器）："><a href="#资源指标（需要指标服务器）：" class="headerlink" title="资源指标（需要指标服务器）："></a><strong>资源指标（需要指标服务器）：</strong></h3><ol><li>获取 Pod 的 CPU 和内存使用情况：<code>kubectl top pod -n &lt;namespace&gt;</code></li></ol><h3 id="kuelet诊断："><a href="#kuelet诊断：" class="headerlink" title="kuelet诊断："></a><strong>kuelet诊断：</strong></h3><ol><li>查看节点上的kubelet日志：<code>kubectl logs -n kube-system kubelet-&lt;node-name&gt;</code></li></ol><h3 id="使用Telepresence-进行高级调试："><a href="#使用Telepresence-进行高级调试：" class="headerlink" title="使用Telepresence 进行高级调试："></a><strong>使用Telepresence 进行高级调试：</strong></h3><ol><li>使用 Telepresence 调试 pod：<code>telepresence --namespace &lt;namespace&gt; --swap-deployment &lt;pod-name&gt;</code></li></ol><h3 id="Kubeconfig-和上下文："><a href="#Kubeconfig-和上下文：" class="headerlink" title="Kubeconfig 和上下文："></a><strong>Kubeconfig 和上下文：</strong></h3><ol><li>列出可用的上下文：<code>kubectl config get-contexts</code></li><li>切换到不同的上下文：<code>kubectl config use-context &lt;context-name&gt;</code></li></ol><h3 id="Pod-安全标准（PodSecurity-准入控制器）："><a href="#Pod-安全标准（PodSecurity-准入控制器）：" class="headerlink" title="Pod 安全标准（PodSecurity 准入控制器）："></a><strong>Pod 安全标准（PodSecurity 准入控制器）：</strong></h3><ol><li>列出 PodSecurityPolicy (PSP) 违规行为：<code>kubectl get psp -A | grep -vE &#39;NAME|REVIEWED&#39;</code></li></ol><h3 id="Pod-中断预算-PDB-诊断："><a href="#Pod-中断预算-PDB-诊断：" class="headerlink" title="Pod 中断预算 (PDB) 诊断："></a><strong>Pod 中断预算 (PDB) 诊断：</strong></h3><ol><li>列出命名空间中的所有 PDB：<code>kubectl get pdb -n &lt;namespace&gt;</code></li><li>查看一个PDB详情：<code>kubectl describe pdb &lt;pdb-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源锁诊断（如果使用资源锁）："><a href="#资源锁诊断（如果使用资源锁）：" class="headerlink" title="资源锁诊断（如果使用资源锁）："></a><strong>资源锁诊断（如果使用资源锁）：</strong></h3><ol><li>列出命名空间中的资源锁：<code>kubectl get resourcelocks -n &lt;namespace&gt;</code></li></ol><h3 id="服务端点和-DNS："><a href="#服务端点和-DNS：" class="headerlink" title="服务端点和 DNS："></a><strong>服务端点和 DNS：</strong></h3><ol><li>列出服务的服务端点：<code>kubectl get endpoints &lt;service-name&gt; -n &lt;namespace&gt;</code></li><li>检查 Pod 中的 DNS 配置：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- cat /etc/resolv.conf</code></li></ol><h3 id="自定义指标（Prometheus、Grafana）："><a href="#自定义指标（Prometheus、Grafana）：" class="headerlink" title="自定义指标（Prometheus、Grafana）："></a><strong>自定义指标（Prometheus、Grafana）：</strong></h3><ol><li>查询Prometheus指标：用于<code>kubectl port-forward</code>访问Prometheus和Grafana服务来查询自定义指标。</li></ol><h3 id="Pod-优先级和抢占："><a href="#Pod-优先级和抢占：" class="headerlink" title="Pod 优先级和抢占："></a><strong>Pod 优先级和抢占：</strong></h3><ol><li>列出优先级：<code>kubectl get priorityclasses</code></li></ol><h3 id="Pod-开销（Kubernetes-1-18-）："><a href="#Pod-开销（Kubernetes-1-18-）：" class="headerlink" title="Pod 开销（Kubernetes 1.18+）："></a><strong>Pod 开销（Kubernetes 1.18+）：</strong></h3><ol><li>列出 pod 中的开销：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.overhead&#125;&#39;</code></li></ol><h3 id="存储卷快照诊断（如果使用存储卷快照）："><a href="#存储卷快照诊断（如果使用存储卷快照）：" class="headerlink" title="存储卷快照诊断（如果使用存储卷快照）："></a><strong>存储卷快照诊断（如果使用存储卷快照）：</strong></h3><ol><li>列出存储卷快照：<code>kubectl get volumesnapshot -n &lt;namespace&gt;</code></li><li>查看存储卷快照详情：<code>kubectl describe volumesnapshot &lt;snapshot-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源反序列化诊断："><a href="#资源反序列化诊断：" class="headerlink" title="资源反序列化诊断："></a><strong>资源反序列化诊断：</strong></h3><ol><li>反序列化并打印 Kubernetes 资源：<code>kubectl get &lt;resource-type&gt; &lt;resource-name&gt; -n &lt;namespace&gt; -o=json</code></li></ol><h3 id="节点污点："><a href="#节点污点：" class="headerlink" title="节点污点："></a><strong>节点污点：</strong></h3><ol><li>列出节点污点：<code>kubectl describe node &lt;node-name&gt; | grep Taints</code></li></ol><h3 id="更改和验证-Webhook-配置："><a href="#更改和验证-Webhook-配置：" class="headerlink" title="更改和验证 Webhook 配置："></a><strong>更改和验证 Webhook 配置：</strong></h3><ol><li>列出变异 webhook 配置：<code>kubectl get mutatingwebhookconfigurations</code></li><li>列出验证 Webhook 配置：<code>kubectl get validatingwebhookconfigurations</code></li></ol><h3 id="Pod-网络策略："><a href="#Pod-网络策略：" class="headerlink" title="Pod 网络策略："></a><strong>Pod 网络策略：</strong></h3><ol><li>列出命名空间中的 pod 网络策略：<code>kubectl get networkpolicies -n &lt;namespace&gt;</code></li></ol><h3 id="节点条件（Kubernetes-1-17-）："><a href="#节点条件（Kubernetes-1-17-）：" class="headerlink" title="节点条件（Kubernetes 1.17+）："></a><strong>节点条件（Kubernetes 1.17+）：</strong></h3><ol><li>自定义查询输出：<code>kubectl get nodes -o custom-columns=NODE:.metadata.name,READY:.status.conditions[?(@.type==&quot;Ready&quot;)].status -l &#39;node-role.kubernetes.io/worker=&#39;</code></li></ol><h3 id="审核日志："><a href="#审核日志：" class="headerlink" title="审核日志："></a><strong>审核日志：</strong></h3><ol><li>检索审核日志（如果启用）：检查 Kubernetes 审核日志配置以了解审核日志的位置。</li></ol><h3 id="节点操作系统详细信息："><a href="#节点操作系统详细信息：" class="headerlink" title="节点操作系统详细信息："></a><strong>节点操作系统详细信息：</strong></h3><ol><li>获取节点的操作系统信息：<code>kubectl get node &lt;node-name&gt; -o jsonpath=&#39;&#123;.status.nodeInfo.osImage&#125;&#39;</code></li></ol><p>这些命令应该涵盖 Kubernetes 中的各种诊断场景。确保将<code>&lt;namespace&gt;</code>、<code>&lt;pod-name&gt;</code>、<code>&lt;deployment-name&gt;</code>等占位符替换为你的集群和用例的实际值。</p>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture接口</title>
    <link href="/2024/02/22/CompletableFuture/"/>
    <url>/2024/02/22/CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><p>学习CompletableFuture</p><ul><li>CompletableFuture的使用</li><li>CompletableFure异步和同步的性能测试</li><li>已经有了Future为什么仍需要在JDK1.8中引入CompletableFuture</li><li>CompletableFuture的应用场景</li><li>对CompletableFuture的使用优化</li></ul><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a><strong>场景说明</strong></h2><p>查询所有商店某个商品的价格并返回，并且查询商店某个商品的价格的API为同步 一个Shop类，提供一个名为getPrice的同步方法</p><ul><li>店铺类：Shop.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-comment">/**     * 根据产品名查找价格     * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">(String product)</span> &#123;<br>            <span class="hljs-keyword">return</span> calculatePrice(product);<br>        &#125;<br>        <span class="hljs-comment">/**     * 计算价格     *     * </span><br><span class="hljs-comment">        <span class="hljs-doctag">@param</span> product     * </span><br><span class="hljs-comment">        <span class="hljs-doctag">@return</span>     * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(String product)</span> &#123;<br>            delay();<br>            <span class="hljs-comment">//random.nextDouble()随机返回折扣     </span><br>            <span class="hljs-keyword">return</span> random.nextDouble() * product.charAt(<span class="hljs-number">0</span>) + product.charAt(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">/**     * 通过睡眠模拟其他耗时操作     * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询商品的价格为同步方法，并通过sleep方法模拟其他操作。这个场景模拟了当需要调用第三方API，但第三方提供的是同步API，在无法修改第三方API时如何设计代码调用提高应用的性能和吞吐量，这时候可以使用CompletableFuture类</p><h2 id="CompletableFuture使用"><a href="#CompletableFuture使用" class="headerlink" title="CompletableFuture使用"></a><strong>CompletableFuture使用</strong></h2><p>Completable是Future接口的实现类，在JDK1.8中引入</p><ul><li><p><strong>CompletableFuture的创建：</strong></p><p>说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Double&gt; futurePrice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>使用CompletableFuture#completedFuture静态方法创建</p><p>参数的值为任务执行完的结果，一般该方法在实际应用中较少应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; completedFuture(U value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span> &lt; U &gt; ((value == <span class="hljs-literal">null</span>) ? NIL : value);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用CompletableFuture#supplyAsync静态方法创建 supplyAsync有两个重载方法</p><p>两个重载方法之间的区别 =&gt; 后者可以传入自定义Executor，前者是默认的，使用的ForkJoinPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; supplyAsync(Supplier &lt; U &gt; supplier) &#123;<br>    <span class="hljs-keyword">return</span> asyncSupplyStage(asyncPool, supplier);<br>&#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; supplyAsync(Supplier &lt; U &gt; supplier, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用CompletableFuture#runAsync静态方法创建 runAsync有两个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Void &gt; runAsync(Runnable runnable) &#123;<br>    <span class="hljs-keyword">return</span> asyncRunStage(asyncPool, runnable);<br>&#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Void &gt; runAsync(Runnable runnable, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>supplyAsync和runAsync方法之间的区别 =&gt; 前者有返回值，后者无返回值Supplier是函数式接口，因此该方法需要传入该接口的实现类，追踪源码会发现在run方法中会调用该接口的方法。因此使用该方法创建CompletableFuture对象只需重写Supplier中的get方法，在get方法中定义任务即可。又因为函数式接口可以使用Lambda表达式，和new创建CompletableFuture对象相比代码会<strong>简洁</strong></p></li><li><p><strong>结果的获取：</strong> 对于结果的获取CompltableFuture类提供了四种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br><span class="hljs-comment">//方式三</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getNow</span><span class="hljs-params">(T valueIfAbsent)</span>;<br><span class="hljs-comment">//方式四</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">join</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>说明：</p></li><li><p>get()和get(long timeout, TimeUnit unit) =&gt; 在Future中就已经提供了，后者提供超时处理，如果在指定时间内未获取结果将抛出超时异常</p></li><li><p>getNow =&gt; 立即获取结果不阻塞，结果计算已完成将返回结果或计算过程中的异常，如果未计算完成将返回设定的valueIfAbsent值</p></li><li><p>join =&gt; 方法里不会抛出异常</p><p>示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcquireResultTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//getNow方法测试   </span><br>        CompletableFuture &lt; String &gt; cp1 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>        &#125;);<br>        System.out.println(cp1.getNow(<span class="hljs-string">&quot;hello h2t&quot;</span>));<br>        <span class="hljs-comment">//join方法测试     </span><br>        CompletableFuture &lt; Integer &gt; cp2 = CompletableFuture.supplyAsync((() - &gt; <span class="hljs-number">1</span> / <span class="hljs-number">0</span>));<br>        System.out.println(cp2.join());<br>        <span class="hljs-comment">//get方法测试   </span><br>        CompletableFuture &lt; Integer &gt; cp3 = CompletableFuture.supplyAsync((() - &gt; <span class="hljs-number">1</span> / <span class="hljs-number">0</span>));<br>        System.out.println(cp3.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>第一个执行结果为hello h2t，因为要先睡上1分钟结果不能立即获取</li><li>join方法获取结果方法里不会抛异常，但是执行结果会抛异常，抛出的异常为CompletionException</li><li>get方法获取结果方法里将抛出异常，执行结果抛出的异常为ExecutionException</li><li><strong>异常处理：</strong> 使用静态方法创建的CompletableFuture对象无需显示处理异常，使用new创建的对象需要调用completeExceptionally方法设置捕获到的异常，举例说明：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompletableFuture</span> <span class="hljs-variable">completableFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() - &gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//doSomething，调用complete方法将其他方法的执行结果记录在completableFuture对象中  </span><br>        completableFuture.complete(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">//异常处理     </span><br>        completableFuture.completeExceptionally(e);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="同步方法Pick异步方法查询所有店铺某个商品价格"><a href="#同步方法Pick异步方法查询所有店铺某个商品价格" class="headerlink" title="同步方法Pick异步方法查询所有店铺某个商品价格"></a><strong>同步方法Pick异步方法查询所有店铺某个商品价格</strong></h2><p>店铺为一个列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; Shop &gt; shopList = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;BestPrice&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;LetsSaveBig&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;MyFavoriteShop&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;BuyItAll&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>同步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; String &gt; findPriceSync(String product) &#123;<br>    <span class="hljs-keyword">return</span> shopList.stream().map(shop - &gt; String.format(<span class="hljs-string">&quot;%s price is %.2f&quot;</span>, shop.getName(), shop.getPrice(product))) <span class="hljs-comment">//格式转换      </span><br>        .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>异步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; String &gt; findPriceAsync(String product) &#123;<br>    List &lt; CompletableFuture &lt; String &gt;&gt; completableFutureList = shopList.stream() <span class="hljs-comment">//转异步执行     </span><br>        .map(shop - &gt; CompletableFuture.supplyAsync(() - &gt; String.format(<span class="hljs-string">&quot;%s price is %.2f&quot;</span>, shop.getName(), shop.getPrice(product)))) <span class="hljs-comment">//格式转换       </span><br>        .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> completableFutureList.stream().map(CompletableFuture::join) <span class="hljs-comment">//获取结果不会抛出异常</span><br>        .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能测试结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Find Price Sync Done <span class="hljs-keyword">in</span> 4141Find Price Async Done <span class="hljs-keyword">in</span> 1033<br></code></pre></td></tr></table></figure><p><strong>异步</strong> 执行效率<strong>提高四倍</strong></p><h3 id="为什么仍需要CompletableFuture"><a href="#为什么仍需要CompletableFuture" class="headerlink" title="为什么仍需要CompletableFuture"></a>为什么仍需要CompletableFuture</h3><p>在JDK1.8以前，通过调用线程池的submit方法可以让任务以异步的方式运行，该方法会返回一个Future对象，通过调用get方法获取异步执行的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; String &gt; findPriceFutureAsync(String product) &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    List &lt; Future &lt; String &gt;&gt; futureList = shopList.stream().map(shop - &gt; es.submit(() - &gt; String.format(<span class="hljs-string">&quot;%s price is %.2f&quot;</span>, shop.getName(), shop.getPrice(product)))).collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> futureList.stream().map(f - &gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = f.get();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;).collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>既生瑜何生亮，为什么仍需要引入CompletableFuture？对于简单的业务场景使用Future完全没有，但是想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值等等，使用Future提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以<strong>声明式</strong> 的方式优雅的处理这些需求。而且在Future编程中想要拿到Future的值然后拿这个值去做后续的计算任务，只能通过轮询的方式去判断任务是否完成这样非常占CPU并且代码也不优雅，用伪代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (future.isDone()) &#123;<br>    result = future.get();<br>    doSomrthingWithResult(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>但CompletableFuture提供了API帮助我们实现这样的需求</p><h3 id="其他API介绍"><a href="#其他API介绍" class="headerlink" title="其他API介绍"></a>其他API介绍</h3><h3 id="whenComplete计算结果的处理："><a href="#whenComplete计算结果的处理：" class="headerlink" title="whenComplete计算结果的处理："></a>whenComplete计算结果的处理：</h3><p>对前面计算结果进行处理，无法返回新值 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; T &gt; whenComplete(BiConsumer &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable &gt; action)<br>    <span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; T &gt; whenCompleteAsync(BiConsumer &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable &gt; action)<br>    <span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; T &gt; whenCompleteAsync(BiConsumer &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable &gt; action, Executor executor)<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>BiFunction&lt;? super T,? super U,? extends V&gt; fn参数 =&gt; 定义对结果的处理</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>以async结尾的方法将会在一个新的线程中执行组合操作</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WhenCompleteTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CompletableFuture &lt; String &gt; cf1 = CompletableFuture.supplyAsync(() - &gt; <span class="hljs-string">&quot;hello&quot;</span>);<br>        CompletableFuture &lt; String &gt; cf2 = cf1.whenComplete((v, e) - &gt; System.out.println(String.format(<span class="hljs-string">&quot;value:%s, exception:%s&quot;</span>, v, e)));<br>        System.out.println(cf2.join());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="thenApply转换："><a href="#thenApply转换：" class="headerlink" title="thenApply转换："></a>thenApply转换：</h3><p>将前面计算结果的的CompletableFuture传递给thenApply，返回thenApply处理后的结果。可以认为通过thenApply方法实现<code>CompletableFuture&lt;T&gt;</code>至<code>CompletableFuture&lt;U&gt;</code>的转换。白话一点就是将CompletableFuture的计算结果作为thenApply方法的参数，返回thenApply方法处理后的结果 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenApply(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>    &#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenApplyAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniApplyStage(asyncPool, fn);<br>    &#125;<br><span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenApplyAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; fn, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>Function&lt;? super T,? extends U&gt; fn参数 =&gt; 对前一个CompletableFuture 计算结果的转化操作</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>以async结尾的方法将会在一个新的线程中执行组合操作 示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenApplyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Integer &gt; result = CompletableFuture.supplyAsync(ThenApplyTest::randomInteger).thenApply((i) - &gt; i * <span class="hljs-number">8</span>);<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">randomInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将前一个CompletableFuture计算出来的结果扩大八倍</p><h3 id="thenAccept结果处理："><a href="#thenAccept结果处理：" class="headerlink" title="thenAccept结果处理："></a>thenAccept结果处理：</h3><p>thenApply也可以归类为对结果的处理，thenAccept和thenApply的区别就是没有返回值 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; Void &gt; thenAccept(Consumer &lt;? <span class="hljs-built_in">super</span> T &gt; action) &#123;<br>        <span class="hljs-keyword">return</span> uniAcceptStage(<span class="hljs-literal">null</span>, action);<br>    &#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; Void &gt; thenAcceptAsync(Consumer &lt;? <span class="hljs-built_in">super</span> T &gt; action) &#123;<br>        <span class="hljs-keyword">return</span> uniAcceptStage(asyncPool, action);<br>    &#125;<br><span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; Void &gt; thenAcceptAsync(Consumer &lt;? <span class="hljs-built_in">super</span> T &gt; action, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>Consumer&lt;? super T&gt; action参数 =&gt; 对前一个CompletableFuture计算结果的操作</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>同理以async结尾的方法将会在一个新的线程中执行组合操作 示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenAcceptTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CompletableFuture.supplyAsync(ThenAcceptTest::getList).thenAccept(strList - &gt; strList.stream().forEach(m - &gt; System.out.println(m)));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List &lt; String &gt; getList() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将前一个CompletableFuture计算出来的结果打印出来</p><h3 id="thenCompose异步结果流水化："><a href="#thenCompose异步结果流水化：" class="headerlink" title="thenCompose异步结果流水化："></a>thenCompose异步结果流水化：</h3><p>thenCompose方法可以将两个异步操作进行流水操作 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenCompose(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletionStage</span> &lt; U &gt;&gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniComposeStage(<span class="hljs-literal">null</span>, fn);<br>    &#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenComposeAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletionStage</span> &lt; U &gt;&gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniComposeStage(asyncPool, fn);<br>    &#125;<br><span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenComposeAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletionStage</span> &lt; U &gt;&gt; fn, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn</code>参数 =&gt; 当前CompletableFuture计算结果的执行</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>同理以async结尾的方法将会在一个新的线程中执行组合操作 示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenComposeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Integer &gt; result = CompletableFuture.supplyAsync(ThenComposeTest::getInteger).thenCompose(i - &gt; CompletableFuture.supplyAsync(() - &gt; i * <span class="hljs-number">10</span>));<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expandValue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> num * <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="thenCombine组合结果："><a href="#thenCombine组合结果：" class="headerlink" title="thenCombine组合结果："></a>thenCombine组合结果：</h3><p>thenCombine方法将两个无关的CompletableFuture组合起来，第二个Completable并不依赖第一个Completable的结果 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> &lt; U, V &gt; CompletableFuture &lt; V &gt; thenCombine(CompletionStage &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; other, BiFunction &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> biApplyStage(<span class="hljs-literal">null</span>, other, fn);<br>    &#125;<br><span class="hljs-comment">//方法二 </span><br><span class="hljs-keyword">public</span> &lt; U, V &gt; CompletableFuture &lt; V &gt; thenCombineAsync(CompletionStage &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; other, BiFunction &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> biApplyStage(asyncPool, other, fn);<br>    &#125;<br><span class="hljs-comment">//方法三 </span><br><span class="hljs-keyword">public</span> &lt; U, V &gt; CompletableFuture &lt; V &gt; thenCombineAsync(CompletionStage &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; other, BiFunction &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span> &gt; fn, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>CompletionStage&lt;? extends U&gt; other参数 =&gt; 新的CompletableFuture的计算结果</li><li>BiFunction&lt;? super T,? super U,? extends V&gt; fn参数 =&gt; 定义了两个CompletableFuture对象<strong>完成计算后</strong> 如何合并结果，该参数是一个函数式接口，因此可以使用Lambda表达式</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>同理以async结尾的方法将会在一个新的线程中执行组合操作</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenCombineTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Integer &gt; result = CompletableFuture.supplyAsync(ThenCombineTest::randomInteger).thenCombine(CompletableFuture.supplyAsync(ThenCombineTest::randomInteger), (i, j) - &gt; i * j);<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">randomInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将两个线程计算出来的值做一个乘法在返回</p><h3 id="allOf-amp-anyOf组合多个CompletableFuture："><a href="#allOf-amp-anyOf组合多个CompletableFuture：" class="headerlink" title="allOf&amp;anyOf组合多个CompletableFuture："></a>allOf&amp;anyOf组合多个CompletableFuture：</h3><p>方法介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//allOf</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Void &gt; allOf(CompletableFuture &lt;? &gt; ...cfs) &#123;<br>        <span class="hljs-keyword">return</span> andTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//anyOf</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Object &gt; anyOf(CompletableFuture &lt;? &gt; ...cfs) &#123;<br>    <span class="hljs-keyword">return</span> orTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>allOf =&gt; 所有的CompletableFuture都执行完后执行计算。</li><li>anyOf =&gt; 任意一个CompletableFuture执行完后就会执行计算</li></ul><p>示例：</p><ul><li>allOf方法测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllOfTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Void &gt; future1 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>        CompletableFuture &lt; Void &gt; future2 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>        CompletableFuture &lt; Void &gt; result = CompletableFuture.allOf(future1, future2);<br>        System.out.println(result.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>allOf方法没有返回值，适合没有返回值并且需要前面所有任务执行完毕才能执行后续任务的应用场景</p><ul><li>anyOf方法测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyOfTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; String &gt; future1 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            randomSleep();<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        &#125;);<br>        CompletableFuture &lt; String &gt; future2 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            randomSleep();<br>            System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world&quot;</span>;<br>        &#125;);<br>        CompletableFuture &lt; Object &gt; result = CompletableFuture.anyOf(future1, future2);<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">randomSleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(random.nextInt(<span class="hljs-number">10</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个线程都会将结果打印出来，但是get方法只会返回最先完成任务的结果。该方法比较适合只要有一个返回值就可以继续执行其他任务的应用场景</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>很多方法都提供了异步实现【带async后缀】，但是需小心谨慎使用这些异步方法，因为异步意味着存在上下文切换，可能性能不一定比同步好。如果需要使用异步的方法，<strong>先做测试</strong> ，用测试数据说话！！！</p><h3 id="CompletableFuture的应用场景"><a href="#CompletableFuture的应用场景" class="headerlink" title="CompletableFuture的应用场景"></a>CompletableFuture的应用场景</h3><p>存在IO密集型的任务可以选择CompletableFuture，IO部分交由另外一个线程去执行。Logback、Log4j2异步日志记录的实现原理就是新起了一个线程去执行IO操作，这部分可以以CompletableFuture.runAsync(()-&gt;{ioOperation();})的方式去调用。如果是CPU密集型就不推荐使用了推荐使用并行流</p><h3 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h3><p>supplyAsync执行任务底层实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; supplyAsync(Supplier &lt; U &gt; supplier) &#123;<br>    <span class="hljs-keyword">return</span> asyncSupplyStage(asyncPool, supplier);<br>&#125;<br><span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; asyncSupplyStage(Executor e, Supplier &lt; U &gt; f) &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture &lt; U &gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span> &lt; U &gt; ();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span> &lt; U &gt; (d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>底层调用的是线程池去执行任务，而CompletableFuture中默认线程池为ForkJoinPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">asyncPool</span> <span class="hljs-operator">=</span> useCommonPool ? ForkJoinPool.commonPool() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>();<br></code></pre></td></tr></table></figure><p>ForkJoinPool线程池的大小取决于CPU的核数。CPU密集型任务线程池大小配置为CPU核心数就可以了，但是IO密集型，线程池的大小由<strong>CPU数量 * CPU利用率 * (1 + 线程等待时间/线程CPU时间)</strong> 确定。而CompletableFuture的应用场景就是IO密集型任务，因此默认的ForkJoinPool一般无法达到最佳性能，我们需自己根据业务创建线程池。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot限流方案</title>
    <link href="/2024/02/20/SpringBoot%20%E9%80%9A%E7%94%A8%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/"/>
    <url>/2024/02/20/SpringBoot%20%E9%80%9A%E7%94%A8%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-通用限流方案"><a href="#SpringBoot-通用限流方案" class="headerlink" title="SpringBoot 通用限流方案"></a>SpringBoot 通用限流方案</h1><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><blockquote><p>限流对于一个微服务架构系统来说具有非常重要的意义，否则其中的某个微服务将成为整个系统隐藏的雪崩因素，为什么这么说？</p><p>举例来讲，某个SAAS平台有100多个微服务应用，但是作为底层的某个或某几个应用来说，将会被所有上层应用频繁调用，业务高峰期时，如果底层应用不做限流处理，该应用必将面临着巨大的压力，尤其是那些个别被高频调用的接口来说，最直接的表现就是导致后续新进来的请求阻塞、排队、响应超时…最后直到该服务所在JVM资源被耗尽。</p></blockquote><h1 id="二、限流概述"><a href="#二、限流概述" class="headerlink" title="二、限流概述"></a>二、限流概述</h1><blockquote><p>在大多数的微服务架构在设计之初，比如在技术选型阶段，架构师会从一个全局的视角去规划技术栈的组合，比如结合当前产品的现状考虑是使用dubbo？还是springcloud？作为微服务治理的底层框架。甚至为了满足快速的上线、迭代和交付，直接以springboot为基座进行开发，后续再引入新的技术栈等…</p><p>所以在谈论某个业务场景具体的技术解决方案时不可一概而论，而是需要结合产品和业务的现状综合评估，以限流来说，在下面的不同的技术架构下具体在选择的时候可能也不一样。</p></blockquote><h3 id="2-1-dubbo-服务治理模式"><a href="#2-1-dubbo-服务治理模式" class="headerlink" title="2.1 dubbo 服务治理模式"></a>2.1 dubbo 服务治理模式</h3><blockquote><p>选择dubbo框架作为基础服务治理对于那种偏向内部平台的应用还是不错的，dubbo底层走netty，这一点相比http协议来说，在一定场景下还是具有优势的，如果选择dubbo，在选择限流方案上可以做如下的参考。</p></blockquote><h3 id="2-1-1-dubbo框架级限流"><a href="#2-1-1-dubbo框架级限流" class="headerlink" title="2.1.1 dubbo框架级限流"></a>2.1.1 dubbo框架级限流</h3><p>dubbo官方提供了完善的服务治理，能够满足大多数开发场景中的需求，针对限流这个场景，具体来说包括如下手段，具体的配置，可以参考官方手册；</p><p><strong>客户端限流</strong></p><ul><li>信号量限流 （通过统计的方式）</li><li>连接数限流 (socket-&gt;tcp)</li></ul><p><strong>服务端限流</strong></p><ul><li>线程池限流 (隔离手段)</li><li>信号量限流 (非隔离手段)</li><li>接收数限流 (socket-&gt;tcp)</li></ul><h3 id="2-1-2-线程池设置"><a href="#2-1-2-线程池设置" class="headerlink" title="2.1.2 线程池设置"></a>2.1.2 线程池设置</h3><p>多线程并发操作一定离不开线程池，Dubbo自身提供了支持了四种线程池类型支持。生产者<code>&lt;dubbo:protocol&gt;</code>标签中可配置线程池关键参数，线程池类型、阻塞队列大小、核心线程数量等，通过配置生产端的线程池数量可以在一定程度上起到限流的效果。</p><h3 id="2-1-3-集成第三方组件"><a href="#2-1-3-集成第三方组件" class="headerlink" title="2.1.3 集成第三方组件"></a>2.1.3 集成第三方组件</h3><p>如果是springboot框架的项目，可以考虑直接引入地方的组件或SDK，比如hystrix，guava，sentinel原生SDK等，如果技术实力足够强甚至可以考虑自己造轮子。</p><h3 id="2-2-springcloud-服务治理模式"><a href="#2-2-springcloud-服务治理模式" class="headerlink" title="2.2 springcloud 服务治理模式"></a>2.2 springcloud 服务治理模式</h3><p>如果你的服务治理框架选用的是springcloud或springcloud-alibaba，其框架自身的生态中已经包含了相应的限流组件，可以实现开箱即用，下面列举几种常用的基于springcloud框架的限流组件。</p><h3 id="2-2-1-hystrix"><a href="#2-2-1-hystrix" class="headerlink" title="2.2.1 hystrix"></a>2.2.1 hystrix</h3><p>Hystrix是Netflix开源的一款容错框架，在springcloud早期推出市场的时候，作为springcloud生态中用于限流、熔断、降级的一款组件。</p><p>Hystrix提供了限流功能，在springcloud架构的系统中，可以在网关启用Hystrix，进行限流处理，每个微服务也可以各自启用Hystrix进行限流。</p><blockquote><p>Hystrix默认使用线程隔离模式，可以通过线程数+队列大小进行限流，具体参数配置可以参考官网相关资料。</p></blockquote><h3 id="2-2-2-sentinel"><a href="#2-2-2-sentinel" class="headerlink" title="2.2.2 sentinel"></a>2.2.2 sentinel</h3><p>Sentinel 号称分布式系统的流量防卫兵，属于springcloud-alibaba生态中的重要组件，面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p><h3 id="2-3-网关层限流"><a href="#2-3-网关层限流" class="headerlink" title="2.3 网关层限流"></a>2.3 网关层限流</h3><p>随着微服务规模的增加，整个系统中很多微服务都需要实现限流这种需求时，就可以考虑在网关这一层进行限流了，通常来说，网关层的限流面向的是通用的业务，比如那些恶意的请求，爬虫，攻击等，简单来说，网关层面的限流提供了一层对系统整体的保护措施。</p><h1 id="三、常用限流策略"><a href="#三、常用限流策略" class="headerlink" title="三、常用限流策略"></a>三、常用限流策略</h1><h3 id="3-1-限流常用的算法"><a href="#3-1-限流常用的算法" class="headerlink" title="3.1 限流常用的算法"></a>3.1 限流常用的算法</h3><p>不管是哪种限流组件，其底层的限流实现算法大同小异，这里列举几种常用的限流算法以供了解。</p><h3 id="3-1-1-令牌桶算法"><a href="#3-1-1-令牌桶算法" class="headerlink" title="3.1.1 令牌桶算法"></a>3.1.1 令牌桶算法</h3><p>令牌桶算法是目前应用最为广泛的限流算法，顾名思义，它有以下两个关键角色：</p><ul><li>令牌 ：获取到令牌的Request才会被处理，其他Requests要么排队要么被直接丢弃；</li><li>桶 ：用来装令牌的地方，所有Request都从这个桶里面获取令牌</li></ul><p>令牌桶主要涉及到2个过程，即令牌的生成，令牌的获取</p><h3 id="3-1-2-漏桶算法"><a href="#3-1-2-漏桶算法" class="headerlink" title="3.1.2 漏桶算法"></a>3.1.2 漏桶算法</h3><p>漏桶算法的前半段和令牌桶类似，但是操作的对象不同。</p><p>令牌桶是将令牌放入桶里，而漏桶是将访问请求的数据包放到桶里。同样的是，如果桶满了，那么后面新来的数据包将被丢弃。</p><h3 id="3-1-3-滑动时间窗口"><a href="#3-1-3-滑动时间窗口" class="headerlink" title="3.1.3 滑动时间窗口"></a>3.1.3 滑动时间窗口</h3><p>简单描述下滑动时间窗口这种过程：</p><ul><li>黑色大框为时间窗口，可以设定窗口时间单位为5秒，它会随着时间推移向后滑动。我们将窗口内的时间划分为五个小格子，每个格子代表1秒钟，同时这个格子还包含一个计数器，用来计算在当前时间内访问的请求数量。那么这个时间窗口内的总访问量就是所有格子计数器累加后的数值；</li><li>比如说，我们在每一秒内有5个用户访问，第5秒内有10个用户访问，那么在0到5秒这个时间窗口内访问量就是15。如果我们的接口设置了时间窗口内访问上限是20，那么当时间到第六秒的时候，这个时间窗口内的计数总和就变成了10，因为1秒的格子已经退出了时间窗口，因此在第六秒内可以接收的访问量就是20-10=10个；</li></ul><p>滑动窗口其实也是一种计算器算法，它有一个显著特点，当时间窗口的跨度越长时，限流效果就越平滑。打个比方，如果当前时间窗口只有两秒，而访问请求全部集中在第一秒的时候，当时间向后滑动一秒后，当前窗口的计数量将发生较大的变化，拉长时间窗口可以降低这种情况的发生概率</p><h1 id="四、通用限流实现方案"><a href="#四、通用限流实现方案" class="headerlink" title="四、通用限流实现方案"></a>四、通用限流实现方案</h1><p>抛开网关层的限流先不说，在微服务应用中，考虑到技术栈的组合，团队人员的开发水平，以及易维护性等因素，一个比较通用的做法是，利用AOP技术+自定义注解实现对特定的方法或接口进行限流，下面基于这个思路来分别介绍下几种常用的限流方案的实现。</p><h3 id="4-1-基于guava限流实现"><a href="#4-1-基于guava限流实现" class="headerlink" title="4.1 基于guava限流实现"></a>4.1 基于guava限流实现</h3><p>guava为谷歌开源的一个比较实用的组件，利用这个组件可以帮助开发人员完成常规的限流操作，接下来看具体的实现步骤。</p><h3 id="4-1-1-引入guava依赖"><a href="#4-1-1-引入guava依赖" class="headerlink" title="4.1.1 引入guava依赖"></a>4.1.1 引入guava依赖</h3><p>版本可以选择更高的或其他版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-1-2-自定义限流注解"><a href="#4-1-2-自定义限流注解" class="headerlink" title="4.1.2 自定义限流注解"></a>4.1.2 自定义限流注解</h3><p>自定义一个限流用的注解，后面在需要限流的方法或接口上面只需添加该注解即可；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 自定义限流注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/10/13 13:46</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RateInterface &#123;<br>    String <span class="hljs-title function_">limitType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">limitCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5d</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-3-限流AOP类"><a href="#4-1-3-限流AOP类" class="headerlink" title="4.1.3 限流AOP类"></a>4.1.3 限流AOP类</h3><p>通过AOP前置通知的方式拦截添加了上述自定义限流注解的方法，解析注解中的属性值，并以该属性值作为guava提供的限流参数，该类为整个实现的核心所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 限流AOP类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/10/13 13:41</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-comment">//@Componentpublic</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaLimitAop</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(@RateConfigAnno * *(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">limit</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-comment">//1、获取当前的调用方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> getCurrentMethod(joinPoint);<br><br>        <span class="hljs-keyword">if</span> (Objects.isNull(currentMethod)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//2、从方法注解定义上获取限流的类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">limitType</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(RateInterface.class)<br>                .limitType();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">limitCount</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(RateInterface.class)<br>                .limitCount();<br><br>        <span class="hljs-comment">//使用guava的令牌桶算法获取一个令牌，获取不到先等待</span><br>        <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimitHelper.getRateLimiter(limitType,<br>                limitCount);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> rateLimiter.tryAcquire();<br><br>        <span class="hljs-keyword">if</span> (b) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取到令牌&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            jsonObject.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>            jsonObject.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;限流中&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                output(resp, jsonObject.toJSONString());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getCurrentMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        Method[] methods = joinPoint.getTarget().getClass().getMethods();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;<br>                target = method;<br><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">(HttpServletResponse response, String msg)</span><br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            outputStream = response.getOutputStream();<br>            outputStream.write(msg.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            outputStream.flush();<br>            outputStream.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中限流的核心API即为RateLimiter这个对象，涉及到的RateLimitHelper类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 核心API类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/10/13 13:43</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimitHelper</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">RateLimitHelper</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, RateLimiter&gt; rateMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RateLimiter <span class="hljs-title function_">getRateLimiter</span><span class="hljs-params">(String limitType, <span class="hljs-type">double</span> limitCount)</span> &#123;<br>        <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> rateMap.get(limitType);<br>        <span class="hljs-keyword">if</span> (rateLimiter == <span class="hljs-literal">null</span>) &#123;<br>            rateLimiter = RateLimiter.create(limitCount);<br>            rateMap.put(limitType, rateLimiter);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rateLimiter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-4-测试接口"><a href="#4-1-4-测试接口" class="headerlink" title="4.1.4 测试接口"></a>4.1.4 测试接口</h3><p>下面添加一个测试接口，测试一下上面的代码是否生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-comment">//localhost:8081/save    </span><br>    <span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span>@ RateConfigAnno(limitType = <span class="hljs-string">&quot;saveOrder&quot;</span>, limitCount = <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接口中为了模拟出效果，我们将参数设置的非常小，即QPS为1，可以预想当每秒请求超过1时将会出现被限流的提示，启动工程并验证接口，每秒1次的请求，可以正常得到结果</p><h3 id="4-2-基于sentinel限流实现"><a href="#4-2-基于sentinel限流实现" class="headerlink" title="4.2 基于sentinel限流实现"></a>4.2 基于sentinel限流实现</h3><p>在不少同学的意识中，sentinel通常是需要结合springcloud-alibaba框架一起实用的，而且与框架集成之后，可以配合控制台一起使用达到更好的效果，实际上，sentinel官方也提供了相对原生的SDK可供使用，接下来就以这种方式进行整合。</p><h3 id="4-2-1-引入sentinel核心依赖包"><a href="#4-2-1-引入sentinel核心依赖包" class="headerlink" title="4.2.1 引入sentinel核心依赖包"></a>4.2.1 引入sentinel核心依赖包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-2-自定义限流注解"><a href="#4-2-2-自定义限流注解" class="headerlink" title="4.2.2 自定义限流注解"></a>4.2.2 自定义限流注解</h3><p>可以根据需要，添加更多的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span> <br><span class="hljs-keyword">public</span>@ <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SentinelLimitAnnotation</span> &#123;<br>    String <span class="hljs-title function_">resourceName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">limitCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-自定义AOP类实现限流"><a href="#4-2-3-自定义AOP类实现限流" class="headerlink" title="4.2.3 自定义AOP类实现限流"></a>4.2.3 自定义AOP类实现限流</h3><p>该类的实现思路与上述使用guava类似，不同的是，这里使用的是sentinel原生的限流相关的API，对此不够属性的可以查阅官方的文档进行学习，这里就不展开来说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Entry;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.SphU;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Tracer;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelMethodLimitAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRule</span><span class="hljs-params">(String resourceName, <span class="hljs-type">int</span> limitCount)</span> &#123;<br>        List &lt; FlowRule &gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> &lt; &gt; ();<br>        <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>        <span class="hljs-comment">//设置受保护的资源       </span><br>        rule.setResource(resourceName);<br>        <span class="hljs-comment">//设置流控规则 QPS     </span><br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        <span class="hljs-comment">//设置受保护的资源阈值      </span><br>        rule.setCount(limitCount);<br>        rules.add(rule);<br>        <span class="hljs-comment">//加载配置好的规则  </span><br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br><span class="hljs-meta">@Pointcut(value = &quot;@annotation(com.congge.sentinel.SentinelLimitAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-meta">@Around(&quot;rateLimit()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-comment">//1、获取当前的调用方法     </span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> getCurrentMethod(joinPoint);<br>        <span class="hljs-keyword">if</span> (Objects.isNull(currentMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、从方法注解定义上获取限流的类型      </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimitAnnotation.class).resourceName();<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(resourceName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;资源名称为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limitCount</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimitAnnotation.class).limitCount();<br>        initFlowRule(resourceName, limitCount);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            entry = SphU.entry(resourceName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = joinPoint.proceed();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>                throwable.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-comment">// 资源访问阻止，被限流或被降级    </span><br>            <span class="hljs-comment">// 在此处进行相应的处理操作       </span><br>            System.out.println(<span class="hljs-string">&quot;blocked&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;被限流了&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Tracer.traceEntry(e, entry);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>                entry.exit();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getCurrentMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        Method[] methods = joinPoint.getTarget().getClass().getMethods();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Method method: methods) &#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;<br>                target = method;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-自定义测试接口"><a href="#4-2-4-自定义测试接口" class="headerlink" title="4.2.4 自定义测试接口"></a>4.2.4 自定义测试接口</h3><p>为了模拟效果，这里将QPS的数量设置为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/limit&quot;)</span><br><span class="hljs-meta">@SentinelLimitAnnotation(limitCount = 1, resourceName = &quot;sentinelLimit&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sentinelLimit</span><span class="hljs-params">()</span> &#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sentinelLimit&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动工程之后，浏览器调用接口测试一下，每秒一个请求，可以正常通过</p><p>快速刷接口，超过每秒1次,自行查看效果</p><h3 id="4-3-基于redis-lua限流实现"><a href="#4-3-基于redis-lua限流实现" class="headerlink" title="4.3 基于redis+lua限流实现"></a>4.3 基于redis+lua限流实现</h3><p>redis是线程安全的，天然具有线程安全的特性，支持原子性操作，限流服务不仅需要承接超高QPS，还要保证限流逻辑的执行层面具备线程安全的特性，利用Redis这些特性做限流，既能保证线程安全，也能保证性能。基于redis的限流实现完整流程如下图：</p><p>结合上面的流程图，这里梳理出一个整体的实现思路：</p><ul><li>编写lua脚本，指定入参的限流规则，比如对特定的接口限流时，可以根据某个或几个参数进行判定，调用该接口的请求，在一定的时间窗口内监控请求次数；</li><li>既然是限流，最好能够通用，可将限流规则应用到任何接口上，那么最合适的方式就是通过自定义注解形式切入；</li><li>提供一个配置类，被spring的容器管理，redisTemplate中提供了DefaultRedisScript这个bean；</li><li>提供一个能动态解析接口参数的类，根据接口参数进行规则匹配后触发限流；</li></ul><h3 id="4-3-1-引入redis依赖"><a href="#4-3-1-引入redis依赖" class="headerlink" title="4.3.1 引入redis依赖"></a>4.3.1 引入redis依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-自定义注解"><a href="#4-3-2-自定义注解" class="headerlink" title="4.3.2 自定义注解"></a>4.3.2 自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RedisLimitAnnotation &#123;<br>    <span class="hljs-comment">/**     * key     */</span><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">/**    *    Key的前缀    */</span><br>    String <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">/**     * 一定时间内最多访问次数     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/**     * 给定的时间范围 单位(秒)     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">period</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/**     * 限流的类型(用户自定义key或者请求ip)     */</span><br>    LimitType <span class="hljs-title function_">limitType</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LimitType.CUSTOMER;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-自定义redis配置类"><a href="#4-3-3-自定义redis配置类" class="headerlink" title="4.3.3 自定义redis配置类"></a>4.3.3 自定义redis配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.scripting.support.ResourceScriptSource;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DefaultRedisScript &lt; Number &gt; redisluaScript() &#123;<br>        DefaultRedisScript &lt; Number &gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span> &lt;&gt; ();<br>        redisScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;limit.lua&quot;</span>)));<br>        redisScript.setResultType(Number.class);<br>        <span class="hljs-keyword">return</span> redisScript;<br>    &#125;<br><span class="hljs-meta">@Bean(&quot;redisTemplate&quot;)</span><br><span class="hljs-keyword">public</span> RedisTemplate &lt; String, Object &gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;<br>        RedisTemplate &lt; String, Object &gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span> &lt;&gt; ();<br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//设置value的序列化方式为JSON</span><br>        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//设置key的序列化方式为String    </span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-自定义限流AOP类"><a href="#4-3-4-自定义限流AOP类" class="headerlink" title="4.3.4 自定义限流AOP类"></a>4.3.4 自定义限流AOP类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.MethodSignature;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitRestAspect</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LimitRestAspect.class);<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate &lt; String, Object &gt; redisTemplate;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DefaultRedisScript &lt; Number &gt; redisluaScript;<br><span class="hljs-meta">@Pointcut(value = &quot;@annotation(com.congge.config.limit.RedisLimitAnnotation)&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-meta">@Around(&quot;rateLimit()&quot;)</span> <br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">interceptor</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br>            Class &lt;? &gt; targetClass = method.getDeclaringClass();<br>            <span class="hljs-type">RedisLimitAnnotation</span> <span class="hljs-variable">rateLimit</span> <span class="hljs-operator">=</span> method.getAnnotation(RedisLimitAnnotation.class);<br>            <span class="hljs-keyword">if</span> (rateLimit != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ipAddress</span> <span class="hljs-operator">=</span> getIpAddr(request);<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>                stringBuffer.append(ipAddress).append(<span class="hljs-string">&quot;-&quot;</span>).append(targetClass.getName()).append(<span class="hljs-string">&quot;- &quot;</span>).append(method.getName()).append(<span class="hljs-string">&quot;-&quot;</span>).append(rateLimit.key());<br>                List &lt; String &gt; keys = Collections.singletonList(stringBuffer.toString());<br>                <span class="hljs-comment">//调用lua脚本，获取返回结果，这里即为请求的次数      </span><br>                <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> redisTemplate.execute(redisluaScript, keys, rateLimit.count(), rateLimit.period());<br>                <span class="hljs-keyword">if</span> (number != <span class="hljs-literal">null</span> &amp;&amp; number.intValue() != <span class="hljs-number">0</span> &amp;&amp; number.intValue() &lt;= rateLimit.count()) &#123;<br>                    logger.info(<span class="hljs-string">&quot;限流时间段内访问了第：&#123;&#125; 次&quot;</span>, number.toString());<br>                    <span class="hljs-keyword">return</span> joinPoint.proceed();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> joinPoint.proceed();<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;访问频率过快，被限流了&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">/**      </span><br><span class="hljs-comment">   * 获取请求的IP方法  </span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> request     </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span>         */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getIpAddr</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ipAddress</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ipAddress = request.getHeader(<span class="hljs-string">&quot;x-forwarded-for&quot;</span>);<br>            <span class="hljs-keyword">if</span> (ipAddress == <span class="hljs-literal">null</span> || ipAddress.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>                ipAddress = request.getHeader(<span class="hljs-string">&quot;Proxy-Client-IP&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ipAddress == <span class="hljs-literal">null</span> || ipAddress.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>                ipAddress = request.getHeader(<span class="hljs-string">&quot;WL-Proxy-Client-IP&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ipAddress == <span class="hljs-literal">null</span> || ipAddress.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>                ipAddress = request.getRemoteAddr();<br>            &#125;<br>            <span class="hljs-comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割      </span><br>            <span class="hljs-keyword">if</span> (ipAddress != <span class="hljs-literal">null</span> &amp;&amp; ipAddress.length() &gt; <span class="hljs-number">15</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ipAddress.indexOf(<span class="hljs-string">&quot;,&quot;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                    ipAddress = ipAddress.substring(<span class="hljs-number">0</span>, ipAddress.indexOf(<span class="hljs-string">&quot;,&quot;</span>));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ipAddress = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ipAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类要做的事情和上面的两种限流措施类似，不过在这里核心的限流是通过读取lua脚步，通过参数传递给lua脚步实现的。</p><h3 id="4-3-5-自定义lua脚本"><a href="#4-3-5-自定义lua脚本" class="headerlink" title="4.3.5 自定义lua脚本"></a>4.3.5 自定义lua脚本</h3><p>在工程的resources目录下，添加如下的lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = <span class="hljs-string">&quot;rate.limit:&quot;</span>..KEYS[<span class="hljs-number">1</span>]<span class="hljs-keyword">local</span> limit = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> current = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, key) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;0&quot;</span>)<span class="hljs-keyword">if</span> current + <span class="hljs-number">1</span> &gt; limitthenreturn <span class="hljs-number">0</span><span class="hljs-keyword">else</span><span class="hljs-comment">--没有超阈值， 将当前访问数量 + 1， 并设置2秒过期（ 可根据自己的业务情况调整）redis.call(&quot;INCRBY&quot;, key, &quot;1&quot;)redis.call(&quot;expire&quot;, key, &quot;2&quot;)return current + 1end</span><br></code></pre></td></tr></table></figure><h3 id="4-3-6-添加测试接口"><a href="#4-3-6-添加测试接口" class="headerlink" title="4.3.6 添加测试接口"></a>4.3.6 添加测试接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisController</span> &#123; <br><br> <span class="hljs-meta">@GetMapping(&quot;/redis/limit&quot;)</span> <br> <span class="hljs-meta">@RedisLimitAnnotation(key = &quot;queryFromRedis&quot;,period = 1, count = 1)</span> <br> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryFromRedis</span><span class="hljs-params">()</span> &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;   <br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了模拟效果，将QPS设置为1 ，启动工程后（提前启动redis服务），调用一下接口</p><p>快速刷接口，超过每秒1次的请求,可自行查看效果</p><h1 id="五、自定义starter限流实现"><a href="#五、自定义starter限流实现" class="headerlink" title="五、自定义starter限流实现"></a>五、自定义starter限流实现</h1><p>上面通过案例介绍了几种常用的限流实现，不过细心的同学可以看到，这些限流的实现都是在具体的工程模块中嵌入的，事实上，在真实的微服务开发中，一个项目可能包含了众多的微服务模块，为了减少重复造轮子，避免每个微服务模块中单独实现，可以考虑将限流的逻辑实现封装成一个SDK，即作为一个springboot的starter的方式被其他微服务模块进行引用即可。这也是目前很多生产实践中比较通用的做法，接下来看看具体的实现吧。</p><h3 id="5-1-前置准备"><a href="#5-1-前置准备" class="headerlink" title="5.1 前置准备"></a>5.1 前置准备</h3><p>创建一个空的springboot工程，工程目录结构说明：</p><ul><li><code>annotation</code>：存放自定义的限流相关的注解；</li><li><code>aop</code>：存放不同的限流实现，比如基于guava的aop，基于sentinel的aop实现等；</li><li><code>spring.factories</code>：自定义待装配的aop实现类；</li></ul><h3 id="5-2-代码整合完成步骤"><a href="#5-2-代码整合完成步骤" class="headerlink" title="5.2 代码整合完成步骤"></a>5.2 代码整合完成步骤</h3><h3 id="5-2-1-导入基础的依赖"><a href="#5-2-1-导入基础的依赖" class="headerlink" title="5.2.1 导入基础的依赖"></a>5.2.1 导入基础的依赖</h3><p>这里包括如下几个必须的依赖，其他的依赖可以结合自身的情况合理选择；</p><ul><li>spring-boot-starter；</li><li>guava；</li><li>spring-boot-autoconfigure；</li><li>sentinel-core；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>   <br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br><span class="hljs-comment">&lt;!-- guava--&gt;</span>    <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>     <br>   <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>     <br>       <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>     <br>       <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/**<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>   <br>         <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>     <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-2-自定义注解"><a href="#5-2-2-自定义注解" class="headerlink" title="5.2.2 自定义注解"></a>5.2.2 自定义注解</h3><p>目前该SDK支持三种限流方式，即后续其他微服务工程中可以通过添加这3种注解即可实现限流，分别是基于guava的令牌桶，基于sentinel的限流，基于java自带的Semaphore限流，三个自定义注解类如下：</p><p>令牌桶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span>@ <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TokenBucketLimiter</span> &#123; <br>   <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Semaphore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ShLimiter &#123;  <br>  <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <br>  <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>sentinel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SentinelLimiter &#123;  <br>  String <span class="hljs-title function_">resourceName</span><span class="hljs-params">()</span>;   <br>  <span class="hljs-type">int</span> <span class="hljs-title function_">limitCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-3-限流实现AOP类"><a href="#5-2-3-限流实现AOP类" class="headerlink" title="5.2.3 限流实现AOP类"></a>5.2.3 限流实现AOP类</h3><p>具体的限流在AOP中进行实现，思路和上一章节类似，即通过环绕通知的方式，先解析那些添加了限流注解的方法，然后解析里面的参数，进行限流的业务实现。</p><p>基于guava的aop实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson2.JSONObject;<br><span class="hljs-keyword">import</span> com.congge.annotation.TokenBucketLimiter;<br><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.cglib.core.ReflectUtils;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaLimiterAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map &lt; String, RateLimiter &gt; rateLimiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span> &lt;String, RateLimiter&gt; ();<br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.congge.annotation.TokenBucketLimiter)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aspect</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Around(value = &quot;aspect()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.debug(<span class="hljs-string">&quot;准备限流&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> point.getTarget();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> target.getClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>        Object[] arguments = point.getArgs();<br>        Class &lt;? &gt; targetClass = Class.forName(targetName);<br>        Class &lt;? &gt; [] argTypes = ReflectUtils.getClasses(arguments);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(methodName, argTypes);<br>        <span class="hljs-comment">// 获取目标method上的限流注解@Limiter     </span><br>        <span class="hljs-type">TokenBucketLimiter</span> <span class="hljs-variable">limiter</span> <span class="hljs-operator">=</span> method.getAnnotation(TokenBucketLimiter.class);<br>        <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != limiter) &#123;<br>            <span class="hljs-comment">// 以 class + method + parameters为key，避免重载、重写带来的混乱      </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> targetName + <span class="hljs-string">&quot;.&quot;</span> + methodName + Arrays.toString(argTypes);<br>            rateLimiter = rateLimiters.get(key);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == rateLimiter) &#123;<br>                <span class="hljs-comment">// 获取限定的流量     </span><br>                <span class="hljs-comment">// 为了防止并发    </span><br>                rateLimiters.putIfAbsent(key, RateLimiter.create(limiter.value()));<br>                rateLimiter = rateLimiters.get(key);<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> rateLimiter.tryAcquire();<br>            <span class="hljs-keyword">if</span> (b) &#123;<br>                log.debug(<span class="hljs-string">&quot;得到令牌，准备执行业务&quot;</span>);<br>                result = point.proceed();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();<br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>                jsonObject.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>                jsonObject.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;限流中&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    output(resp, jsonObject.toJSONString());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;error,e:&#123;&#125;&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = point.proceed();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;退出限流&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">(HttpServletResponse response, String msg)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            outputStream = response.getOutputStream();<br>            outputStream.write(msg.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            outputStream.flush();<br>            outputStream.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于Semaphore的aop实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.congge.annotation.ShLimiter;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.cglib.core.ReflectUtils;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreLimiterAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map &lt;String, Semaphore&gt; semaphores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span> &lt;String, Semaphore&gt; ();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SemaphoreLimiterAop.class);<br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.congge.annotation.ShLimiter)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aspect</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Around(value = &quot;aspect()&quot;)</span><br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.debug(<span class="hljs-string">&quot;进入限流aop&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> point.getTarget();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> target.getClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>        Object[] arguments = point.getArgs();<br>        Class &lt;? &gt; targetClass = Class.forName(targetName);<br>        Class &lt;? &gt; [] argTypes = ReflectUtils.getClasses(arguments);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(methodName, argTypes);<br>        <span class="hljs-comment">// 获取目标method上的限流注解</span><br>        <span class="hljs-meta">@Limiter</span><br>        <span class="hljs-type">ShLimiter</span> <span class="hljs-variable">limiter</span> <span class="hljs-operator">=</span> method.getAnnotation(ShLimiter.class);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != limiter) &#123;<br>            <span class="hljs-comment">// 以 class + method + parameters为key，避免重载、重写带来的混乱    </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> targetName + <span class="hljs-string">&quot;.&quot;</span> + methodName + Arrays.toString(argTypes);<br>            <span class="hljs-comment">// 获取限定的流量    </span><br>            <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> semaphores.get(key);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == semaphore) &#123;<br>                semaphores.putIfAbsent(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(limiter.value()));<br>                semaphore = semaphores.get(key);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>                result = point.proceed();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != semaphore) &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = point.proceed();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;退出限流&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于sentinel的aop实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Entry;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.SphU;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Tracer;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br><span class="hljs-keyword">import</span> com.congge.annotation.SentinelLimiter;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelLimiterAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRule</span><span class="hljs-params">(String resourceName, <span class="hljs-type">int</span> limitCount)</span> &#123;<br>        List &lt; FlowRule &gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> &lt;&gt; ();<br>        <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>        <span class="hljs-comment">//设置受保护的资源      </span><br>        rule.setResource(resourceName);<br>        <span class="hljs-comment">//设置流控规则 QPS   </span><br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        <span class="hljs-comment">//设置受保护的资源阈值   </span><br>        rule.setCount(limitCount);<br>        rules.add(rule);<br>        <span class="hljs-comment">//加载配置好的规则       </span><br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(com.congge.annotation.SentinelLimiter)&quot;)</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Around(&quot;rateLimit()&quot;)</span> <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-comment">//1、获取当前的调用方法  </span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> getCurrentMethod(joinPoint);<br>        <span class="hljs-keyword">if</span> (Objects.isNull(currentMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、从方法注解定义上获取限流的类型    </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimiter.class).resourceName();<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(resourceName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;资源名称为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limitCount</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimiter.class).limitCount();<br>        initFlowRule(resourceName, limitCount);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            entry = SphU.entry(resourceName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = joinPoint.proceed();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>                throwable.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-comment">// 资源访问阻止，被限流或被降级     </span><br>            <span class="hljs-comment">// 在此处进行相应的处理操作      </span><br>            System.out.println(<span class="hljs-string">&quot;blocked&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;被限流了&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Tracer.traceEntry(e, entry);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>                entry.exit();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getCurrentMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        Method[] methods = joinPoint.getTarget().getClass().getMethods();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Method method: methods) &#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;<br>                target = method;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-4-配置自动装配AOP实现"><a href="#5-2-4-配置自动装配AOP实现" class="headerlink" title="5.2.4 配置自动装配AOP实现"></a>5.2.4 配置自动装配AOP实现</h3><p>在resources目录下创建上述的<code>spring.factories</code>文件，内容如下，通过这种方式配置后，其他应用模块引入了当前的SDK的jar之后，就可以实现开箱即用了；</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\\com<span class="hljs-selector-class">.congge</span><span class="hljs-selector-class">.aop</span><span class="hljs-selector-class">.SemaphoreLimiterAop</span>,\\com<span class="hljs-selector-class">.congge</span><span class="hljs-selector-class">.aop</span><span class="hljs-selector-class">.GuavaLimiterAop</span>,\\com<span class="hljs-selector-class">.congge</span><span class="hljs-selector-class">.aop</span>.SemaphoreLimiterAop<br></code></pre></td></tr></table></figure><h3 id="5-2-5-将工程打成jar进行安装"><a href="#5-2-5-将工程打成jar进行安装" class="headerlink" title="5.2.5 将工程打成jar进行安装"></a>5.2.5 将工程打成jar进行安装</h3><p>这一步比较简单就跳过了</p><h3 id="5-2-6-在其他的工程中引入上述SDK"><a href="#5-2-6-在其他的工程中引入上述SDK" class="headerlink" title="5.2.6 在其他的工程中引入上述SDK"></a>5.2.6 在其他的工程中引入上述SDK</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cm.congge<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>biz-limit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-7-编写测试接口"><a href="#5-2-7-编写测试接口" class="headerlink" title="5.2.7 编写测试接口"></a>5.2.7 编写测试接口</h3><p>在其他工程中，编写一个测试接口，并使用上面的注解，这里以guava的限流注解为例进行说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.congge.annotation.TokenBucketLimiter;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SdkController</span> &#123;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br>    <span class="hljs-meta">@TokenBucketLimiter(1)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queryUser&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-8-功能测试"><a href="#5-2-8-功能测试" class="headerlink" title="5.2.8 功能测试"></a>5.2.8 功能测试</h3><p>启动当前的工程后，正常调用接口，每秒一次的请求，可以正常得到结果</p><p>快速刷接口，QPS超过1之后，将会触发限流</p><p>通过上面这种方式，也可以得到预期的效果，其他两种限流注解有兴趣的同学也可以继续测试验证，篇幅原因就不再赘述了。</p><blockquote><p>上述通过starter的方式实现了一种更优雅的限流集成方式，也是生产中比较推荐的一种方式，不过当前的案例还比较粗糙，需要使用的同学还需根据自己的情况完善里面的逻辑，进一步的封装以期得到更好的效果。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile指令详解</title>
    <link href="/2023/12/28/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/12/28/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM**"></a>FROM**</h3><ul><li>说明：指定该镜像的基础镜像</li><li>格式如：<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code></li><li>示例：<code>FROM centos:7</code></li><li>注意：<code>FROM</code>一般出现在文件头，且每个镜像都需要有一个<code>FROM</code>来指定基础镜像。</li></ul><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a><strong>MAINTAINER</strong></h3><ul><li>说明：指定作者信息</li><li>格式如：<code>MAINTAINER &lt;name&gt;</code></li><li>示例：<code>MAINTAINER along</code></li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><strong>RUN</strong></h3><ul><li>说明：在构建镜像时执行脚本</li><li>格式如：<code>RUN &lt;command&gt;</code>、<code>RUN [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>RUN ls -l</code>（以详细信息方式列表当前目录下的文件，跟在shell终端运行一样）</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><strong>CMD</strong></h3><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>CMD &lt;command&gt; &lt;par1&gt; &lt;par2&gt; ...</code>、<code>CMD [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>CMD [&quot;ls&quot;, &quot;-l&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>CMD</code>，如果有多条只执行最后一条；在运行容器时如果用户指定了运行命令则Dockerfile中的CMD将被覆盖。</li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a><strong>ENTRYPOINT</strong></h3><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>ENTRYPOINT [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code>、<code>ENTRYPOINT command par1 par2</code></li><li>示例：<code>ENTRYPOINT [&quot;catalina.sh&quot;, &quot;run&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>ENTRYPOINT</code>，如果有多条只执行最后一条；不可以被容器运行时的命令所覆盖。</li></ul><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a><strong>EXPOSE</strong></h3><ul><li>说明：让Docker暴露容器的端口号，供其他容器使用，在宿主机以外的网络中是无法使用的</li><li>格式如：<code>EXPOSE &lt;port&gt; ...</code></li><li>示例：<code>EXPOSE 8080</code></li><li>注意： <ul><li>在Docker中有两种暴露端口的概念，一种叫<code>EXPOSE</code>隐式暴露，只供Docker服务内部使用；另一种叫<code>PUBLISH</code>显式暴露，供外部网络使用，<code>PUBLISH</code>只是一个概念在Dockerfile中没有这个指令。</li><li><code>EXPOSE</code> 只在Dockerfile中出现，所暴露的端口只是被其他容器使用</li><li><code>PUBLISH</code> 没有该指令而是通过<code>docker run</code>命令的参数<code>p</code>、<code>P</code>或在<code>docker-compose</code>中的<code>ports</code>来体现</li><li><code>P</code>：大写是属于自动映射，将Dockerfile中<code>EXPOSE</code>所暴露的所有端口分别映射到宿主机的随机端口，每次启动或重启容器时端口都可能有所不同</li><li><code>p</code>：小写是属于固定映射，格式如：<code>p 宿主端口:容器端口</code>，宿主端口和容器端口可以是纯数字也可以是一个范围，如：<code>p 8060-8080:8060-8080</code>，意为将宿主机的<code>8060</code>（含）到<code>8080</code>（含）的端口映射到容器的<code>8060</code>（含）到<code>8080</code>（含）端口，需要注意的是在使用范围时，宿主端口个数应该与容器端口个数匹配；但上面这个例子可以写成：<code>p 7060-7080:8060-8080</code>，这样宿主的端口就在<code>7060-7080</code>范围内</li></ul></li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a><strong>ENV</strong></h3><ul><li>说明：指定环境变量，在Dockerfile文件中的后续代码中使用，在容器运行时也可以使用</li><li>格式如：<code>ENV &lt;key&gt; &lt;value&gt;</code></li><li>示例：<code>ENV tomcat_home /web/tomcat/</code></li></ul><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><strong>ADD</strong></h3><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>ADD &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>ADD web.jar /web.jar</code></li><li>注意：复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径，也可以是一个URL，也可以是一个<code>tar</code>文件（<code>tar</code>文件将自动解压成文件目录）</li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a><strong>COPY</strong></h3><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>COPY &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>COPY web.jar /web.jar</code></li><li>注意：与<code>ADD</code>功能相似，只是不能指定URL，使用本地文件（夹）为源文件时，推荐使用<code>COPY</code></li></ul><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a><strong>VOLUME</strong></h3><ul><li><p>说明：创建挂载点</p></li><li><p>格式如：<code>VOLUME [path]</code></p></li><li><p>示例：<code>VOLUME [&quot;/datas&quot;]</code></p></li><li><p>注意： </p><ul><li><p><code>VOLUME</code>在原理和概念上与<code>EXPOSE</code>差不多，都是属于供容器与容器间使用</p></li><li><p>通过<code>VOLUME</code>挂载的卷可以供其他容器使用</p></li><li><p>举例说明： </p><ul><li><p>创建一个Dockerfile来构建一个镜像，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM centos  VOLUME [<span class="hljs-string">&quot;/web/images&quot;</span>, <span class="hljs-string">&quot;/web/files&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t <span class="hljs-string">&quot;zsl131/test01&quot;</span> .<br></code></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name test-root<br></code></pre></td></tr></table></figure></li><li><p>可以使用命令：<code>docker inspect test-root</code>来查看容器详细信息，在<code>Mounts</code>部份可以看到两个挂载点：<code>/web/images</code>和<code>/web/files</code></p></li><li><p>启动另一个容器来共用这两个挂载卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name test-1 --volumes-from test-root centos<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>使用<code>--volumes-from</code>来指定挂载点，这时容器<code>test-root</code>和<code>test-1</code>里面都分别有挂载卷<code>/web/images</code>和<code>/web/files</code>，可以启动任意多个容器使用<code>--volumes-from</code>来共用这些挂载卷，这些容器可以来自不同的镜像。当任何一个容器中的挂载卷中的文件发生变化时其他容器挂载卷中的内容也随之改变。</p><p>容器<code>test-root</code>即使已经停止也可以在启动其他容器时使用<code>--volumes-from test-root</code>来挂载这些卷，只要<code>test-root</code>不被删除，不过如果<code>test-root</code>真被删除还可以使用<code>--volumes-from test-1</code>，因为容器<code>test-1</code>中还存在我们所需要的挂载卷，换句话说这些挂载卷永远存在直到所有使用这些挂载卷的容器都被删除。</p></li><li><p><code>VOLUME</code>与<code>docker run</code>参数<code>v</code>是有区别的。<code>docker run -v /host/web/images:/web/images -v /host/web/files:/web/files:rw</code>是将容器内的<code>/web/images</code>挂载到宿主机的<code>/host/web/images</code>目录上；将容器内的<code>/web/files</code>挂载到宿主机的<code>/host/web/files</code>目录上，<code>rw</code>表示可读写。</p></li></ul></li></ul></li></ul><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a><strong>WORKDIR</strong></h3><ul><li>说明：设置工作目录</li><li>格式如：<code>WORKDIR /path</code></li><li>示例：<code>WORKDIR /web</code></li><li>注意：可以使用绝对路径，也可以使用相对路径，设置之后的所有操作都将在这个目录下完成</li></ul><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>在上面的描述中可以看到有两组指令在功能上都差不多，但也是有区别的：</p><ul><li>RUN/CMD/ENTRYPOINT 执行脚本的指令 <ul><li>三个指令都是执行脚本</li><li><code>RUN</code>是在创建镜像是执行，即使用<code>docker build</code>命令时执行，在一个Dockerfile里面可以有多个<code>RUN</code></li><li><code>CMD</code>和<code>ENTRYPOINT</code>是在运行容器时执行，即使用<code>docker run</code>命令时执行，这两个指令在Dockerfile中都只有最行一条被执行</li><li><code>CMD</code>在使用<code>docker run</code>时可以加参数将Dockerfile中的<code>CMD</code>覆盖</li><li><code>ENTRYPOINT</code>在Dockerfile中出现后就一定会在<code>docker run</code>时被执行，不必担心会被其他参数所覆盖。</li></ul></li><li>ADD/COPY 拷贝文件（夹）到容器 <ul><li><code>ADD</code>拷贝文件（夹）时可以指定本地文件、远程URL地址，如果拷贝的是<code>tar</code>文件时将会被自动解压成文件夹</li><li><code>COPY</code>拷贝文件（夹）时不可以指定远程URL地址，拷贝<code>tar</code>文件也不会被自动解压成文件夹，在拷贝本地文件时建议使用<code>COPY</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>&lt;Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s &amp; Docker</title>
    <link href="/2023/12/25/K8s%20&amp;%20Docker/"/>
    <url>/2023/12/25/K8s%20&amp;%20Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="K8s-amp-Docker"><a href="#K8s-amp-Docker" class="headerlink" title="K8s &amp; Docker"></a>K8s &amp; Docker</h1><h2 id="kubectl-概述"><a href="#kubectl-概述" class="headerlink" title="kubectl 概述"></a><strong>kubectl 概述</strong></h2><blockquote><p>kubectl 是用于运行 Kubernetes 集群命令的管理工具</p></blockquote><h2 id="kubectl-与-Docker-命令关系"><a href="#kubectl-与-Docker-命令关系" class="headerlink" title="kubectl 与 Docker 命令关系"></a><strong>kubectl 与 Docker 命令关系</strong></h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a><strong>docker run</strong></h3><blockquote><p>运行nginx</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --restart=always -e DOMAIN=cluster --name nginx-app -p 80:80 nginx<br>a9e<br></code></pre></td></tr></table></figure><blockquote><p><strong>docker ps</strong></p></blockquote><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>STATUS</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>a9ec34d98787</td><td>nginx</td><td>“nginx -g ‘daemon of</td><td>2 seconds ago</td><td>Up 2 seconds</td><td>0.0.0.0:80-&gt;80/tcp,443/tcp</td><td>nginx-app</td></tr></tbody></table><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># start the pod running nginx</span><br>$ kubectl run --image=nginx nginx-app --port=80 --<span class="hljs-built_in">env</span>=<span class="hljs-string">&quot;DOMAIN=cluster&quot;</span> deployment <span class="hljs-string">&quot;nginx-app&quot;</span> created<br></code></pre></td></tr></table></figure><p>kubectl run 在 Kubernetes 集群&gt; = v1.2 上将创建名是 “nginx-app”的 Deployment。如果 运行的是低的版本，则会创建一个 replication controllers，如果要了解低版本方式，请使 用–generator=run/v1，将会创建 replication controllers。查看 kubectl run 更多详情。现 在，我们可以使用上面创建的 Deployment 来暴露一个新的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#expose a port through with a service</span><br>$ kubectl expose deployment nginx-app --port=80 --name=nginx-http service <span class="hljs-string">&quot;nginx-http&quot;</span> exposed<br></code></pre></td></tr></table></figure><p>使用 kubectl 创建一个 Deployment，他能保证任何情况下有 N 个运行 nginx 的 pods（其 中 N 是默认定义声明的副本数，默认为 1 个）。它同时会创建一个 Services，使用选择器 匹配 Deployment’s selector。</p><p>默认情况下镜像在后台运行，类似于 docker run -d …在前台运行，使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl run [-i] [--<span class="hljs-built_in">tty</span>] --attach &lt;name&gt; --image=&lt;image&gt;<br>要删除 Deployment （及其 pod）<br>kubectl delete deployment &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><strong>docker ps</strong></h3><blockquote><p>列出当前运行的内容</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker ps<br></code></pre></td></tr></table></figure><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>STATUS</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>a9ec34d98787</td><td>nginx</td><td>“nginx -g ‘daemon of</td><td>About an hour ago</td><td>Up About an hour</td><td>0.0.0.0:80-&gt;80/tcp,443/tcp</td><td>nginx-app</td></tr></tbody></table><ul><li><strong>使用kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get po<br></code></pre></td></tr></table></figure><table><thead><tr><th>NAME</th><th>READY</th><th>STATUS</th><th>RESTARTS</th><th>AGE</th></tr></thead><tbody><tr><td>nginx-app</td><td>1/1</td><td>Running</td><td>0</td><td>1h</td></tr></tbody></table><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><blockquote><p>连接已经运行在容器中的进程</p></blockquote><ul><li><strong>使用docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker attach CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl attach -it NAME<br></code></pre></td></tr></table></figure><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a><strong>docker exec</strong></h3><blockquote><p>何在容器中执行命令</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> CONTAINER ID <span class="hljs-built_in">cat</span> /etc/hostname CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl <span class="hljs-built_in">exec</span> NAME -- <span class="hljs-built_in">cat</span> /etc/hostname NAME<br></code></pre></td></tr></table></figure><blockquote><p>交互式命令</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -ti CONTAINER ID /bin/sh<br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl <span class="hljs-built_in">exec</span> -ti NAME -- /bin/sh<br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a><strong>docker logs</strong></h3><blockquote><p>查看进程打印 stdout / stderr</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -f CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl logs -f NAME<br></code></pre></td></tr></table></figure><blockquote><p>pods和containers之间的微小差异</p></blockquote><p>默认情况下，如果进程退出，pods是不会终止，相反，它会重新启动该进程。这与 docker run 配置–restart=always 选项有一个主要区别。要查看以前在 Kubernetes 中运行的输出，请运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl logs --previous NAME<br></code></pre></td></tr></table></figure><h3 id="docker-stop-和-docker-rm"><a href="#docker-stop-和-docker-rm" class="headerlink" title="docker stop 和 docker rm"></a><strong>docker stop 和 docker rm</strong></h3><blockquote><p>停止和删除正在运行的进程</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker stop CONTAINER ID<br>$ docker <span class="hljs-built_in">rm</span> CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get deployment NAME<br>$ kubectl get po -l run=NAME<br>$ kubectl delete deployment NAME<br>$ kubectl get po -l run=NAME<br></code></pre></td></tr></table></figure><p>注意，不要直接删除 pod，使用 kubectl 请删除拥有该 pod 的 Deployment。如果直接删除 pod，则 Deployment将会重新创建该pod。</p><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a><strong>docker version</strong></h3><blockquote><p>获取客户端和服务器的版本号</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker version<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl version<br></code></pre></td></tr></table></figure><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a><strong>docker info</strong></h3><blockquote><p>获取有关配置和环境信息</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker info<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl cluster-info<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h2><h3 id="1、查看集群状态"><a href="#1、查看集群状态" class="headerlink" title="1、查看集群状态"></a><strong>1、查看集群状态</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看客户端及服务端程序版本信息<br>kubectl version --short=<span class="hljs-literal">true</span><br>查看集群信息<br>kubectl cluster-info<br></code></pre></td></tr></table></figure><h3 id="2、创建资源对象"><a href="#2、创建资源对象" class="headerlink" title="2、创建资源对象"></a><strong>2、创建资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl run name --image=(镜像名) --replicas=(备份数) --port=(容器要暴露的端口) -labels=(设定自定义标签)<br>陈述式对象配置管理方式<br>kubectl create -f **.yaml<br>声明式对象配置管理方式（也适用于更新等）<br>kubectl apply -f **.yaml<br></code></pre></td></tr></table></figure><h3 id="3、查看资源对象"><a href="#3、查看资源对象" class="headerlink" title="3、查看资源对象"></a><strong>3、查看资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get namespace 查看命名空间<br>kubectl get pods,services -o wide (-o 输出格式 wide 表示 plain-text)<br>kubectl get pod -l <span class="hljs-string">&quot;key=value,key=value&quot;</span> -n kube-system (-l 标签选择器(多个的话是与逻辑)，-n 指定命名空间，不指定默认 default)<br>kubectl get pod -l <span class="hljs-string">&quot;key1 in (val1,val2),!key2&quot;</span> -L key (-l 基于集合的标签选择器, -L 查询结果显示标签) 注意：为了避免和 shell 解释器解析!,必须要为此类表达式使用单引号<br>kubectl get pod -w(-w 监视资源变动信息)<br></code></pre></td></tr></table></figure><h3 id="4、打印容器中日志信息"><a href="#4、打印容器中日志信息" class="headerlink" title="4、打印容器中日志信息"></a><strong>4、打印容器中日志信息</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs name -f -c container_name -n kube-system (-f 持续监控，-c 如果 pod 中只有一个容器不用加)<br></code></pre></td></tr></table></figure><h3 id="5、在容器中执行命令"><a href="#5、在容器中执行命令" class="headerlink" title="5、在容器中执行命令"></a>5、在容器中执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> name -c container_name -n kube-system -- 具体命令<br>进入容器的交互式 shell<br>kubectl <span class="hljs-built_in">exec</span> -it pod_name /bin/sh<br></code></pre></td></tr></table></figure><h3 id="6、删除资源对象"><a href="#6、删除资源对象" class="headerlink" title="6、删除资源对象"></a><strong>6、删除资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除指定资源对象<br>kubectl delete [pods/services/deployments/...] name<br>删 除kube-system 下指定标签的资源对象<br>kubectl delete [pods/services/deployments/...] -l key=value -n kube-system<br>删除 kube-system 下所有资源对象<br>kubectl delete [pods/services/deployments/...] --all -n kube-system<br>强制删除 Terminating 的资源对象<br>kubectl delete [pods/services/deployments/...] source_name --force --grace-period=0 -n kube-system<br>kubectl delete -f xx.yaml<br>kubectl apply -f xx.yaml --prune -l &lt;labels&gt;(一般不用这种方式删除)<br>kubectl delete rs rs_name --cascade=fale(默认删除控制器会同时删除其管控的所有 Pod对象，加上 cascade=<span class="hljs-literal">false</span> 就只删除 rs)<br></code></pre></td></tr></table></figure><h3 id="7、更新资源对象"><a href="#7、更新资源对象" class="headerlink" title="7、更新资源对象"></a><strong>7、更新资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl replace -f xx.yaml --force(--force 如果需要基于此前的配置文件进行替换，需要加上 force)<br></code></pre></td></tr></table></figure><h3 id="8、将服务暴露出去-创建-Service"><a href="#8、将服务暴露出去-创建-Service" class="headerlink" title="8、将服务暴露出去(创建 Service)"></a><strong>8、将服务暴露出去(创建 Service)</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl expose deployments/deployment_name --<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;NodePort&quot;</span> --port=(要暴露的容器端口) --name=(Service 对象名字)<br></code></pre></td></tr></table></figure><h3 id="9、扩容和缩容"><a href="#9、扩容和缩容" class="headerlink" title="9、扩容和缩容"></a><strong>9、扩容和缩容</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl scale deployment/deployment_name --replicas=N<br>kubectl scale deployment/deployment_name --replicas=N --current-replicas=M <br>只有当前副本数等于 M 时才会执行扩容或者缩容<br></code></pre></td></tr></table></figure><h3 id="10、查看-API-版本"><a href="#10、查看-API-版本" class="headerlink" title="10、查看 API 版本"></a><strong>10、查看 API 版本</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl api-versions<br></code></pre></td></tr></table></figure><h3 id="11、在本地主机上为-API-Server-启动一个代理网关"><a href="#11、在本地主机上为-API-Server-启动一个代理网关" class="headerlink" title="11、在本地主机上为 API Server 启动一个代理网关"></a><strong>11、在本地主机上为 API Server 启动一个代理网关</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl proxy --port=8080<br>之后就可以通过 curl 来对此套字节发起访问请求<br>curl localhost:8080/api/v1/namespaces/ | jq .items[].metadata.name<br>(jq 可以对 json 进行过滤)<br></code></pre></td></tr></table></figure><h3 id="12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释"><a href="#12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释" class="headerlink" title="12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释"></a><strong>12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(二级对象可用类似于 pods.spec 这种方式查看)<br>kubectl explain pods/deployments/...<br></code></pre></td></tr></table></figure><h3 id="13、查看某资源对象的配置文件"><a href="#13、查看某资源对象的配置文件" class="headerlink" title="13、查看某资源对象的配置文件"></a><strong>13、查看某资源对象的配置文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(--<span class="hljs-built_in">export</span> 表示省略由系统生成的信息) 后面加 &gt; file.yaml 就可以快速生成一个配置文件了<br>kubectl get source_type source_name -o yaml --<span class="hljs-built_in">export</span><br></code></pre></td></tr></table></figure><h3 id="14、标签管理相关命令"><a href="#14、标签管理相关命令" class="headerlink" title="14、标签管理相关命令"></a><strong>14、标签管理相关命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">添 加 标 签 , 如 果 是 修 改 的 话 需 要 后 面 添 加 -overwrite<br>kubectl label pods/pod_name key=value<br>给 工 作 节 点 添 加 标 签 ， 后 续 可 以 使 用<br>kubectl label nodes node_name key=value<br>来指定 pod 被调度到指定的工作节点上运行<br>nodeSelector<br></code></pre></td></tr></table></figure><h3 id="15、注解管理相关命令"><a href="#15、注解管理相关命令" class="headerlink" title="15、注解管理相关命令"></a><strong>15、注解管理相关命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl annotate pods pod_name key=value<br></code></pre></td></tr></table></figure><h3 id="16、patch-修改-Deployment-控制器进行控制器升级"><a href="#16、patch-修改-Deployment-控制器进行控制器升级" class="headerlink" title="16、patch 修改 Deployment 控制器进行控制器升级"></a><strong>16、patch 修改 Deployment 控制器进行控制器升级</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">(-p以补丁形式更新补丁形式默认是 json)<br>kubectl patch deployment deployment-demo -p <span class="hljs-string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;minReadySeconds&quot;: 5&#125;&#125;&#x27;</span><br>修改depolyment 中的镜像文件<br>kubectl <span class="hljs-built_in">set</span> image deployments deployment-demo myapp=ikubernetes/myapp:v2 <br>打印滚动更新过程中的状态信息<br>kubectl rollout status deployment deployment-demo<br>监控 deployment 的更新过程<br>kubectl get deployments deployment-demo --watch<br>暂停更新<br>kubectl kubectl rollout pause deployments deployment-demo<br>继续更新<br>kubectl rollout resume deployments deployment-demo<br>查看历史版本(能查到具体的历史需要在 apply 的时候加上--record 参数)<br>kubectl rollout <span class="hljs-built_in">history</span> deployments deployment-demo<br>回滚到指定版本，不加--to-version 则回滚到上一个版本<br>kubectl rollout undo deployments deployment-demo --to-revision=2 <br></code></pre></td></tr></table></figure><h3 id="17、查看所有-pod-列表-n-后跟-namespace-查看指定的命名空间"><a href="#17、查看所有-pod-列表-n-后跟-namespace-查看指定的命名空间" class="headerlink" title="17、查看所有 pod 列表, -n 后跟 namespace, 查看指定的命名空间"></a><strong>17、查看所有 pod 列表, -n 后跟 namespace, 查看指定的命名空间</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pod<br>kubectl get pod -n kubekubectl get pod -o wide<br></code></pre></td></tr></table></figure><h3 id="18、查看-RC-和-service-列表，-o-wide-查看详细信息"><a href="#18、查看-RC-和-service-列表，-o-wide-查看详细信息" class="headerlink" title="18、查看 RC 和 service 列表， -o wide 查看详细信息"></a><strong>18、查看 RC 和 service 列表， -o wide 查看详细信息</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get rc,svc<br>kubectl get pod,svc -o wide<br>kubectl get pod &lt;pod-name&gt; -o yaml<br></code></pre></td></tr></table></figure><h3 id="19、显示-Node-的详细信息"><a href="#19、显示-Node-的详细信息" class="headerlink" title="19、显示 Node 的详细信息"></a><strong>19、显示 Node 的详细信息</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe node 192.168.0.212<br></code></pre></td></tr></table></figure><h3 id="20、显示-Pod-的详细信息-特别是查看-pod-无法创建的时候的日志"><a href="#20、显示-Pod-的详细信息-特别是查看-pod-无法创建的时候的日志" class="headerlink" title="20、显示 Pod 的详细信息, 特别是查看 pod 无法创建的时候的日志"></a><strong>20、显示 Pod 的详细信息, 特别是查看 pod 无法创建的时候的日志</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe pod &lt;pod-name&gt;<br>eg: kubectl describe pod redis-master-tqds9<br></code></pre></td></tr></table></figure><h3 id="21、根据-yaml-创建资源-apply-可以重复执行，create不行"><a href="#21、根据-yaml-创建资源-apply-可以重复执行，create不行" class="headerlink" title="21、根据 yaml 创建资源, apply 可以重复执行，create不行"></a><strong>21、根据 yaml 创建资源, apply 可以重复执行，create不行</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create -f pod.yaml<br>kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="22、基于-pod-yaml-定义的名称删除-pod"><a href="#22、基于-pod-yaml-定义的名称删除-pod" class="headerlink" title="22、基于 pod.yaml 定义的名称删除 pod"></a><strong>22、基于 pod.yaml 定义的名称删除 pod</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="23、删除所有包含某个-label-的-pod-和-service"><a href="#23、删除所有包含某个-label-的-pod-和-service" class="headerlink" title="23、删除所有包含某个 label 的 pod 和 service"></a><strong>23、删除所有包含某个 label 的 pod 和 service</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete pod,svc -l name=&lt;label-name&gt;<br></code></pre></td></tr></table></figure><h3 id="24、删除所有-Pod"><a href="#24、删除所有-Pod" class="headerlink" title="24、删除所有 Pod"></a><strong>24、删除所有 Pod</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete pod --all<br></code></pre></td></tr></table></figure><h3 id="25、查看-endpoint-列表"><a href="#25、查看-endpoint-列表" class="headerlink" title="25、查看 endpoint 列表"></a><strong>25、查看 endpoint 列表</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get endpoints<br></code></pre></td></tr></table></figure><h3 id="26、执行-pod-的-date-命令"><a href="#26、执行-pod-的-date-命令" class="headerlink" title="26、执行 pod 的 date 命令"></a><strong>26、执行 pod 的 date 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -- <span class="hljs-built_in">date</span><br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -- bash<br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -- ping 10.24.51.9<br></code></pre></td></tr></table></figure><h3 id="27、通过-bash-获得-pod-中某个容器的-TTY，相当于登录容器"><a href="#27、通过-bash-获得-pod-中某个容器的-TTY，相当于登录容器" class="headerlink" title="27、通过 bash 获得 pod 中某个容器的 TTY，相当于登录容器"></a><strong>27、通过 bash 获得 pod 中某个容器的 TTY，相当于登录容器</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -it &lt;pod-name&gt; -c &lt;container-name&gt; -- bash<br>eg: kubectl <span class="hljs-built_in">exec</span> -it redis-master-cln81 -- bash<br></code></pre></td></tr></table></figure><h3 id="28、查看容器的日志"><a href="#28、查看容器的日志" class="headerlink" title="28、查看容器的日志"></a><strong>28、查看容器的日志</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs &lt;pod-name&gt;<br>kubectl logs -f &lt;pod-name&gt; <span class="hljs-comment"># 实时查看日志</span><br>kubectl <span class="hljs-built_in">log</span> &lt;pod-name&gt; -c &lt;container_name&gt; <span class="hljs-comment"># 若 pod 只有一个容器，可以不加 -c</span><br></code></pre></td></tr></table></figure><h3 id="29、查看注释"><a href="#29、查看注释" class="headerlink" title="29、查看注释"></a><strong>29、查看注释</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl explain pod<br>kubectl explain pod.apiVersion<br></code></pre></td></tr></table></figure><h3 id="30、查看节点-labels"><a href="#30、查看节点-labels" class="headerlink" title="30、查看节点 labels"></a><strong>30、查看节点 labels</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get node --show-labels<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器日志</title>
    <link href="/2023/12/18/Docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/"/>
    <url>/2023/12/18/Docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="docker容器日志"><a href="#docker容器日志" class="headerlink" title="docker容器日志"></a>docker容器日志</h1><h1 id="docker-logs－查看docker容器日志"><a href="#docker-logs－查看docker容器日志" class="headerlink" title="docker logs－查看docker容器日志"></a>docker logs－查看docker容器日志</h1><p>通过docker logs命令可以查看容器的日志。</p><p><strong>命令格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs [OPTIONS] CONTAINER<br>  Options:<br>        --details        显示更多的信息<br>    -f, --follow         跟踪实时日志<br>        --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）<br>        --<span class="hljs-built_in">tail</span> string    从日志末尾显示多少行日志， 默认是all<br>    -t, --timestamps     显示时间戳<br>        --<span class="hljs-keyword">until</span> string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><p>查看指定时间后的日志，只显示最后100行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -f -t --since=<span class="hljs-string">&quot;2023-10-08&quot;</span> --<span class="hljs-built_in">tail</span>=100 CONTAINER_ID<br></code></pre></td></tr></table></figure><p>查看最近30分钟的日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs --since 30m CONTAINER_ID<br></code></pre></td></tr></table></figure><p>查看某时间之后的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -t --since=<span class="hljs-string">&quot;2023-10-08T13:23:37&quot;</span> CONTAINER_ID<br></code></pre></td></tr></table></figure><p>查看某时间段日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -t --since=<span class="hljs-string">&quot;2023-10-08T13:23:37&quot;</span> --<span class="hljs-keyword">until</span> <span class="hljs-string">&quot;2023-10-09T12:23:37&quot;</span> CONTAINER_ID<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker 服务器日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令总结</title>
    <link href="/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令总结"><a href="#Linux命令总结" class="headerlink" title="Linux命令总结"></a>Linux命令总结</h1><p>[TOC]</p><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><blockquote><ul><li>uname -m <ul><li>显示机器的处理器架构</li></ul></li><li>uname -r<ul><li> 显示正在使用的内核版本</li></ul></li><li>dmidecode -q<ul><li> 显示硬件系统部件</li></ul></li><li>(SMBIOS / DMI) hdparm -i /dev/hda<ul><li> 罗列一个磁盘的架构特性</li></ul></li><li>hdparm -tT /dev/sda<ul><li> 在磁盘上执行测试性读取操作系统信息</li></ul></li><li>arch<ul><li> 显示机器的处理器架构</li></ul></li><li>uname -m<ul><li> 显示机器的处理器架构</li></ul></li><li>uname -r<ul><li> 显示正在使用的内核版本</li></ul></li><li>dmidecode -q<ul><li> 显示硬件系统部件 - (SMBIOS / DMI)</li></ul></li><li>hdparm -i /dev/hda<ul><li> 罗列一个磁盘的架构特性</li></ul></li><li>hdparm -tT /dev/sda<ul><li> 在磁盘上执行测试性读取操作</li></ul></li><li>cat /proc/cpuinfo<ul><li> 显示CPU info的信息</li></ul></li><li>cat /proc/interrupts<ul><li> 显示中断</li></ul></li><li>cat /proc/meminfo<ul><li> 校验内存使用</li></ul></li><li>cat /proc/swaps<ul><li> 显示哪些swap被使用</li></ul></li><li>cat /proc/version<ul><li> 显示内核的版本</li></ul></li><li>cat /proc/net/dev<ul><li> 显示网络适配器及统计</li></ul></li><li>cat /proc/mounts<ul><li> 显示已加载的文件系统</li></ul></li><li>lspci -tv <ul><li>罗列 PCI 设备</li></ul></li><li>lsusb -tv<ul><li> 显示 USB 设备</li></ul></li><li>date 显示系统日期</li><li>cal 2007 显示2007年的日历表</li><li>date 041217002007.00 设置日期和时间 - 月日时分年.秒</li><li>clock -w 将时间修改保存到 BIOS</li></ul></blockquote><h2 id="2-关机"><a href="#2-关机" class="headerlink" title="2. 关机"></a>2. 关机</h2><blockquote><ul><li>shutdown -h now 关闭系统(1)</li><li>init 0 关闭系统(2)</li><li>telinit 0 关闭系统(3)</li><li>shutdown -h hours:minutes &amp; 按预定时间关闭系统</li><li>shutdown -c 取消按预定时间关闭系统</li><li>shutdown -r now 重启(1)</li><li>reboot 重启(2)</li><li>logout 注销</li></ul></blockquote><h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3. 文件和目录"></a>3. 文件和目录</h2><blockquote><ul><li>cd /home <ul><li>进入 ‘/ home’ 目录’</li></ul></li><li>cd .. <ul><li>返回上一级目录</li></ul></li><li>cd ../.. <ul><li>返回上两级目录</li></ul></li><li>cd <ul><li>进入个人的主目录</li></ul></li><li>cd ~user1<ul><li>进入个人的主目录</li></ul></li><li>cd -<ul><li>返回上次所在的目录</li></ul></li><li>pwd <ul><li>显示工作路径</li></ul></li><li>ls<ul><li>查看目录中的文件</li></ul></li><li>ls -F<ul><li>查看目录中的文件</li></ul></li><li>ls -l<ul><li>显示文件和目录的详细资料</li></ul></li><li>ls -a<ul><li>显示隐藏文件</li></ul></li><li>ls <em>[0-9]</em><ul><li>显示包含数字的文件名和目录名</li></ul></li><li>tree<ul><li>显示文件和目录由根目录开始的树形结构(1)</li></ul></li><li>lstree<ul><li>显示文件和目录由根目录开始的树形结构(2)</li></ul></li><li>mkdir dir1<ul><li>创建一个叫做 ‘dir1’ 的目录’</li></ul></li><li>mkdir dir1 dir2<ul><li>同时创建两个目录</li></ul></li><li>mkdir -p /tmp/dir1/dir2<ul><li>创建一个目录树</li></ul></li><li>rm -f file1<ul><li>删除一个叫做 ‘file1’ 的文件’</li></ul></li><li>rmdir dir1<ul><li>删除一个叫做 ‘dir1’ 的目录’</li></ul></li><li>rm -rf dir1<ul><li>删除一个叫做 ‘dir1’ 的目录并同时删除其内容</li></ul></li><li>rm -rf dir1 dir2<ul><li>同时删除两个目录及它们的内容</li></ul></li><li>mv dir1 new_dir<ul><li>重命名/移动 一个目录</li></ul></li><li>cp file1 file2<ul><li>复制一个文件</li></ul></li><li>cp dir/* .<ul><li>复制一个目录下的所有文件到当前工作目录</li></ul></li><li>cp -a /tmp/dir1 .<ul><li>复制一个目录到当前工作目录</li></ul></li><li>cp -a dir1 dir2 <ul><li>复制一个目录</li></ul></li><li>ln -s file1 lnk1 <ul><li>创建一个指向文件或目录的软链接</li></ul></li><li>ln file1 lnk1 <ul><li>创建一个指向文件或目录的物理链接</li></ul></li><li>touch -t 0712250000 file1 <ul><li>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</li></ul></li><li>file file1 outputs the mime type of the file as text</li><li>iconv -l <ul><li>列出已知的编码</li></ul></li><li>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</li><li>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</li></ul></blockquote><h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4. 文件搜索"></a>4. 文件搜索</h2><blockquote><ul><li>find / -name file1<ul><li>从 ‘/‘ 开始进入根文件系统搜索文件和目录</li></ul></li><li>find / -user user1<ul><li>搜索属于用户 ‘user1’ 的文件和目录</li></ul></li><li>find /home/user1 -name *.bin<ul><li>在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件</li></ul></li><li>find /usr/bin -type f -atime<ul><li>+100 搜索在过去100天内未被使用过的执行文件</li></ul></li><li>find /usr/bin -type f -mtime -10<ul><li>搜索在10天内被创建或者修改过的文件</li></ul></li><li>find / -name *.rpm -exec chmod 755 ‘{}’ ;<ul><li>搜索以 ‘.rpm’ 结尾的文件并定义其权限</li></ul></li><li>find / -xdev -name *.rpm<ul><li>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</li></ul></li><li>locate *.ps<ul><li>寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</li></ul></li><li>whereis halt<ul><li>显示一个二进制文件、源码或man的位置</li></ul></li><li>which halt<ul><li>显示一个二进制文件或可执行文件的完整路径</li></ul></li></ul></blockquote><h2 id="5-挂载一个文件系统"><a href="#5-挂载一个文件系统" class="headerlink" title="5. 挂载一个文件系统"></a>5. 挂载一个文件系统</h2><blockquote><ul><li>mount /dev/hda2 /mnt/hda2<ul><li>挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在</li></ul></li><li>umount /dev/hda2<ul><li>卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出</li></ul></li><li>fuser -km /mnt/hda2<ul><li>当设备繁忙时强制卸载</li></ul></li><li>umount -n /mnt/hda2<ul><li>运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</li></ul></li><li>mount /dev/fd0 /mnt/floppy<ul><li>挂载一个软盘</li></ul></li><li>mount /dev/cdrom /mnt/cdrom<ul><li>挂载一个cdrom或dvdrom</li></ul></li><li>mount /dev/hdc /mnt/cdrecorder<ul><li>挂载一个cdrw或dvdrom</li></ul></li><li>mount /dev/hdb /mnt/cdrecorder<ul><li>挂载一个cdrw或dvdrom</li></ul></li><li>mount -o loop file.iso /mnt/cdrom<ul><li>挂载一个文件或ISO镜像文件</li></ul></li><li>mount -t vfat /dev/hda5 /mnt/hda5<ul><li>挂载一个Windows FAT32文件系统</li></ul></li><li>mount /dev/sda1 /mnt/usbdisk<ul><li>挂载一个usb 捷盘或闪存设备</li></ul></li><li>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share<ul><li>挂载一个windows网络共享</li></ul></li></ul></blockquote><h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6. 磁盘空间"></a>6. 磁盘空间</h2><blockquote><ul><li>df -h <ul><li>显示已经挂载的分区列表</li></ul></li><li>ls -lSr |more <ul><li>以尺寸大小排列文件和目录</li></ul></li><li>du -sh dir1 <ul><li>估算目录 ‘dir1’ 已经使用的磁盘空间’</li></ul></li><li>du -sk * | sort -rn <ul><li>以容量大小为依据依次显示文件和目录的大小</li></ul></li><li>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n <ul><li>以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</li></ul></li><li>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n <ul><li>以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</li></ul></li></ul></blockquote><h2 id="7-用户和群组"><a href="#7-用户和群组" class="headerlink" title="7. 用户和群组"></a>7. 用户和群组</h2><blockquote><ul><li>groupadd group_name <ul><li>创建一个新用户组</li></ul></li><li>groupdel group_name <ul><li>删除一个用户组</li></ul></li><li>groupmod -n new_group_name old_group_name <ul><li>重命名一个用户组</li></ul></li><li>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” <ul><li>用户组的用户</li></ul></li><li>useradd user1 <ul><li>创建一个新用户</li></ul></li><li>userdel -r user1 <ul><li>删除一个用户 ( ‘-r’ 排除主目录)</li></ul></li><li>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 <ul><li>修改用户属性</li></ul></li><li>passwd <ul><li>修改口令</li></ul></li><li>passwd user1 <ul><li>修改一个用户的口令 (只允许root执行)</li></ul></li><li>chage -E 2005-12-31 user1 <ul><li>设置用户口令的失效期限</li></ul></li><li>pwck <ul><li>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户</li></ul></li><li>grpck <ul><li>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组</li></ul></li><li>newgrp group_name <ul><li>登陆进一个新的群组以改变新创建文件的预设群组</li></ul></li></ul></blockquote><h2 id="8-文件的权限-使用-“-”-设置权限，使用-“-”-用于取消"><a href="#8-文件的权限-使用-“-”-设置权限，使用-“-”-用于取消" class="headerlink" title="8. 文件的权限 使用 “+” 设置权限，使用 “-” 用于取消"></a>8. 文件的权限 使用 “+” 设置权限，使用 “-” 用于取消</h2><blockquote><ul><li>ls -lh <ul><li>显示权限</li></ul></li><li>ls /tmp | pr -T5 -W$COLUMNS <ul><li>将终端划分成5栏显示</li></ul></li><li>chmod ugo+rwx directory1 <ul><li>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</li></ul></li><li>chmod go-rwx directory1 <ul><li>删除群组(g)与其他人(o)对目录的读写执行权限</li></ul></li><li>chown user1 file1 <ul><li>改变一个文件的所有人属性</li></ul></li><li>chown -R user1 directory1 <ul><li>改变一个目录的所有人属性并同时改变改目录下所有文件的属性</li></ul></li><li>chgrp group1 file1 <ul><li>改变文件的群组</li></ul></li><li>chown user1:group1 file1 <ul><li>改变一个文件的所有人和群组属性</li></ul></li><li>find / -perm -u+s <ul><li>罗列一个系统中所有使用了SUID控制的文件</li></ul></li><li>chmod u+s /bin/file1 <ul><li>设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</li></ul></li><li>chmod u-s /bin/file1 <ul><li>禁用一个二进制文件的 SUID位</li></ul></li><li>chmod g+s /home/public <ul><li>设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</li></ul></li><li>chmod g-s /home/public <ul><li>禁用一个目录的 SGID 位</li></ul></li><li>chmod o+t /home/public <ul><li>设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</li></ul></li><li>chmod o-t /home/public <ul><li>禁用一个目录的 STIKY 位</li></ul></li><li>chmod +x <ul><li>文件路径 为所有者、所属组和其他用户添加执行的权限</li></ul></li><li>chmod -x <ul><li>文件路径 为所有者、所属组和其他用户删除执行的权限</li></ul></li><li>chmod u+x <ul><li>文件路径 为所有者添加执行的权限</li></ul></li><li>chmod g+x <ul><li>文件路径 为所属组添加执行的权限</li></ul></li><li>chmod o+x <ul><li>文件路径 为其他用户添加执行的权限</li></ul></li><li>chmod ug+x <ul><li>文件路径 为所有者、所属组添加执行的权限</li></ul></li><li>chmod =wx <ul><li>文件路径 为所有者、所属组和其他用户添加写、执行的权限，取消读权限</li></ul></li><li>chmod ug=wx <ul><li>文件路径 为所有者、所属组添加写、执行的权限，取消读权限</li></ul></li></ul></blockquote><h2 id="9-文件的特殊属性-，使用-“-”-设置权限，使用-“-”-用于取消"><a href="#9-文件的特殊属性-，使用-“-”-设置权限，使用-“-”-用于取消" class="headerlink" title="9. 文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消"></a>9. 文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消</h2><blockquote><ul><li>chattr +a file1 只允许以追加方式读写文件</li><li>chattr +c file1 允许这个文件能被内核自动压缩/解压</li><li>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件</li><li>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接</li><li>chattr +s file1 允许一个文件被安全地删除</li><li>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</li><li>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件</li><li>lsattr 显示特殊的属性</li></ul></blockquote><h2 id="10-打包和压缩文件"><a href="#10-打包和压缩文件" class="headerlink" title="10. 打包和压缩文件"></a>10. 打包和压缩文件</h2><blockquote><ul><li>bunzip2 file1.bz2<ul><li> 解压一个叫做 ‘file1.bz2’的文件</li></ul></li><li>bzip2 file1<ul><li> 压缩一个叫做 ‘file1’ 的文件</li></ul></li><li>gunzip file1.gz<ul><li> 解压一个叫做 ‘file1.gz’的文件</li></ul></li><li>gzip file1<ul><li> 压缩一个叫做 ‘file1’的文件</li></ul></li><li>gzip -9 file1<ul><li> 最大程度压缩</li></ul></li><li>rar a file1.rar test_file<ul><li> 创建一个叫做 ‘file1.rar’ 的包</li></ul></li><li>rar a file1.rar file1 file2 dir1<ul><li> 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</li></ul></li><li>rar x file1.rar<ul><li> 解压rar包</li></ul></li><li>unrar x file1.rar<ul><li> 解压rar包</li></ul></li><li>tar -cvf archive.tar file1<ul><li> 创建一个非压缩的 tarball</li></ul></li><li>tar -cvf archive.tar file1 file2 dir1<ul><li> 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</li></ul></li><li>tar -tf archive.tar<ul><li> 显示一个包中的内容</li></ul></li><li>tar -xvf archive.tar<ul><li> 释放一个包</li></ul></li><li>tar -xvf archive.tar -C /tmp<ul><li> 将压缩包释放到 /tmp目录下</li></ul></li><li>tar -cvfj archive.tar.bz2 dir1<ul><li> 创建一个bzip2格式的压缩包</li></ul></li><li>tar -xvfj archive.tar.bz2<ul><li> 解压一个bzip2格式的压缩包</li></ul></li><li>tar -cvfz archive.tar.gz dir1<ul><li> 创建一个gzip格式的压缩包</li></ul></li><li>tar -xvfz archive.tar.gz<ul><li> 解压一个gzip格式的压缩包</li></ul></li><li>zip file1.zip file1<ul><li> 创建一个zip格式的压缩包</li></ul></li><li>zip -r file1.zip file1 file2 dir1<ul><li> 将几个文件和目录同时压缩成一个zip格式的压缩包</li></ul></li><li>unzip file1.zip <ul><li>解压一个zip格式压缩包</li></ul></li></ul></blockquote><h2 id="11-RPM-包"><a href="#11-RPM-包" class="headerlink" title="11. RPM 包"></a>11. RPM 包</h2><blockquote><ul><li>rpm -ivh package.rpm<ul><li> 安装一个rpm包</li></ul></li><li>rpm -ivh –nodeeps package.rpm<ul><li> 安装一个rpm包而忽略依赖关系警告</li></ul></li><li>rpm -U package.rpm<ul><li> 更新一个rpm包但不改变其配置文件</li></ul></li><li>rpm -F package.rpm<ul><li> 更新一个确定已经安装的rpm包</li></ul></li><li>rpm -e package_name.rpm<ul><li> 删除一个rpm包</li></ul></li><li>rpm -qa <ul><li>显示系统中所有已经安装的rpm包</li></ul></li><li>rpm -qa | grep httpd<ul><li> 显示所有名称中包含 “httpd” 字样的rpm包</li></ul></li><li>rpm -qi package_name<ul><li> 获取一个已安装包的特殊信息</li></ul></li><li>rpm -qg “System Environment/Daemons”<ul><li> 显示一个组件的rpm包</li></ul></li><li>rpm -ql package_name<ul><li> 显示一个已经安装的rpm包提供的文件列表</li></ul></li><li>rpm -qc package_name<ul><li> 显示一个已经安装的rpm包提供的配置文件列表</li></ul></li><li>rpm -q package_name –whatrequires<ul><li> 显示与一个rpm包存在依赖关系的列表</li></ul></li><li>rpm -q package_name –whatprovides<ul><li> 显示一个rpm包所占的体积</li></ul></li><li>rpm -q package_name –scripts<ul><li> 显示在安装/删除期间所执行的脚本l</li></ul></li><li>rpm -q package_name –changelog<ul><li> 显示一个rpm包的修改历史</li></ul></li><li>rpm -qf /etc/httpd/conf/httpd.conf<ul><li> 确认所给的文件由哪个rpm包所提供</li></ul></li><li>rpm -qp package.rpm -l<ul><li> 显示由一个尚未安装的rpm包提供的文件列表</li></ul></li><li>rpm –import /media/cdrom/RPM-GPG-KEY<ul><li> 导入公钥数字证书</li></ul></li><li>rpm –checksig package.rpm<ul><li> 确认一个rpm包的完整性</li></ul></li><li>rpm -qa gpg-pubkey<ul><li> 确认已安装的所有rpm包的完整性</li></ul></li><li>rpm -V package_name<ul><li> 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</li></ul></li><li>rpm -Va<ul><li> 检查系统中所有已安装的rpm包- 小心使用</li></ul></li><li>rpm -Vp package.rpm<ul><li> 确认一个rpm包还未安装</li></ul></li><li>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em><ul><li> 从一个rpm包运行可执行文件</li></ul></li><li>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm<ul><li> 从一个rpm源码安装一个构建好的包</li></ul></li><li>rpmbuild –rebuild package_name.src.rpm<ul><li> 从一个rpm源码构建一个 rpm 包</li></ul></li></ul></blockquote><h2 id="12-YUM-软件包升级器"><a href="#12-YUM-软件包升级器" class="headerlink" title="12. YUM 软件包升级器"></a>12. YUM 软件包升级器</h2><blockquote><ul><li>yum install package_name<ul><li>下载并安装一个rpm包</li></ul></li><li>yum localinstall package_name.rpm <ul><li>将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</li></ul></li><li>yum update package_name.rpm<ul><li>更新当前系统中所有安装的rpm包</li></ul></li><li>yum update package_name<ul><li>更新一个rpm包</li></ul></li><li>yum remove package_name<ul><li>删除一个rpm包</li></ul></li><li>yum list<ul><li>列出当前系统中安装的所有包</li></ul></li><li>yum search package_name<ul><li>在rpm仓库中搜寻软件包</li></ul></li><li>yum clean packages<ul><li>清理rpm缓存删除下载的包</li></ul></li><li>yum clean headers<ul><li>删除所有头文件</li></ul></li><li>yum clean all<ul><li>删除所有缓存的包和头文件yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件</li></ul></li></ul></blockquote><h2 id="13-deb-包"><a href="#13-deb-包" class="headerlink" title="13. deb 包"></a>13. deb 包</h2><blockquote><ul><li>dpkg -i package.deb<ul><li>安装/更新一个 deb 包</li></ul></li><li>dpkg -r package_name<ul><li>从系统删除一个 deb 包</li></ul></li><li>dpkg -l <ul><li>显示系统中所有已经安装的 deb 包</li></ul></li><li>dpkg -l | grep httpd<ul><li>显示所有名称中包含 “httpd” 字样的deb包</li></ul></li><li>dpkg -s package_name<ul><li>获得已经安装在系统中一个特殊包的信息</li></ul></li><li>dpkg -L package_name<ul><li>显示系统中已经安装的一个deb包所提供的文件列表</li></ul></li><li>dpkg –contents package.deb<ul><li>显示尚未安装的一个包所提供的文件列表</li></ul></li><li>dpkg -S /bin/ping<ul><li>确认所给的文件由哪个deb包提供</li></ul></li><li>APT 软件工具 (Debian, Ubuntu 以及类似系统)</li><li>apt-get install package_name<ul><li>安装/更新一个 deb 包</li></ul></li><li>apt-cdrom install package_name<ul><li>从光盘安装/更新一个 deb 包</li></ul></li><li>apt-get update<ul><li>升级列表中的软件包</li></ul></li><li>apt-get upgrade<ul><li>升级所有已安装的软件</li></ul></li><li>apt-get remove package_name<ul><li>从系统删除一个deb包</li></ul></li><li>apt-get check<ul><li>确认依赖的软件仓库正确</li></ul></li><li>apt-get clean <ul><li>从下载的软件包中清理缓存</li></ul></li><li>apt-cache search searched-package <ul><li>返回包含所要搜索字符串的软件包名称</li></ul></li></ul></blockquote><h2 id="14-查看文件内容"><a href="#14-查看文件内容" class="headerlink" title="14. 查看文件内容"></a>14. 查看文件内容</h2><blockquote><ul><li>cat file1 <ul><li>从第一个字节开始正向查看文件的内容</li></ul></li><li>tac file1 <ul><li>从最后一行开始反向查看一个文件的内容</li></ul></li><li>more file1 <ul><li>查看一个长文件的内容</li></ul></li><li>less file1 <ul><li>类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</li></ul></li><li>head -2 file1 <ul><li>查看一个文件的前两行</li></ul></li><li>tail -2 file1 <ul><li>查看一个文件的最后两行</li></ul></li><li>tail -f /var/log/messages <ul><li>实时查看被添加到一个文件中的内容</li></ul></li></ul></blockquote><h2 id="15-文本处理"><a href="#15-文本处理" class="headerlink" title="15. 文本处理"></a>15. 文本处理</h2><blockquote><ul><li>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</li><li>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt <ul><li>合并一个文件的详细说明文本，并将简介写入一个新文件中</li></ul></li><li>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt <ul><li>合并一个文件的详细说明文本，并将简介写入一个已有的文件中</li></ul></li><li>grep Aug /var/log/messages <ul><li>在文件 ‘/var/log/messages’中查找关键词”Aug”</li></ul></li><li>grep ^Aug /var/log/messages <ul><li>在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇</li></ul></li><li>grep [0-9] /var/log/messages <ul><li>选择 ‘/var/log/messages’ 文件中所有包含数字的行</li></ul></li><li>grep Aug -R /var/log/* <ul><li>在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”</li></ul></li><li>sed ‘s/stringa1/stringa2/g’ example.txt <ul><li>将example.txt文件中的 “string1” 替换成 “string2”</li></ul></li><li>sed ‘/^$/d’ example.txt <ul><li>从example.txt文件中删除所有空白行</li></ul></li><li>sed ‘/ *#/d; /^$/d’ example.txt <ul><li>从example.txt文件中删除所有注释和空白行</li></ul></li><li>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ <ul><li>合并上下单元格内容</li></ul></li><li>sed -e ‘1d’ result.txt <ul><li>从文件example.txt 中排除第一行</li></ul></li><li>sed -n ‘/stringa1/p’ <ul><li>查看只包含词汇 “string1”的行</li></ul></li><li>sed -e ‘s/ *$//‘ example.txt <ul><li>删除每一行最后的空白字符</li></ul></li><li>sed -e ‘s/stringa1//g’ example.txt <ul><li>从文档中只删除词汇 “string1” 并保留剩余全部</li></ul></li><li>sed -n ‘1,5p;5q’ example.txt <ul><li>查看从第一行到第5行内容</li></ul></li><li>sed -n ‘5p;5q’ example.txt <ul><li>查看第5行</li></ul></li><li>sed -e ‘s/00*/0/g’ example.txt <ul><li>用单个零替换多个零</li></ul></li><li>cat -n file1 <ul><li>标示文件的行数</li></ul></li><li>cat example.txt | awk ‘NR%2==1’ <ul><li>删除example.txt文件中的所有偶数行</li></ul></li><li>echo a b c | awk ‘{print $1}’ <ul><li>查看一行第一栏</li></ul></li><li>echo a b c | awk ‘{print $1,$3}’ <ul><li>查看一行的第一和第三栏</li></ul></li><li>paste file1 file2 <ul><li>合并两个文件或两栏的内容</li></ul></li><li>paste -d ‘+’ file1 file2 <ul><li>合并两个文件或两栏的内容，中间用”+”区分</li></ul></li><li>sort file1 file2 <ul><li>排序两个文件的内容</li></ul></li><li>sort file1 file2 | uniq <ul><li>取出两个文件的并集(重复的行只保留一份)</li></ul></li><li>sort file1 file2 | uniq -u <ul><li>删除交集，留下其他的行</li></ul></li><li>sort file1 file2 | uniq -d <ul><li>取出两个文件的交集(只留下同时存在于两个文件中的文件)</li></ul></li><li>comm -1 file1 file2 <ul><li>比较两个文件的内容只删除 ‘file1’ 所包含的内容</li></ul></li><li>comm -2 file1 file2 <ul><li>比较两个文件的内容只删除 ‘file2’ 所包含的内容</li></ul></li><li>comm -3 file1 file2 <ul><li>比较两个文件的内容只删除两个文件共有的部分</li></ul></li></ul></blockquote><h2 id="16-字符设置和文件格式转换"><a href="#16-字符设置和文件格式转换" class="headerlink" title="16. 字符设置和文件格式转换"></a>16. 字符设置和文件格式转换</h2><blockquote><ul><li>dos2unix filedos.txt fileunix.txt <ul><li>将一个文本文件的格式从MSDOS转换成UNIX</li></ul></li><li>unix2dos fileunix.txt filedos.txt <ul><li>将一个文本文件的格式从UNIX转换成MSDOS</li></ul></li><li>recode ..HTML &lt; page.txt &gt; page.html <ul><li>将一个文本文件转换成html</li></ul></li><li>recode -l | more <ul><li>显示所有允许的转换格式</li></ul></li></ul></blockquote><h2 id="17-文件系统分析"><a href="#17-文件系统分析" class="headerlink" title="17. 文件系统分析"></a>17. 文件系统分析</h2><blockquote><ul><li>badblocks -v /dev/hda1 <ul><li>检查磁盘hda1上的坏磁块</li></ul></li><li>fsck /dev/hda1 <ul><li>修复/检查hda1磁盘上linux文件系统的完整性</li></ul></li><li>fsck.ext2 /dev/hda1 <ul><li>修复/检查hda1磁盘上ext2文件系统的完整性</li></ul></li><li>e2fsck /dev/hda1 <ul><li>修复/检查hda1磁盘上ext2文件系统的完整性</li></ul></li><li>e2fsck -j /dev/hda1 <ul><li>修复/检查hda1磁盘上ext3文件系统的完整性</li></ul></li><li>fsck.ext3 /dev/hda1 <ul><li>修复/检查hda1磁盘上ext3文件系统的完整性</li></ul></li><li>fsck.vfat /dev/hda1 <ul><li>修复/检查hda1磁盘上fat文件系统的完整性</li></ul></li><li>fsck.msdos /dev/hda1 <ul><li>修复/检查hda1磁盘上dos文件系统的完整性</li></ul></li><li>dosfsck /dev/hda1 <ul><li>修复/检查hda1磁盘上dos文件系统的完整性</li></ul></li></ul></blockquote><h2 id="18-初始化一个文件系统"><a href="#18-初始化一个文件系统" class="headerlink" title="18. 初始化一个文件系统"></a>18. 初始化一个文件系统</h2><blockquote><ul><li>mkfs /dev/hda1 <ul><li>在hda1分区创建一个文件系统</li></ul></li><li>mke2fs /dev/hda1 <ul><li>在hda1分区创建一个linux ext2的文件系统</li></ul></li><li>mke2fs -j /dev/hda1 <ul><li>在hda1分区创建一个linux ext3(日志型)的文件系统</li></ul></li><li>mkfs -t vfat 32 -F /dev/hda1 <ul><li>创建一个 FAT32 文件系统</li></ul></li><li>fdformat -n /dev/fd0 <ul><li>格式化一个软盘</li></ul></li><li>mkswap /dev/hda3 <ul><li>创建一个swap文件系统</li></ul></li></ul></blockquote><h2 id="19-SWAP-文件系统"><a href="#19-SWAP-文件系统" class="headerlink" title="19. SWAP 文件系统"></a>19. SWAP 文件系统</h2><blockquote><ul><li>mkswap /dev/hda3 <ul><li>创建一个swap文件系统</li></ul></li><li>swapon /dev/hda3 <ul><li>启用一个新的swap文件系统</li></ul></li><li>swapon /dev/hda2 /dev/hdb3 <ul><li>启用两个swap分区</li></ul></li></ul></blockquote><h2 id="20-备份"><a href="#20-备份" class="headerlink" title="20. 备份"></a>20. 备份</h2><blockquote><ul><li>dump -0aj -f /tmp/home0.bak /home <ul><li>制作一个 ‘/home’ 目录的完整备份</li></ul></li><li>dump -1aj -f /tmp/home0.bak /home <ul><li>制作一个 ‘/home’ 目录的交互式备份</li></ul></li><li>restore -if /tmp/home0.bak <ul><li>还原一个交互式备份</li></ul></li><li>rsync -rogpav –delete /home /tmp <ul><li>同步两边的目录</li></ul></li><li>rsync -rogpav -e ssh –delete /home ip_address:/tmp <ul><li>通过SSH通道rsync</li></ul></li><li>rsync -az -e ssh –delete ip_addr:/home/public /home/local <ul><li>通过ssh和压缩将一个远程目录同步到本地目录</li></ul></li><li>rsync -az -e ssh –delete /home/local ip_addr:/home/public <ul><li>通过ssh和压缩将本地目录同步到远程目录</li></ul></li><li>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ <ul><li>通过ssh在远程主机上执行一次备份本地磁盘的操作</li></ul></li><li>dd if=/dev/sda of=/tmp/file1 <ul><li>备份磁盘内容到一个文件</li></ul></li><li>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ <ul><li>目录的交互式备份操作</li></ul></li><li>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ <ul><li>通过ssh在远程目录中复制一个目录内容</li></ul></li><li>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ <ul><li>通过ssh在远程目录中复制一个本地目录</li></ul></li><li>tar cf - . | (cd /tmp/backup ; tar xf - ) <ul><li>本地将一个目录复制到另一个地方，保留原有权限及链接</li></ul></li><li>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents <ul><li>从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录</li></ul></li><li>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 <ul><li>查找所有以 ‘.log’ 结尾的文件并做成一个bzip包</li></ul></li><li>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 <ul><li>做一个将 MBR (Master Boot Record)内容复制到软盘的动作</li></ul></li><li>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 <ul><li>从已经保存到软盘的备份中恢复MBR内容</li></ul></li></ul></blockquote><h2 id="21-光盘"><a href="#21-光盘" class="headerlink" title="21. 光盘"></a>21. 光盘</h2><blockquote><ul><li>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force <ul><li>清空一个可复写的光盘内容</li></ul></li><li>mkisofs /dev/cdrom &gt; cd.iso <ul><li>在磁盘上创建一个光盘的iso镜像文件</li></ul></li><li>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz <ul><li>在磁盘上创建一个压缩了的光盘iso镜像文件</li></ul></li><li>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd <ul><li>创建一个目录的iso镜像文件</li></ul></li><li>cdrecord -v dev=/dev/cdrom cd.iso <ul><li>刻录一个ISO镜像文件</li></ul></li><li>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - <ul><li>刻录一个压缩了的ISO镜像文件</li></ul></li><li>mount -o loop cd.iso /mnt/iso <ul><li>挂载一个ISO镜像文件</li></ul></li><li>cd-paranoia -B <ul><li>从一个CD光盘转录音轨到 wav 文件中</li></ul></li><li>cd-paranoia – “-3” <ul><li>从一个CD光盘转录音轨到 wav 文件中（参数-3）</li></ul></li><li>cdrecord –scanbus <ul><li>扫描总线以识别scsi通道</li></ul></li><li>dd if=/dev/hdc | md5sum <ul><li>校验一个设备的md5sum编码，例如一张 CD</li></ul></li></ul></blockquote><h2 id="22-网络（以太网和-WIFI-无线）"><a href="#22-网络（以太网和-WIFI-无线）" class="headerlink" title="22. 网络（以太网和 WIFI 无线）"></a>22. 网络（以太网和 WIFI 无线）</h2><blockquote><ul><li>ifconfig eth0 <ul><li>显示一个以太网卡的配置</li></ul></li><li>ifup eth0 <ul><li>启用一个 ‘eth0’ 网络设备</li></ul></li><li>ifdown eth0 <ul><li>禁用一个 ‘eth0’ 网络设备</li></ul></li><li>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 <ul><li>控制IP地址</li></ul></li><li>ifconfig eth0 promisc <ul><li>设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)</li></ul></li><li>dhclient eth0 <ul><li>以dhcp模式启用 ‘eth0’</li></ul></li><li>route -n show routing table</li><li>route add -net 0/0 gw IP_Gateway configura default gateway</li><li>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’</li><li>route del 0/0 gw IP_gateway remove static route</li><li>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing</li><li>hostname show hostname of system</li><li>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(1)</li><li>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(2)</li><li>ip link show show link status of all interfaces</li><li>mii-tool eth0 show link status of ‘eth0’</li><li>ethtool eth0 show statistics of network card ‘eth0’</li><li>netstat -tup show all active network connections and their PID</li><li>netstat -tupl show all network services listening on the system and their PID</li><li>tcpdump tcp port 80 show all HTTP traffic</li><li>iwlist scan show wireless networks</li><li>iwconfig eth1 show configuration of a wireless network card</li><li>hostname show hostname</li><li>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</li><li>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</li><li>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database</li></ul></blockquote><h2 id="23-列出目录内容"><a href="#23-列出目录内容" class="headerlink" title="23. 列出目录内容"></a>23. 列出目录内容</h2><blockquote><ul><li>ls -a：显示所有文件（包括隐藏文件）；</li><li>ls -l：显示详细信息；</li><li>ls -R：递归显示子目录结构；</li><li>ls -ld：显示目录和链接信息；</li><li>ctrl+r：历史记录中所搜命令（输入命令中的任意一个字符）；</li><li>Linux中以.开头的文件是隐藏文件；</li><li>pwd:显示当前目录</li></ul></blockquote><h2 id="24-查看文件的类型"><a href="#24-查看文件的类型" class="headerlink" title="24. 查看文件的类型"></a>24. 查看文件的类型</h2><ul><li><blockquote><p>file:查看文件的类型</p></blockquote></li></ul><h2 id="25-复制文件目录"><a href="#25-复制文件目录" class="headerlink" title="25. 复制文件目录"></a>25. 复制文件目录</h2><p>1、<strong>cp</strong>：复制文件和目录 cp 源文件（文件夹）目标文件（文件夹）</p><blockquote><ul><li><p>常用参数：</p></li><li><p>-r:递归复制整个目录树；</p></li><li><p>-v：显示详细信息；</p></li><li><p>复制文件夹时要在 cp 命令后面加一个-r 参数：</p><p>如：cp -r 源文件夹 目标文件夹</p></li></ul></blockquote><p>2、<strong>touch+文件名</strong>：当文件不存在的时候，创建相应的文件；当文件存在的时候，修改文件的创建时间。</p><blockquote><ul><li><p>功能：生成一个空文件或修改文件的存取/修改的时间记录值。</p></li><li><p>touch *：将当前下的文件时间修改为系统的当前时间</p></li><li><p>touch –d 20040210 test：将 test 文件的日期改为 20040210</p></li><li><p>touch abc：若 abc 文件存在，则修改为系统的当前时间；若不存在，则生成一个为当前时间的空文件</p></li></ul></blockquote><p>3、<strong>mv 文件 目标目录</strong>：移动或重命名文件或目录（如果指定文件名，则可以重命名文件）。可以将文件及目录移到另一目录下，或更改文件及目录的名称。</p><blockquote><ul><li><p>格式为：mv [参数]&lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p></li><li><p>mva.txt ../：将 a.txt 文件移动上层目录</p></li><li><p>mv a.txt b.txt：将 a.txt 改名为 b.txt</p></li><li><p>mvdir2 ../：将 dir2 目录上移一层</p></li></ul></blockquote><p>4、<strong>rm</strong>：删除文件；</p><blockquote><p>常用参数：</p><ul><li>-i：交互式 </li><li>-r：递归的删除包括目录中的所有内容</li></ul></blockquote><p>5、<strong>mkdir +文件夹名称</strong>：创建文件夹；</p><p>6、<strong>rm -r +文件夹名称</strong>：删除文件夹（空文件夹和非空文件夹都可删除）</p><blockquote><ul><li>rmdir 文件夹名称：删除文件夹（只能删除空文件夹）</li></ul></blockquote><p>7、<strong>mkdir -p dir1/dir2</strong>：在当前目录下创建 dir1 目录，并在 dir1 目录下创建 dir2 目录， 也就是连续创建两个目录（dir1/和 dir1/dir2）</p><p>8、<strong>rmdir –p dir1/dir2</strong>：删除 dir1 下的 dir2 目录，若 dir1 目录为空也删除它</p><p>9、**rm ***：删除当前目录下的所有文件</p><p>10、**-f 参数**：强迫删除文件 rm –f *.txt：强迫删除所有以后缀名为 txt 文件</p><p>11、**-i 参数**：删除文件时询问</p><blockquote><ul><li><p>rm 　–i * ：删除当前目录下的所有文件会有如下提示：</p></li><li><p>rm:backup:is a directory  遇到目录会略过</p></li><li><p>rm: remove ‘myfiles.txt’ ? Y</p></li><li><p>删除文件时会询问,可按 Y 或 N 键表示允许或拒绝删除文件</p></li></ul></blockquote><p>12、**-r 参数**：递归删除（连子目录一同删除，这是一个相当常用的参数）</p><blockquote><ul><li><p>rm -r test ：删除 test 目录（含 test 目录下所有文件和子目录）</p></li><li><p>rm -r *：删除所有文件（含当前目录所有文件、所有子目录和子目录下的文件） </p></li><li><p>一般在删除目录时 r 和 f 一起用，避免麻烦</p></li><li><p>rm -rf test ：强行删除、不加询问</p></li></ul></blockquote><p>13、<strong>grep</strong>：功能：在文件中搜索匹配的字符并进行输出</p><blockquote><ul><li><p>格式：grep[参数] &lt;要找的字串&gt; &lt;要寻找字 串的源文件&gt;</p></li><li><p>greplinux test.txt：搜索 test.txt 文件中字符串 linux 并输出</p></li></ul></blockquote><p>14、<strong>ln 命令</strong></p><blockquote><ul><li><p>功能：在文件和目录之间建立链接</p></li><li><p>格式：ln [参数] &lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p></li><li><p>链接分“软链接”和“硬链接”</p></li><li><p>1.软链接:</p></li><li><p>ln–s /usr/share/do doc ：创建一个链接文件 doc,并指向目录/usr/share/do</p></li><li><p>2.硬链接:</p></li><li><p>ln /usr/share/test hard：创建一个硬链接文件 hard，这时对于 test 文件对应 的存储区域来说，又多了一个文件指向它</p></li></ul></blockquote><h2 id="26-系统常用命令"><a href="#26-系统常用命令" class="headerlink" title="26. 系统常用命令"></a>26. 系统常用命令</h2><h3 id="26-1、显示命令"><a href="#26-1、显示命令" class="headerlink" title="26.1、显示命令"></a>26.1、显示命令</h3><blockquote><ul><li><p>date:查看或设置当前系统的时间：格式化显示时间：+%Y–%m–%d；</p></li><li><p>date -s:设置当前系统的时间</p></li><li><p>hwclock(clock)：显示硬件时钟时间(需要管理员权限)；</p></li><li><p>cal：查看日历 格式 cal [参数] 月年</p></li><li><p>cal：显示当月的日历 cal7 2023：显示 2023 年 7 月的日历</p></li><li><p>cal- y 2023：显示 2023年的日历</p></li><li><p>uptime：查看系统运行时间</p></li></ul></blockquote><h3 id="26-2、输出查看命令"><a href="#26-2、输出查看命令" class="headerlink" title="26.2、输出查看命令"></a>26.2、输出查看命令</h3><blockquote><ul><li><p>echo：显示输入的内容 追加文件 echo “文件名” &gt;&gt; 文件名.txt</p></li><li><p>cat：显示文件内容,也可以将数个文件合并成一个文件。格式：格式：cat[参数]&lt;文件名&gt;</p></li><li><p>cat test.txt：显示 test.txt 文件内容</p></li><li><p>cat test.txt | more ：逐页显示 test.txt 文件中的内容</p></li><li><p>cat test.txt &gt;&gt; test1.txt ：将 test.txt 的内容附加到 test1.txt 文件之后</p></li><li><p>cat test.txt test2.txt &gt;readme.txt 　: 将 test.txt 和 test2.txt 文件合并成 readme.txt 文件</p></li><li><p>head:显示文件的头几行（默认 10 行） -n:指定显示的行数格式：head -n 文件名</p></li><li><p>tail：显示文件的末尾几行（默认 10 行）-n：指定显示的行数 -f：追踪显示文件更新 （一般用于查看日志，命令不会退出，而是持续显示新加入的内容）格式：格式：tail[参数]&lt;文件名&gt;</p></li><li><p>tail-10 /etc/passwd ：显示/etc/passwd/文件的倒数 10 行内容</p></li><li><p>tail+10 /etc/passwd ：显示/etc/passwd/文件从第 10 行开始到末尾的内容</p></li><li><p>more：用于翻页显示文件内容（只能向下翻页）</p></li><li><p>more 命令是一般用于要显示的内容会超过一个画面长度的情况。为了避免画 面显示时瞬间就闪过去，用户可以使用 more 命令，让画面在显示满一页时暂停，此时可按空格键继续显示下一个画面，或按 Q 键停止显示。</p></li><li><p>ls -al |more：以长格形式显示 etc 目录下的文件列表，显示满一个画面便暂停，可 按空格键继续显示下一画面，或按 Q 键跳离</p></li><li><p>less：翻页显示文件内容（带上下翻页）按下上键分页，按 q 退出、‘</p></li><li><p>less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同 的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 Q 键即可。</p></li><li><p>ls -al | less：以长格形式列出/etc 目录中所有的内容。用户可按上下键浏览或按 Q 键跳离</p></li></ul></blockquote><h3 id="26-3、查看硬件信息"><a href="#26-3、查看硬件信息" class="headerlink" title="26.3、查看硬件信息"></a>26.3、查看硬件信息</h3><blockquote><ul><li><p>Ispci：查看 PCI 设备 -v：查看详细信息</p></li><li><p>Isusb：查看 USB 设备 -v：查看详细信息</p></li><li><p>Ismod：查看加载的模块(驱动)</p></li></ul></blockquote><h3 id="26-4、关机、重启"><a href="#26-4、关机、重启" class="headerlink" title="26.4、关机、重启"></a>26.4、关机、重启</h3><blockquote><ul><li><p>shutdown 关闭、重启计算机</p></li><li><p>shutdown[关机、重启]时间 -h 关闭计算机 -r：重启计算机</p><ul><li>如：<ul><li>立即关机：shutdown -h now</li><li>10 分钟后关机：shutdown -h +10</li><li>23:30 分关机：shutdown -h 23:30</li><li>立即重启：shutdown -r now</li></ul></li></ul></li><li><p>poweroff：立即关闭计算机</p></li><li><p>reboot：立即重启计算机</p></li></ul></blockquote><h3 id="26-5、归档、压缩"><a href="#26-5、归档、压缩" class="headerlink" title="26.5、归档、压缩"></a>26.5、归档、压缩</h3><blockquote><ul><li><p>zip:压缩文件 zip liuyazhuang.zip myfile 格式为：“zip 压缩后的 zip 文件文件名”</p></li><li><p>unzip：解压文件 unzip liuyazhuang.zip</p></li><li><p>gzip：压缩文件 gzip 文件名</p></li><li><p>tar：归档文件</p></li><li><p>tar -cvf out.tar liuyazhuang 打包一个归档（将文件”liuyazhuang”打包成一个归档）</p></li><li><p>tar -xvf liuyazhuang.tar 释放一个归档（释放 liuyazhuang.tar 归档）</p></li><li><p>tar -cvzf backup.tar.gz/etc</p></li><li><p>-z 参数将归档后的归档文件进行 gzip 压缩以减少大小。</p></li><li><p>-c：创建一个新 tar 文件</p></li><li><p>-v：显示运行过程的信息</p></li><li><p>-f：指定文件名</p></li><li><p>-z：调用 gzip 压缩命令进行压缩</p></li><li><p>-t：查看压缩文件的内容</p></li><li><p>-x：解开 tar 文件</p></li><li><p>tar -cvf test.tar *：将所有文件打包成 test.tar,扩展名.tar 需自行加上</p></li><li><p>tar -zcvf test.tar.gz *：将所有文件打包成 test.tar,再用 gzip 命令压缩</p></li><li><p>tar -tf test.tar ：查看 test.tar 文件中包括了哪些文件</p></li><li><p>tar -xvf test.tar 将 test.tar 解开</p></li><li><p>tar -zxvf foo.tar.gz 解压缩</p></li><li><p>gzip 各 gunzip 命令</p></li><li><p>gziptest.txt ：压缩文件时，不需要任何参数</p></li><li><p>gizp–l test.txt.gz：显示压缩率</p></li></ul></blockquote><h3 id="26-6、查找"><a href="#26-6、查找" class="headerlink" title="26.6、查找"></a>26.6、查找</h3><blockquote><ul><li><p>locate：快速查找文件、文件夹：locate keyword</p></li><li><p>此命令需要预先建立数据库，数据库默认每天更新一次，可用 updatedb 命令手工建立、更新数据库。</p></li><li><p>find 查找位置查找参数</p><ul><li>如：<ul><li>find . -name<em>XXX</em>查找当前目录下名称中含有”XXX”的文件</li><li>find / -name *.conf 查找根目录下（整个硬盘）下后缀为.conf 的文件</li><li>find / -perm 777 查找所有权限是 777 的文件</li><li>find / -type d 返回根目录下所有的目录</li><li>find . -name “a*”-exec ls -l {} ;</li><li>find 功能：用来寻找文件或目录。</li><li>格式：find [&lt;路径&gt;][匹配条件]</li><li>find / -name httpd.conf 搜索系统根目录下名为 httpd.conf 的文件</li></ul></li></ul></li></ul></blockquote><h3 id="26-7、ctrl-c-终止当前的命令"><a href="#26-7、ctrl-c-终止当前的命令" class="headerlink" title="26.7、ctrl+c :终止当前的命令"></a>26.7、ctrl+c :终止当前的命令</h3><h3 id="26-8、who-或-w-命令"><a href="#26-8、who-或-w-命令" class="headerlink" title="26.8、who 或 w 命令"></a>26.8、who 或 w 命令</h3><blockquote><ul><li><p>功能：查看当前系统中有哪些用户登录</p></li><li><p>格式：who/w[参数]</p></li></ul></blockquote><h3 id="26-9、dmesg-命令"><a href="#26-9、dmesg-命令" class="headerlink" title="26.9、dmesg 命令"></a>26.9、dmesg 命令</h3><ul><li><blockquote><p>功能：显示系统诊断信息、操作系统版本号、物理内存的大小以及其它信息</p></blockquote></li></ul><h3 id="26-10、df-命令"><a href="#26-10、df-命令" class="headerlink" title="26.10、df 命令"></a>26.10、df 命令</h3><ul><li><blockquote><p>功能：用于查看文件系统的各个分区的占用情况</p></blockquote></li></ul><h3 id="26-11、du-命令"><a href="#26-11、du-命令" class="headerlink" title="26.11、du 命令"></a>26.11、du 命令</h3><blockquote><ul><li><p>功能：查看某个目录中各级子目录所使用的硬盘空间数</p></li><li><p>格式：du [参数] &lt;目录名&gt;</p></li></ul></blockquote><h3 id="26-12、free-命令"><a href="#26-12、free-命令" class="headerlink" title="26.12、free 命令"></a>26.12、free 命令</h3><ul><li><blockquote><p>功能：用于查看系统内存，虚拟内存（交换空间）的大小占用情况</p></blockquote></li></ul><h2 id="27-VIM"><a href="#27-VIM" class="headerlink" title="27. VIM"></a>27. VIM</h2><p>VIM 是一款功能强大的命令行文本编辑器，在 Linux 中通过 vim 命令可以启动 vim 编辑器。</p><p>一般使用 vim + 目标文件路径 的形式使用 vim</p><p>如果目标文件存在，则 vim 打开目标文件，如果目标文件不存在，则 vim 新建并打开该文件</p><p>:q：退出 vim 编辑器</p><p><strong>VIM 模式</strong></p><p>vim 拥有三种模式：</p><p><strong>（1）命令模式（常规模式）</strong></p><p>vim 启动后，默认进入命令模式，任何模式都可以通过 esc 键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。</p><p>命名模式常用命令如下：</p><blockquote><ul><li><p>i : 在光标前插入文本</p></li><li><p>o:在当前行的下面插入新行</p></li><li><p>dd:删除整行</p></li><li><p>yy：将当前行的内容放入缓冲区（复制当前行）</p></li><li><p>n+yy :将 n 行的内容放入缓冲区（复制 n 行）</p></li><li><p>p:将缓冲区中的文本放入光标后（粘贴）</p></li><li><p>u：撤销上一个操作</p></li><li><p>r:替换当前字符</p></li><li><p>/ 查找关键字</p></li></ul></blockquote><p><strong>（2）插入模式</strong></p><p>在命令模式下按 “ i “键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用 esc 键可以返回命令模式。</p><p><strong>（3）ex 模式</strong></p><p>在命令模式中按” : “键可以进入 ex 模式，光标会移动到底部，在这里可以保存修改或退出 vim.</p><p>ext 模式常用命令如下：</p><blockquote><ul><li><p>:w ：保存当前的修改</p></li><li><p>:q ：退出</p></li><li><p>:q! ：强制退出，保存修改</p></li><li><p>:x :保存并退出，相当于:wq</p></li><li><p>:set number 显示行号</p></li><li><p>:! 系统命令 执行一个系统命令并显示结果</p></li><li><p>:sh ：切换到命令行，使用 ctrl+d 切换回 vim</p></li></ul></blockquote><h2 id="28-软件包管理命令-RPM"><a href="#28-软件包管理命令-RPM" class="headerlink" title="28. 软件包管理命令(RPM)"></a>28. 软件包管理命令(RPM)</h2><h3 id="28-1、软件包的安装"><a href="#28-1、软件包的安装" class="headerlink" title="28.1、软件包的安装"></a>28.1、软件包的安装</h3><p>使用 RPM 命令的安装模式可以将软件包内所有的组件放到系统中的正确路径</p><p>命令:</p><blockquote><ul><li>rpm –ivh xxx-2.6.2-8.i386.rpm</li><li>i：作用 rpm 的安装模式 </li><li>v: 校验文件信息 </li><li>h: 以＃号显示安装进度</li></ul></blockquote><h3 id="28-2、软件包的删除"><a href="#28-2、软件包的删除" class="headerlink" title="28.2、软件包的删除"></a>28.2、软件包的删除</h3><p>删除模式会将指定软件包的内容全部删除，但并不包括已更改过的配置文件，删除 RPM 软件包</p><p>命令：</p><ul><li><blockquote><p>rpm –e xxx</p></blockquote></li></ul><p>注意：</p><ul><li><blockquote><p>这里必须使用软件名“xxx”或”xxx-2.6.2-8 而不是使用当初安装时的软件包名.xxx-2.6.2-8.i386.rpm</p></blockquote></li></ul><h3 id="28-3、软件包升级"><a href="#28-3、软件包升级" class="headerlink" title="28.3、软件包升级"></a>28.3、软件包升级</h3><p>升级模式会安装用户所指定的更新版本，并删除已安装在系统中的相同软件包，升级软件包</p><p>命令：</p><ul><li><blockquote><p>rpm –Uvh xxx-2.6.2-8.i386.rpm –Uvh：升级参数</p></blockquote></li></ul><h3 id="28-4、软件包更新"><a href="#28-4、软件包更新" class="headerlink" title="28.4、软件包更新"></a>28.4、软件包更新</h3><p>更新模式下，rpm 命令会检查在命令行中所指定的软件包是否比系统中原有的软件 包更新。如果情况属实，rpm 命令会自动更新指定的软件包；反之，若系统中并没有指定软件包的较旧版本，rpm 命令并不会安装此软件包。而在升级模式下，不管系统中是否有较旧的版本，rpm 命令都会安装指定的软件包。</p><ul><li><blockquote><p>rpm –Fvhxxx-2.6.2-8.i386.rpm -Fvh：更新参数</p></blockquote></li></ul><h3 id="28-5、软件包查询"><a href="#28-5、软件包查询" class="headerlink" title="28.5、软件包查询"></a>28.5、软件包查询</h3><p>若要获取 RPM 软件包的相关信息，可以使用查询模式。</p><blockquote><ul><li>使用-q 参数可查询一个已安装的软件包的内容<ul><li>rpm –q xxx</li></ul></li><li>查询软件包所安装的位置<ul><li>rpm –ql package-name</li><li>rpm –ql xv (l 参数：显示文件列表)</li></ul></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存溢出-String</title>
    <link href="/2023/06/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-String/"/>
    <url>/2023/06/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-String/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内存溢出-String"><a href="#内存溢出-String" class="headerlink" title="内存溢出-String"></a>内存溢出-String</h1><h3 id="JDK1-6方法举例："><a href="#JDK1-6方法举例：" class="headerlink" title="JDK1.6方法举例："></a>JDK1.6方法举例：</h3><p>String.substring(int beginIndex, int endIndex);源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a string that is a substring of this string. The</span><br><span class="hljs-comment">     * substring begins at the specified &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; and</span><br><span class="hljs-comment">     * extends to the character at index &#123;<span class="hljs-doctag">@code</span> endIndex - 1&#125;.</span><br><span class="hljs-comment">     * Thus the length of the substring is &#123;<span class="hljs-doctag">@code</span> endIndex-beginIndex&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Examples:</span><br><span class="hljs-comment">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment">     * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment">     * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment">     * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      beginIndex   the beginning index, inclusive.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      endIndex     the ending index, exclusive.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>     the specified substring.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  IndexOutOfBoundsException  if the</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is negative, or</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125; is larger than the length of</span><br><span class="hljs-comment">     *             this &#123;<span class="hljs-doctag">@code</span> String&#125; object, or</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is larger than</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> bedinIndex, <span class="hljs-type">int</span> endIndex)</span>&#123;<br>    <span class="hljs-keyword">if</span>(beginIndex &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(endIndex &gt; count)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(beginIndex &gt; endIndex)&#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex - beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(offset + beginIndex, endIndex - beginIndex, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>由源码分析可看出，substring方法在使用时，会构造一个新的String对象，问题所在也在此。</p><p>JDK1.6 String构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String(<span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count, <span class="hljs-type">char</span>[] value)&#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>    <span class="hljs-built_in">this</span>.offset = offset;<br>    <span class="hljs-built_in">this</span>.count = count;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.6中，String类的构造函数创建时非简单拷贝对象，而是将整个value引用。问题导致较大字符串就算不再被引用，内存也不会释放。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456789&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.substring(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">return</span> b;<br></code></pre></td></tr></table></figure><p>此处，字符串a只是临时的，而真正所用到的字符串b的内存数组，其实是从字符串a中共享所得。虽然字符串a本身可被回收，但其内存数据却不可释放，导致内存泄露。</p><h3 id="JDK1-8源码分析"><a href="#JDK1-8源码分析" class="headerlink" title="JDK1.8源码分析"></a>JDK1.8源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a string that is a substring of this string. The</span><br><span class="hljs-comment"> * substring begins at the specified &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; and</span><br><span class="hljs-comment"> * extends to the character at index &#123;<span class="hljs-doctag">@code</span> endIndex - 1&#125;.</span><br><span class="hljs-comment"> * Thus the length of the substring is &#123;<span class="hljs-doctag">@code</span> endIndex-beginIndex&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Examples:</span><br><span class="hljs-comment"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment"> * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment"> * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      beginIndex   the beginning index, inclusive.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      endIndex     the ending index, exclusive.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>     the specified substring.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@exception</span>  IndexOutOfBoundsException  if the</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is negative, or</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125; is larger than the length of</span><br><span class="hljs-comment"> *             this &#123;<span class="hljs-doctag">@code</span> String&#125; object, or</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is larger than</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-built_in">this</span><br>            : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.8 String构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allocates a new &#123;<span class="hljs-doctag">@code</span> String&#125; that contains characters from a subarray</span><br><span class="hljs-comment"> * of the character array argument. The &#123;<span class="hljs-doctag">@code</span> offset&#125; argument is the</span><br><span class="hljs-comment"> * index of the first character of the subarray and the &#123;<span class="hljs-doctag">@code</span> count&#125;</span><br><span class="hljs-comment"> * argument specifies the length of the subarray. The contents of the</span><br><span class="hljs-comment"> * subarray are copied; subsequent modification of the character array does</span><br><span class="hljs-comment"> * not affect the newly created string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  value</span><br><span class="hljs-comment"> *         Array that is the source of characters</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  offset</span><br><span class="hljs-comment"> *         The initial offset</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  count</span><br><span class="hljs-comment"> *         The length</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IndexOutOfBoundsException</span><br><span class="hljs-comment"> *          If the &#123;<span class="hljs-doctag">@code</span> offset&#125; and &#123;<span class="hljs-doctag">@code</span> count&#125; arguments index</span><br><span class="hljs-comment"> *          characters outside the bounds of the &#123;<span class="hljs-doctag">@code</span> value&#125; array</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span> value[], <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset + count);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在JDK1.8中，当我们需要一个子字符串的时候，substring 生成了一个新的字符串，这个字符串通过构造函数的 Arrays.copyOfRange 函数进行构造。此优化在JDK1.7时就已实现，新的实现虽然损失了性能，而且浪费了一些存储空间，但却保证了字符串的内部数组可以和字符串对象一起被回收，从而防止发生内存泄漏。</p><p><img src="%5Cimg%5Cavatar.png"></p>]]></content>
    
    
    <categories>
      
      <category>&lt;JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存溢出 JVM调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream流操作</title>
    <link href="/2023/06/10/JAVA%20Stream%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/10/JAVA%20Stream%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JAVA-Stream流操作"><a href="#JAVA-Stream流操作" class="headerlink" title="JAVA Stream流操作"></a>JAVA Stream流操作</h1><ul><li><p>Stream流操作分为<strong>3种类型</strong>：</p><ul><li><p>创建Stream</p></li><li><p>Stream中间处理</p></li><li><p>终止Steam</p></li></ul></li></ul><h3 id="Stream特性"><a href="#Stream特性" class="headerlink" title="Stream特性"></a>Stream特性</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1.stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。<br>2.stream不会改变数据源，通常情况下会产生一个新的集合或一个值。<br>3.stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。<br></code></pre></td></tr></table></figure><h3 id="Stream特点"><a href="#Stream特点" class="headerlink" title="Stream特点"></a>Stream特点</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.</span>代码简洁：函数编程写出的代码简洁且意图明确，使用stream接口让你从此告别<span class="hljs-keyword">for</span>循环。<br><span class="hljs-number">2.</span>多核友好：Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下方法。<br><span class="hljs-number">3.</span><span class="hljs-built_in">Stream</span>不存储数据。<br><span class="hljs-number">4.</span><span class="hljs-built_in">Stream</span>不会改变源对象。相反，他们会返回一个持有结果的新<span class="hljs-built_in">Stream</span>。<br><span class="hljs-number">5.</span><span class="hljs-built_in">Stream</span>是惰性求值的（延迟执行）<br></code></pre></td></tr></table></figure><h3 id="Stream创建"><a href="#Stream创建" class="headerlink" title="Stream创建"></a>Stream创建</h3><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1.创建 Stream一个数据源（如： 集合、数组）， 获取一个流。<br>2.中间操作一个中间操作链，对数据源的数据进行处理。<br>3.终止操作(终端操作)一个终止操作，执行中间操作链，并产生结果 。<br></code></pre></td></tr></table></figure><h4 id="创建示例"><a href="#创建示例" class="headerlink" title="创建示例"></a>创建示例</h4><ul><li>通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//获取一个顺序流</span><br>Stream&lt;String&gt; stream = list.stream();<br><span class="hljs-comment">//获取一个并行流</span><br>Stream&lt;String&gt; parallelStream = list.parallelStream();<br></code></pre></td></tr></table></figure><ul><li>使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br></code></pre></td></tr></table></figure><ul><li>使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>stream.forEach(System.out::println);<br>Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">3</span>).limit(<span class="hljs-number">4</span>);<br>stream2.forEach(System.out::println);<br>Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="hljs-number">3</span>);<br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h4 id="开始管道"><a href="#开始管道" class="headerlink" title="开始管道"></a>开始管道</h4><ul><li>主要负责新建一个Stream流，或者基于现有的数组、List、Set、Map等集合类型对象创建出新的Stream流。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>stream()</td><td>创建出一个新的stream串行流对象</td></tr><tr><td>parallelStream()</td><td>创建出一个可并行执行的stream流对象</td></tr><tr><td>Stream.of()</td><td>通过给定的一系列元素创建一个新的Stream串行流对象</td></tr></tbody></table><h4 id="中间管道"><a href="#中间管道" class="headerlink" title="中间管道"></a>中间管道</h4><ul><li>负责对Stream进行处理操作，并返回一个新的Stream对象，中间管道操作可以进行<strong>叠加</strong>。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>filter()</td><td>按照条件过滤符合要求的元素， 返回新的stream流</td></tr><tr><td>map()</td><td>将已有元素转换为另一个对象类型，一对一逻辑，返回新的stream流</td></tr><tr><td>flatMap()</td><td>将已有元素转换为另一个对象类型，一对多逻辑，即原来一个元素对象可能会转换为1个或者多个新类型的元素，返回新的stream流</td></tr><tr><td>limit()</td><td>仅保留集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>skip()</td><td>跳过集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>concat()</td><td>将两个流的数据合并起来为1个新的流，返回新的stream流</td></tr><tr><td>distinct()</td><td>对Stream中所有元素进行去重，返回新的stream流</td></tr><tr><td>sorted()</td><td>对stream中所有的元素按照指定规则进行排序，返回新的stream流</td></tr><tr><td>peek()</td><td>对stream流中的每个元素进行逐个遍历处理，返回处理后的stream流</td></tr></tbody></table><h4 id="终止管道"><a href="#终止管道" class="headerlink" title="终止管道"></a>终止管道</h4><ul><li>顾名思义，通过终止管道操作之后，Stream流将<strong>会结束</strong>，最后可能会执行某些逻辑处理，或者是按照要求返回某些执行后的结果数据。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>count()</td><td>返回stream处理后最终的元素个数</td></tr><tr><td>max()</td><td>返回stream处理后的元素最大值</td></tr><tr><td>min()</td><td>返回stream处理后的元素最小值</td></tr><tr><td>findFirst()</td><td>找到第一个符合条件的元素时则终止流处理</td></tr><tr><td>findAny()</td><td>找到任何一个符合条件的元素时则退出流处理，这个<strong>对于串行流时与findFirst相同，对于并行流时比较高效</strong>，任何分片中找到都会终止后续计算逻辑</td></tr><tr><td>anyMatch()</td><td>返回一个boolean值，类似于isContains(),用于判断是否有符合条件的元素</td></tr><tr><td>allMatch()</td><td>返回一个boolean值，用于判断是否所有元素都符合条件</td></tr><tr><td>noneMatch()</td><td>返回一个boolean值， 用于判断是否所有元素都不符合条件</td></tr><tr><td>collect()</td><td>将流转换为指定的类型，通过Collectors进行指定</td></tr><tr><td>toArray()</td><td>将流转换为数组</td></tr><tr><td>iterator()</td><td>将流转换为Iterator对象</td></tr><tr><td>foreach()</td><td>无返回值，对元素进行逐个遍历，然后执行给定的处理逻辑</td></tr></tbody></table><h2 id="Stream方法使用"><a href="#Stream方法使用" class="headerlink" title="Stream方法使用"></a>Stream方法使用</h2><h4 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h4><ul><li><p>map与flatMap都是用于转换已有的元素为其它元素，区别点在于：</p><ul><li><p>map <strong>必须是一对一的</strong>，即每个元素都只能转换为1个新的元素</p></li><li><p>flatMap <strong>可以是一对多的</strong>，即每个元素都可以转换为1个或者多个新的元素</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringToIntMap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;105&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;469&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>    <span class="hljs-comment">// 使用流操作</span><br>    List&lt;User&gt; results = ids.stream()<br>            .map(id -&gt; &#123;<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                user.setId(id);<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;)<br>            .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>[User&#123;id=<span class="hljs-string">&#x27;205&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;105&#x27;</span>&#125;,<br> User&#123;id=<span class="hljs-string">&#x27;308&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;469&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;627&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;193&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;111&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringToIntFlatmap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; sentences = Arrays.asList(<span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-string">&quot;coco&quot;</span>);<br>    <span class="hljs-comment">// 使用流操作</span><br>    List&lt;String&gt; results = sentences.stream()<br>            .flatMap(sentence -&gt; Arrays.stream(sentence.split(<span class="hljs-string">&quot; &quot;</span>)))<br>            .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>[hello, world, coco]<br></code></pre></td></tr></table></figure><ul><li>flatMap操作的时候是先将每个元素处理并返回一个新的Stream，然后将多个Stream展开合并为了一个完整的新的Stream。</li></ul><h4 id="peek和foreach"><a href="#peek和foreach" class="headerlink" title="peek和foreach"></a>peek和foreach</h4><ul><li><p>对元素进行遍历然后逐个的进行处理。</p></li><li><p>peek属于中间方法，只能作为管道中途的一个处理步骤，而没法直接执行得到结果，其后面必须还要有其它终止操作的时候才会被执行；</p></li><li><p>foreach属于终止方法，可以直接执行相关操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPeekAndforeach</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; sentences = Arrays.asList(<span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-string">&quot;coco&quot;</span>);<br>    <span class="hljs-comment">// 演示点1：仅peek操作，最终不会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before peek----&quot;</span>);<br>    sentences.stream().peek(sentence -&gt; System.out.println(sentence));<br>    System.out.println(<span class="hljs-string">&quot;----after peek----&quot;</span>);<br>    <span class="hljs-comment">// 演示点2：仅foreach操作，最终会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before foreach----&quot;</span>);<br>    sentences.stream().forEach(sentence -&gt; System.out.println(sentence));<br>    System.out.println(<span class="hljs-string">&quot;----after foreach----&quot;</span>);<br>    <span class="hljs-comment">// 演示点3：peek操作后面增加终止操作，peek会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before peek and count----&quot;</span>);<br>    sentences.stream().peek(sentence -&gt; System.out.println(sentence)).count();<br>    System.out.println(<span class="hljs-string">&quot;----after peek and count----&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>----before peek----<br>----after peek----<br>----before foreach----<br>hello world<br>coco<br>----after foreach----<br>----before peek and count----<br>hello world<br>coco<br>----after peek and count----<br></code></pre></td></tr></table></figure><h4 id="filter、sorted、distinct、limit"><a href="#filter、sorted、distinct、limit" class="headerlink" title="filter、sorted、distinct、limit"></a>filter、sorted、distinct、limit</h4><ul><li>都是常用的Stream的中间操作方法,可以根据需要选择一个或者多个进行组合使用，或者同时使用多个相同方法的组合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetTargetUsers</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Dept&gt; ids = Arrays.asList(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;99&quot;</span>,<span class="hljs-string">&quot;999&quot;</span>,<span class="hljs-string">&quot;9999&quot;</span>,<span class="hljs-string">&quot;99999&quot;</span>)<br>        .stream()<br>        <span class="hljs-comment">// 使用filter过滤掉不符合条件的数据</span><br>        .filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-comment">// 通过distinct对存量元素进行去重操作</span><br>        .distinct()<br>        <span class="hljs-comment">// 通过map操作将字符串转成整数类型</span><br>        .map(Integer::valueOf)<br>        <span class="hljs-comment">// 指定按照数字大小正序排列</span><br>        .sorted(Comparator.comparingInt(o -&gt; o))<br>        <span class="hljs-comment">// 使用limit截取排在前3位的元素</span><br>        .limit(<span class="hljs-number">3</span>)<br>        <span class="hljs-comment">// 使用map将id转为Dept对象类型</span><br>        .map(id -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(id))<br>        <span class="hljs-comment">// 使用collect终止操作将最终处理后的数据收集到list中</span><br>        .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="简单结果终止方法"><a href="#简单结果终止方法" class="headerlink" title="简单结果终止方法"></a>简单结果终止方法</h4><ul><li>count、max、min、findAny、findFirst、anyMatch、allMatch、nonneMatch,结果形式是数字、布尔值或者Optional对象值等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleStopOptions</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>);<br>    <span class="hljs-comment">// 统计stream操作后剩余的元素个数</span><br>    System.out.println(ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>).count());<br>    <span class="hljs-comment">// 判断是否有元素值等于205</span><br>    System.out.println(ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>).anyMatch(<span class="hljs-string">&quot;205&quot;</span>::equals));<br>    <span class="hljs-comment">// findFirst操作</span><br>    ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>            .findFirst()<br>            .ifPresent(s -&gt; System.out.println(<span class="hljs-string">&quot;findFirst:&quot;</span> + s));<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">6</span><br><span class="hljs-literal">true</span><br>findFirst:<span class="hljs-number">205</span><br></code></pre></td></tr></table></figure><p><strong>一旦被执行了终止操作之后，后续便不可以再读这个流执行其他的操作</strong></p><h4 id="结果收集终止方法"><a href="#结果收集终止方法" class="headerlink" title="结果收集终止方法"></a>结果收集终止方法</h4><ul><li><p>结果数据：</p><ul><li>一个集合类，比如List、Set或者HashMap等;</li><li>StringBuilder对象，支持将多个字符串进行拼接处理并输出拼接后结果;</li><li>一个可以记录个数或者计算总和的对象（数据批量运算统计）。</li></ul></li></ul><h5 id="◆生成集合"><a href="#◆生成集合" class="headerlink" title="◆生成集合"></a>◆生成集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCollectStopOptions</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Dept&gt; ids = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">17</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">22</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">23</span>));<br>    <span class="hljs-comment">// collect成list</span><br>    List&lt;Dept&gt; collectList = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toList());<br>    System.out.println(<span class="hljs-string">&quot;collectList:&quot;</span> + collectList);<br>    <span class="hljs-comment">// collect成Set</span><br>    Set&lt;Dept&gt; collectSet = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toSet());<br>    System.out.println(<span class="hljs-string">&quot;collectSet:&quot;</span> + collectSet);<br>    <span class="hljs-comment">// collect成HashMap，key为id，value为Dept对象</span><br>    Map&lt;Integer, Dept&gt; collectMap = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));<br>    System.out.println(<span class="hljs-string">&quot;collectMap:&quot;</span> + collectMap);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="◆生成拼接字符串"><a href="#◆生成拼接字符串" class="headerlink" title="◆生成拼接字符串"></a>◆生成拼接字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCollectJoinStrings</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinResult</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;拼接后：&quot;</span> + joinResult);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="◆数据批量数学运算"><a href="#◆数据批量数学运算" class="headerlink" title="◆数据批量数学运算"></a>◆数据批量数学运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNumberCalculate</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; ids = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>);<br>    <span class="hljs-comment">// 计算平均值</span><br>    <span class="hljs-type">Double</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.averagingInt(value -&gt; value));<br>    System.out.println(<span class="hljs-string">&quot;平均值：&quot;</span> + average);<br>    <span class="hljs-comment">// 数据统计信息</span><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">summary</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.summarizingInt(value -&gt; value));<br>    System.out.println(<span class="hljs-string">&quot;数据统计信息：&quot;</span> + summary);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并行Stream"><a href="#并行Stream" class="headerlink" title="并行Stream"></a>并行Stream</h4><h5 id="◆Stream-API代替for循环"><a href="#◆Stream-API代替for循环" class="headerlink" title="◆Stream API代替for循环"></a>◆Stream API代替for循环</h5><ul><li>省略</li></ul><h5 id="◆将数组转换为管道流"><a href="#◆将数组转换为管道流" class="headerlink" title="◆将数组转换为管道流"></a>◆将数组转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>Stream&lt;String&gt; nameStrs2 = Stream.of(array);<br>Stream&lt;String&gt; nameStrs3 = Stream.of(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="◆将集合类对象转换为管道流"><a href="#◆将集合类对象转换为管道流" class="headerlink" title="◆将集合类对象转换为管道流"></a>◆将集合类对象转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;&quot;</span>);<br>Stream&lt;String&gt; streamFromList = list.stream();<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(list);<br>Stream&lt;String&gt; streamFromSet = set.stream();<br></code></pre></td></tr></table></figure><h5 id="◆将文本文件转换为管道流"><a href="#◆将文本文件转换为管道流" class="headerlink" title="◆将文本文件转换为管道流"></a>◆将文本文件转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="hljs-string">&quot;file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="◆filter与谓语逻辑"><a href="#◆filter与谓语逻辑" class="headerlink" title="◆filter与谓语逻辑"></a>◆filter与谓语逻辑</h5><ul><li>Predicate接口</li></ul><h5 id="◆and语法（并集）"><a href="#◆and语法（并集）" class="headerlink" title="◆and语法（并集）"></a>◆and语法（并集）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.and(Employee.genderM))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆or语法（交集）"><a href="#◆or语法（交集）" class="headerlink" title="◆or语法（交集）"></a>◆or语法（交集）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.or(Employee.genderM))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆negate语法（取反）"><a href="#◆negate语法（取反）" class="headerlink" title="◆negate语法（取反）"></a>◆negate语法（取反）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.or(Employee.genderM).negate())<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="Stream管道流的map操作"><a href="#Stream管道流的map操作" class="headerlink" title="Stream管道流的map操作"></a>Stream管道流的map操作</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 全部转换成大写</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Coco&quot;</span>, <span class="hljs-string">&quot;Liming&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-string">&quot;lisa&quot;</span>);<br>List&lt;String&gt; collect = list.stream().map(String::toUpperCase).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="处理非字符串类型集合元素"><a href="#处理非字符串类型集合元素" class="headerlink" title="处理非字符串类型集合元素"></a>处理非字符串类型集合元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; lengths = alpha.stream()<br>        .map(String::length)<br>        .collect(Collectors.toList());<br><span class="hljs-comment">// [6, 4, 7, 5]</span><br>Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .mapToInt(String::length);<br><span class="hljs-number">6</span><br><span class="hljs-number">4</span><br><span class="hljs-number">7</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="处理对象数据格式转换"><a href="#处理对象数据格式转换" class="headerlink" title="处理对象数据格式转换"></a>处理对象数据格式转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将每一个Employee的年龄增加一岁</span><br><span class="hljs-comment">// 将性别中的“M”换成“male”，F换成Female</span><br> List&lt;Employee&gt; maped = list.stream()<br>            .peek(e -&gt; &#123;<br>                e.setAge(e.getAge() + <span class="hljs-number">1</span>);<br>                e.setGender(e.getGender().equals(<span class="hljs-string">&quot;M&quot;</span>)?<span class="hljs-string">&quot;male&quot;</span>:<span class="hljs-string">&quot;female&quot;</span>);<br>            &#125;).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;word&quot;</span>);<br><span class="hljs-comment">// map处理</span><br>words.stream()<br>        .map(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)));<br><span class="hljs-comment">// 输出</span><br>[[h,e,l,l,o],[w,o,r,l,d]]<br><span class="hljs-comment">// flatMap处理</span><br>words.stream()<br>        .flatMap(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)));<br><span class="hljs-comment">// 输出</span><br>[h,e,l,l,o,w,o,r,l,d]<br></code></pre></td></tr></table></figure><h3 id="状态与并行操作"><a href="#状态与并行操作" class="headerlink" title="状态与并行操作"></a>状态与并行操作</h3><h4 id="中间操作：有状态与无状态"><a href="#中间操作：有状态与无状态" class="headerlink" title="中间操作：有状态与无状态"></a>中间操作：有状态与无状态</h4><ul><li><p>filter与map操作，不需要管道流的前面后面元素相关，所以不需要额外的记录元素之间的关系。输入一个元素，获得一个结果。</p></li><li><p>sorted是排序操作、distinct是去重操作。像这种操作都是和别的元素相关的操作，我自己无法完成整体操作。就像班级点名就是无状态的，喊到你你就答到就可以了。如果是班级同学按大小个排序，那就不是你自己的事了，你得和周围的同学比一下身高并记住，你记住的这个身高比较结果就是一种“状态”。所以这种操作就是有状态操作。</p><h5 id="◆Limit与Skip管道数据截取"><a href="#◆Limit与Skip管道数据截取" class="headerlink" title="◆Limit与Skip管道数据截取"></a>◆Limit与Skip管道数据截取</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; limitN = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .limit(<span class="hljs-number">2</span>)<br>        .collect(Collectors.toList());<br>List&lt;String&gt; skipN = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .skip(<span class="hljs-number">2</span>)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li><p>limt方法传入一个整数n，用于截取管道中的前n个元素。经过管道处理之后的数据是：[Monkey, Lion]。</p></li><li><p>skip方法与limit方法的使用相反，用于跳过前n个元素，截取从n到末尾的元素。经过管道处理之后的数据是：[Giraffe, Lemur]。</p><h5 id="◆Distinct元素去重"><a href="#◆Distinct元素去重" class="headerlink" title="◆Distinct元素去重"></a>◆Distinct元素去重</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; uniqueAnimals = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>)<br>    .distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆Sorted排序"><a href="#◆Sorted排序" class="headerlink" title="◆Sorted排序"></a>◆Sorted排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; alphabeticOrder = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .sorted()<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆串行、并行与顺序"><a href="#◆串行、并行与顺序" class="headerlink" title="◆串行、并行与顺序"></a>◆串行、并行与顺序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>)<br>    .parallel()<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure><ul><li>parallel()函数表示对管道中的元素进行并行处理,元素的顺序无法保证。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparator接口</span><br>list.stream().sorted(Comparator.naturalOrder());<br><span class="hljs-comment">// Comparator.naturalOrder()-&gt;自然排序</span><br><span class="hljs-comment">// Comparator.reverseOrder()-&gt;倒序排序</span><br></code></pre></td></tr></table></figure><ul><li>对象字段排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(Comparator.comparing(User::getAge));<br><span class="hljs-comment">// 倒序</span><br>users.sort(Comparator.comparing(User::getAge).reversed());<br></code></pre></td></tr></table></figure><ul><li>Comparator链对List排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(<br>        Comparator.comparing(User::getGender)<br>        .thenComparing(User::getAge)<br>        .reversed()<br>);<br><span class="hljs-comment">// 都是正序 ，不加reversed</span><br><span class="hljs-comment">// 都是倒序，最后面加一个reserved</span><br><span class="hljs-comment">// 先是倒序（加reserved），然后正序</span><br><span class="hljs-comment">// 先是正序（加reserved），然后倒序（加reserved）</span><br></code></pre></td></tr></table></figure><h3 id="函数式接口Comparator"><a href="#函数式接口Comparator" class="headerlink" title="函数式接口Comparator"></a>函数式接口Comparator</h3><h4 id="只能有一个抽象方法的接口"><a href="#只能有一个抽象方法的接口" class="headerlink" title="只能有一个抽象方法的接口"></a><strong>只能有一个抽象方法的接口</strong></h4><h5 id="◆函数式接口的特点"><a href="#◆函数式接口的特点" class="headerlink" title="◆函数式接口的特点"></a>◆函数式接口的特点</h5><ul><li>接口有且仅有一个抽象方法；</li><li>允许定义静态非抽象方法；</li><li>允许定义默认defalut非抽象方法（default方法也是java8才有的，见下文）；</li><li>允许java.lang.Object中的public方法，如：equals方法；</li><li>FunctionInterface注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错,见源码查看。</li><li><strong>lambda表达式是只实现接口中唯一的抽象方法的匿名实现类</strong>。</li></ul><h5 id="◆default关键字"><a href="#◆default关键字" class="headerlink" title="◆default关键字"></a>◆default关键字</h5><ul><li><p>java8之前</p><ul><li>接口是不能有方法的实现，所有方法全都是抽象方法</li><li>实现接口就必须实现接口里面的所有方法</li><li>问题：<strong>当一个接口有很多的实现类的时候,修改这个接口就变成了一个非常麻烦的事,需要修改这个接口的所有实现类</strong>。</li></ul></li><li><p>java8引入default方法</p><ul><li><p>default方法可以有自己的默认实现，即有方法体。</p></li><li><p>接口实现类可以不去实现default方法，并且可以使用default方法。</p></li></ul></li></ul><h5 id="◆JDK中的函数式接口举例"><a href="#◆JDK中的函数式接口举例" class="headerlink" title="◆JDK中的函数式接口举例"></a>◆JDK中的函数式接口举例</h5><ul><li><p>java.lang.Runnable,</p></li><li><p>java.util.Comparator,</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.util.function包下的接口，如Consumer、Predicate、Supplier等</p></li></ul><h5 id="◆自定义Comparator排序"><a href="#◆自定义Comparator排序" class="headerlink" title="◆自定义Comparator排序"></a>◆自定义Comparator排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User u1, User u2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(u1.getAge() == u2.getAge())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge() &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// lambda</span><br>users.sort((u1,u2) -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(u1.getAge() == u2.getAge())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge() &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="查找与匹配元素"><a href="#查找与匹配元素" class="headerlink" title="查找与匹配元素"></a>查找与匹配元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// anyMatch 一个符合就可以</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan70</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(Employee.ageGreaterThan70);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan72</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">72</span>);<br><span class="hljs-comment">// allMatch 全部符合</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan10</span> <span class="hljs-operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">10</span>);<br><span class="hljs-comment">// noneMatch 全部不符合</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeLess18</span> <span class="hljs-operator">=</span> employees.stream().noneMatch(e -&gt; e.getAge() &lt; <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h4 id="元素查找与Optional"><a href="#元素查找与Optional" class="headerlink" title="元素查找与Optional"></a>元素查找与Optional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查找第一个年龄大于40的员工</span><br>Optional&lt;Employee&gt; employeeOptional = employees.stream()<br>    .filter(e -&gt; e.getAge() &gt; <span class="hljs-number">40</span>).findFirst();<br></code></pre></td></tr></table></figure><ul><li>Optional类代表一个值存在或者不存在</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">isPresent() 将在 Optional 包含值的时候返回 true,否则返回 false;<br>ifPresent(Consumer block) 会在值存在的时候执行给定的代码块;<br>T get() 会在值存在时返回值，否则?出一个 NoSuchElement 异常;<br>T orElse(T other) 会在值存在时返回值,否则返回一个默认值;<br>findFirst用于查找第一个符合“匹配规则”的元素，返回值为Optional;<br>findAny用于查找任意一个符合“匹配规则”的元素，返回值为Optional。<br></code></pre></td></tr></table></figure><h3 id="元素归约"><a href="#元素归约" class="headerlink" title="元素归约"></a>元素归约</h3><ul><li><p>Stream.reduce用来实现集合元素的归约，reduce函数有三个参数：</p><ul><li>Identity标识：一个元素，它是归约操作的初始值，如果流为空，则为默认结果。</li><li>Accumulator累加器：具有两个参数的函数：归约运算的部分结果和流的下一个元素。</li><li>Combiner合并器（可选）：当归约并行化时，或当累加器参数的类型与累加器实现的类型不匹配时，用于合并归约操作的部分结果的函数。累加器：阶段累加结果作为累加器的第一个参数；集合遍历元素作为累加器的第二个参数。</li><li>reduce初始值为0，累加器可以是lambda表达式，也可以是方法引用。</li></ul></li></ul><h4 id="Integer类型归约"><a href="#Integer类型归约" class="headerlink" title="Integer类型归约"></a>Integer类型归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers<br>        .stream()<br>        .reduce(<span class="hljs-number">0</span>, (subtotal, element) -&gt; subtotal + element);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers<br>        .stream()<br>        .reduce(<span class="hljs-number">0</span>, Integer::sum);<br><span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h4 id="String类型归约"><a href="#String类型归约" class="headerlink" title="String类型归约"></a>String类型归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; letters = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> letters<br>        .stream()<br>        .reduce(<span class="hljs-string">&quot;&quot;</span>, (partialString, element) -&gt; partialString + element);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> letters<br>        .stream()<br>        .reduce(<span class="hljs-string">&quot;&quot;</span>, String::concat);<br><span class="hljs-comment">// abcde</span><br></code></pre></td></tr></table></figure><h4 id="复杂对象归约"><a href="#复杂对象归约" class="headerlink" title="复杂对象归约"></a>复杂对象归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算所有的员工的年龄总和。</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees.stream().map(Employee::getAge).reduce(<span class="hljs-number">0</span>,Integer::sum);<br></code></pre></td></tr></table></figure><h4 id="Combiner合并器的使用"><a href="#Combiner合并器的使用" class="headerlink" title="Combiner合并器的使用"></a>Combiner合并器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees.stream()<br>        .reduce(<span class="hljs-number">0</span>,(totalAge,emp) -&gt; totalAge + emp.getAge(),Integer::sum); <br><span class="hljs-comment">// 并行</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees<br>        .parallelStream()<br>        .map(Employee::getAge)<br>        .reduce(<span class="hljs-number">0</span>,Integer::sum,Integer::sum);<br></code></pre></td></tr></table></figure><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收集为Set，Set会去重</span><br>Set&lt;String&gt; collectToSet = Stream.of(...).collect(Collectors.toSet());<br><span class="hljs-comment">// 收集为List</span><br>List&lt;String&gt; collectToList = Stream.of(...).collect(Collectors.toList());<br><span class="hljs-comment">// 通用的收集</span><br>LinkedList&lt;String&gt; collectToCollection = Stream.of(...)<br>    .collect(Collectors.toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br><span class="hljs-comment">// 收集到Array</span><br>String[] toArray = Stream.of(...).toArray(String[]::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">// 收集到Map</span><br>Map&lt;String, Integer&gt; toMap = Stream.of(...)<br>.distinct()<br>.collect(Collectors.toMap(<br>       Function.identity(),   <span class="hljs-comment">// key</span><br>       s -&gt; (<span class="hljs-type">int</span>) s.chars().distinct().count()<span class="hljs-comment">// value</span><br>));<br><span class="hljs-comment">// 分组收集groupingBy</span><br>Map&lt;Character, List&lt;String&gt;&gt; groupingByList = Stream.of(...)<br>.collect(Collectors.groupingBy(<br>       s -&gt; 条件, 收集器<br>));<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断管道中是否包含2，结果是: true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">containsTwo</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).anyMatch(i -&gt; i == <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 管道中元素数据总计结果nrOfAnimals: 4</span><br><span class="hljs-type">long</span> <span class="hljs-variable">nrOfAnimals</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>).count();<br><br><span class="hljs-comment">// 管道中元素数据累加结果sum: 6</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br><br><span class="hljs-comment">// 管道中元素数据平均值average: OptionalDouble[2.0]</span><br><span class="hljs-type">OptionalDouble</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).average();<br><br><span class="hljs-comment">// 管道中元素数据最大值max: 3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).max().orElse(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 全面统计的结果statistics: IntSummaryStatistics&#123;count=3, sum=6, min=1, average=2.000000, max=3&#125;</span><br><span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).summaryStatistics();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;流</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2023/05/27/mybatis/"/>
    <url>/2023/05/27/mybatis/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="用来循环容器的标签forEach-查看例子"><a href="#用来循环容器的标签forEach-查看例子" class="headerlink" title="用来循环容器的标签forEach,查看例子"></a><strong>用来循环容器的标签forEach,查看例子</strong></h3><ul><li><p>foreach元素的属性主要有item，index，collection，open，separator，close。</p><ul><li><p>item：集合中元素迭代时的别名，</p></li><li><p>index：集合中元素迭代时的索引</p></li><li><p>open：常用语where语句中，表示以什么开始，比如以’(‘开始</p></li><li><p>separator：表示在每次进行迭代时的分隔符，</p></li><li><p>close 常用语where语句中，表示以什么结束，</p></li></ul></li></ul><ul><li><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p><ul><li><p>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</p></li><li><p>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</p></li><li><p>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</p></li></ul></li></ul><ul><li><p>针对最后一条，我们来看一下官方说法：</p></li><li><blockquote><p>注意 你可以将一个 List 实例或者数组作为参数对象传给 MyBatis，当你这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。</p></blockquote><p>所以，不管是多参数还是单参数的list,array类型，都可以封装为map进行传递。如果传递的是一个List，则mybatis会封装为一个list为key，list值为object的map，如果是array，则封装成一个array为key，array的值为object的map，如果自己封装呢，则colloection里放的是自己封装的map里的key值</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">//mapper中我们要为这个方法传递的是一个容器,将容器中的元素一个一个的//拼接到xml的方法中就要使用这个forEach这个标签了public List<span class="hljs-tag">&lt;<span class="hljs-name">Entity</span>&gt;</span> queryById(List<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> userids);<br>    //对应的xml中如下<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseReslutMap&quot;</span> &gt;</span><br>    select * FROM entity<br>    where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;userids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;userid&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;userid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="concat模糊查询"><a href="#concat模糊查询" class="headerlink" title="concat模糊查询"></a><strong>concat模糊查询</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">//比如说我们想要进行条件查询,但是几个条件不是每次都要使用,那么我们就可以//通过判断是否拼接到sql中       <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BascResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;entity&quot;</span>&gt;</span><br>    SELECT * from entity<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span><br>                name like concat(&#x27;%&#x27;,concat(#&#123;name&#125;,&#x27;%&#x27;))<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="choose-when-otherwise-标签"><a href="#choose-when-otherwise-标签" class="headerlink" title="choose (when, otherwise)标签"></a><strong>choose (when, otherwise)标签</strong></h3><p>choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。</p><p>例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_user&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.yiibai.pojo.User&quot;</span>&gt;</span><br>      SELECT *<br>        FROM User u<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username !=null &quot;</span>&gt;</span><br>                    u.username LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;username, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex != &#x27;&#x27; &quot;</span>&gt;</span><br>                    AND u.sex = #&#123;sex, jdbcType=INTEGER&#125;<br>                &lt;/when &gt;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null &quot;</span>&gt;</span><br>                    AND u.age = #&#123;age, jdbcType=INTEGER&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>          <br>                <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>          <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>      <br>         <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="selectKey-标签"><a href="#selectKey-标签" class="headerlink" title="selectKey 标签"></a><strong>selectKey 标签</strong></h3><p>在insert语句中，在Oracle经常使用序列、在MySQL中使用函数来自动生成插入表的主键，而且需要方法能返回这个生成主键。使用myBatis的selectKey标签可以实现这个效果。</p><p>下面例子，使用mysql数据库自定义函数nextval(‘student’)，用来生成一个key，并把他设置到传入的实体类中的studentId属性上。所以在执行完此方法后，边可以通过这个实体类获取生成的key。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 插入学生 自动主键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;createStudentAutoKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;liming.student.manager.data.model.StudentEntity&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;studentId&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;studentId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        select nextval(&#x27;student&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span>&gt;</span><br>    INSERT INTO<br>M_STUDENT(STUDENT_ID,STUDENT_SEX,STUDENT_BIRTHDAY,STUDENT_PHOTO,CLASS_ID,PLACE_ID)   VALUES (#&#123;studentId&#125;,#&#123;studentName&#125;,#&#123;studentSex&#125;,#&#123;studentBirthday&#125;,#&#123;studentPhoto,javaType=byte[],jdbcType=BLOB,typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,#&#123;classId&#125;,#&#123;placeId&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用接口方法，和获取自动生成key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>entity.setStudentName(<span class="hljs-string">&quot;黎明你好&quot;</span>);<br>entity.setStudentSex(<span class="hljs-number">1</span>);<br>entity.setStudentBirthday(DateUtil.parse(<span class="hljs-string">&quot;1985-05-28&quot;</span>));<br>entity.setClassId(<span class="hljs-string">&quot;20000001&quot;</span>);<br>entity.setPlaceId(<span class="hljs-string">&quot;70000001&quot;</span>);<br><span class="hljs-built_in">this</span>.dynamicSqlMapper.createStudentAutoKey(entity);<br>System.out.println(<span class="hljs-string">&quot;新增学生ID: &quot;</span> + entity.getStudentId());<br></code></pre></td></tr></table></figure><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a><strong>if标签</strong></h3><p>if标签可用在许多类型的sql语句中，我们以查询为例。首先看一个很普通的查询：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 查询学生list，like姓名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListLikeName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;StudentEntity&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>    SELECT * from M_STUDENT ms<br>    WHERE ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName&#125;),&#x27;%&#x27;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>但是此时如果studentName为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。</p><p>参数为实体类StudentEntity。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2 if(判断参数) - 将实体类不为空的属性作为where条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;liming.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID, ms.STUDENT_NAME, ms.STUDENT_SEX, ms.STUDENT_BIRTHDAY,      ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID <br>    FROM M_STUDENT ms<br>    WHERE<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>        ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>        AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>        AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span>      <br>        AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用时比较灵活， new一个这样的实体类，我们需要限制那个条件，只需要附上相应的值就会where这个条件，相反不去赋值就可以不在where中判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>    entity.setStudentName(<span class="hljs-string">&quot;&quot;</span>);<br>    entity.setStudentSex(<span class="hljs-number">1</span>);<br>    entity.setStudentBirthday(DateUtil.parse(<span class="hljs-string">&quot;2023-05-28&quot;</span>));                 <br>    entity.setClassId(<span class="hljs-string">&quot;20000001&quot;</span>);<br> entity.setPlaceId(<span class="hljs-string">&quot;70000001&quot;</span>);<br> List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentList(entity);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>     System.out.println(e.toString());<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-where-的条件判断"><a href="#if-where-的条件判断" class="headerlink" title="if + where 的条件判断"></a><strong>if + where 的条件判断</strong></h3><p>当where中的条件使用的if标签较多时，这样的组合可能会导致错误。我们以在3.1中的查询语句为例子，当java代码按如下方法调用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>    entity.setStudentName(<span class="hljs-literal">null</span>);<br>    entity.setStudentSex(<span class="hljs-number">1</span>);<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentList(entity);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上面例子，参数studentName为null，将不会进行STUDENT_NAME列的判断，则会直接导“WHERE AND”关键字多余的错误SQL。</p><p>这时我们可以使用where动态语句来解决。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><p>上面例子修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 3 select - where/if(判断参数) - 将实体类不为空的属性作为where条件 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,    ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>            ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="if-set实现修改语句"><a href="#if-set实现修改语句" class="headerlink" title="if + set实现修改语句"></a><strong>if + set实现修改语句</strong></h3><p>当update语句中没有使用if标签时，如果有一个参数为null，都会导致错误。</p><p>当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。使用if+set标签修改后，如果某项为null则不进行更新，而是保持数据库原值。</p><p>如下示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 4 if/set(判断参数) - 将实体类不为空的属性更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    UPDATE M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName != null and studentName != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_NAME = #&#123;studentName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_SEX = #&#123;studentSex&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            ms.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentPhoto != null &quot;</span>&gt;</span><br>            ms.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.CLASS_ID = #&#123;classId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.PLACE_ID = #&#123;placeId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    WHERE ms.STUDENT_ID = #&#123;studentId&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="if-trim代替where-set标签"><a href="#if-trim代替where-set标签" class="headerlink" title="if + trim代替where/set标签"></a><strong>if + trim代替where/set标签</strong></h3><p>trim是更灵活的去处多余关键字的标签，他可以实践where和set的效果。</p><h4 id="trim代替where"><a href="#trim代替where" class="headerlink" title="trim代替where"></a><strong>trim代替where</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.1 if/trim代替where(判断参数) -将实体类不为空的属性作为where条件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,       ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND|OR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>            ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="trim代替set"><a href="#trim代替set" class="headerlink" title="trim代替set"></a><strong>trim代替set</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.2 if/trim代替set(判断参数) - 将实体类不为空的属性更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    UPDATE M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName != null and studentName != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_NAME = #&#123;studentName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_SEX = #&#123;studentSex&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>        ms.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentPhoto != null &quot;</span>&gt;</span><br>            ms.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.CLASS_ID = #&#123;classId&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.PLACE_ID = #&#123;placeId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    WHERE ms.STUDENT_ID = #&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h3><p>对于动态SQL 非常必须的，主是要迭代一个集合，通常是用于IN 条件。List 实例将使用“list”做为键，数组实例以“array” 做为键。</p><p>foreach元素是非常强大的，它允许你指定一个集合，声明集合项和索引变量，它们可以用在元素体内。它也允许你指定开放和关闭的字符串，在迭代之间放置分隔符。这个元素是很智能的，它不会偶然地附加多余的分隔符。</p><blockquote><p>注意：你可以传递一个List实例或者数组作为参数对象传给MyBatis。当你这么做的时候，MyBatis会自动将它包装在一个Map中，用名称在作为键。List实例将会以“list”作为键，而数组实例将会以“array”作为键。</p></blockquote><p>这个部分是对关于XML配置文件和XML映射文件的而讨论的。下一部分将详细讨论Java API，所以你可以得到你已经创建的最有效的映射。</p><h4 id="参数为array示例的写法"><a href="#参数为array示例的写法" class="headerlink" title="参数为array示例的写法"></a><strong>参数为array示例的写法</strong></h4><p>接口的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title function_">getStudentListByClassIds_foreach_array</span><span class="hljs-params">(String[] classIds)</span>;<br></code></pre></td></tr></table></figure><p>动态SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 7.1 foreach(循环array参数) - 作为where中in的条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListByClassIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,     ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    WHERE ms.CLASS_ID IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;classIds&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;classIds&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码，查询学生中，在20000001、20000002这两个班级的学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>    String[] classIds = &#123; <span class="hljs-string">&quot;20000001&quot;</span>, <span class="hljs-string">&quot;20000002&quot;</span> &#125;;<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentListByClassIds(classIds);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数为list示例的写法"><a href="#参数为list示例的写法" class="headerlink" title="参数为list示例的写法"></a><strong>参数为list示例的写法</strong></h4><p>接口的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title function_">getStudentListByClassIds</span><span class="hljs-params">(List&lt;String&gt; classIdList)</span>;<br></code></pre></td></tr></table></figure><p>动态SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 7.2 foreach(循环List&lt;String&gt;参数) - 作为where中in的条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListByClassIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,     ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    WHERE ms.CLASS_ID IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;classIdList&quot;</span>  <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>          #&#123;classIdList&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码，查询学生中，在20000001、20000002这两个班级的学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>    ArrayList&lt;String&gt; classIdList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    classIdList.add(<span class="hljs-string">&quot;20000001&quot;</span>);<br>    classIdList.add(<span class="hljs-string">&quot;20000002&quot;</span>);<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentListByClassIds(classIdList);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sql片段标签<code>&lt;sql&gt;</code>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性</p><p>需要配置的属性：id=”” &gt;&gt;&gt;表示需要改sql语句片段的唯一标识</p><p>引用：通过<code>&lt;include refid=&quot;&quot; /&gt;</code>标签引用，refid=”” 中的值指向需要引用的<code>&lt;sql&gt;</code>中的id=“”属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义sql片段--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderAndItem&quot;</span>&gt;</span>   t1.order_id,t1.cid,t1.address,t1.create_date,t1.item,t2.item,t2.product_id,t2.count<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findOrderAndItemsByOid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>    select  <span class="hljs-comment">&lt;!--引用sql片段--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;orderAndItem&quot;</span> /&gt;</span><br>    from table1 t1<br>    join table2 t2 on t1.item = t2.item<br>    where t1.order_id = #&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口优化</title>
    <link href="/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
    <url>/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="接口优化方案总结"><a href="#接口优化方案总结" class="headerlink" title="接口优化方案总结"></a><strong>接口优化方案总结</strong></h2><p>近期接口优化的一些总结：</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="1-批处理"><a href="#1-批处理" class="headerlink" title="1.批处理"></a><strong>1.批处理</strong></h3><p>批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//for循环单笔入库</span><br>list.stream().forEatch(l -&gt; &#123;<br>insert();<br>&#125;);<br><span class="hljs-comment">//批量入库batchInsert();</span><br></code></pre></td></tr></table></figure><h3 id="2-异步处理"><a href="#2-异步处理" class="headerlink" title="2. 异步处理"></a><strong>2. 异步处理</strong></h3><p>异步思想：针对耗时比较长且不是结果必须的逻辑，我们可以考虑放到异步执行，这样能降低接口耗时。</p><h3 id="3-空间换时间"><a href="#3-空间换时间" class="headerlink" title="3. 空间换时间"></a><strong>3. 空间换时间</strong></h3><p>合理使用缓存，针对一些频繁使用且不频繁变更的数据，可以提前缓存起来，需要时直接查缓存，避免频繁地查询数据库或者重复计算。需要注意空间换时间也是一把双刃剑，需要综合考虑使用场景，缓存带来的数据一致性问题也挺令人头疼。</p><h3 id="4-预处理"><a href="#4-预处理" class="headerlink" title="4. 预处理"></a><strong>4. 预处理</strong></h3><p>预取思想，提前把查询的数据计算好，封装好，放入缓存或者表中的某个字段，用的时候会大幅提高接口性能。</p><h3 id="5-池化思想"><a href="#5-池化思想" class="headerlink" title="5. 池化思想"></a><strong>5. 池化思想</strong></h3><p>我们都用过数据库连接池，线程池等，这就是池思想的体现，它们解决的问题就是避免重复创建对象或创建连接，可以重复利用，避免不必要的损耗，因为创建销毁也会占用时间。</p><p>池化思想包含但并不局限于以上两种，总的来说池化思想的本质是<strong>预分配与循环使用</strong>。</p><h3 id="6-串行改并行"><a href="#6-串行改并行" class="headerlink" title="6. 串行改并行"></a><strong>6. 串行改并行</strong></h3><p>串行就是，当前执行逻辑必须等上一个执行逻辑结束之后才执行，并行就是两个执行逻辑互不干扰，所以并行相对来说就比较节省时间，当然是建立在没有结果参数依赖的前提下。</p><h3 id="7-索引"><a href="#7-索引" class="headerlink" title="7. 索引"></a><strong>7. 索引</strong></h3><p>加索引能大大提高数据查询效率，这个在接口设计之出也会考虑到</p><p>索引失效常见情景：</p><p>① 隐式类型转换；</p><p>② select * ；</p><p>③ 对索引进行列运算(+、-、*、/)；</p><p>④ 不满足最左匹配原则；</p><p>⑤ 使用or关键字；</p><p>⑥ not in 和 not exists；</p><p>⑦ order by 和搜索列不匹配；</p><p>⑧ 使用&lt;、&gt;、!=;</p><p>⑨ like以通配符开头(‘%xxx’)</p><h3 id="8-避免大事务"><a href="#8-避免大事务" class="headerlink" title="8. 避免大事务"></a><strong>8. 避免大事务</strong></h3><p>所谓大事务问题，就是<strong>运行时间较长的事务，</strong>由于事务一致不提交，会导致数据库连接被占用，影响到别的请求访问数据库，影响别的接口性能。事务中嵌套 RPC 调用，即非 DB 操作，这些非 DB 操作如果耗时较大的话，可能会出现大事务问题。大数据引发的问题主要有：死锁、接口超时、主从延迟等。所以为避免大事务问题，我们可以通过以下方案规避：</p><p>① RPC调用不放到事务里面;</p><p>② 查询操作尽量放到事务之外;</p><p>③ 事务中避免处理太多数据。</p><h3 id="9-优化程序结构"><a href="#9-优化程序结构" class="headerlink" title="9. 优化程序结构"></a><strong>9. 优化程序结构</strong></h3><p>程序结构问题一般出现在多次需求迭代后，代码叠加形成。会造成一些重复查询、多次创建对象等耗时问题。在多人维护一个项目时比较多见。解决起来也比较简单，我们需要针对接口整体做重构，评估每个代码块的作用和用途，调整执行顺序。</p><h3 id="10-深分页问题"><a href="#10-深分页问题" class="headerlink" title="10. 深分页问题"></a><strong>10. 深分页问题</strong></h3><p>深分页问题比较常见，分页我们一般最先想到的就是 limit，为什么会慢，如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderTime <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>,<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>limit 100000,200 意味着会扫描 100200 行，然后返回 200 行，丢弃掉前 100000 行。所以执行速度很慢。一般可以采用标签记录法来优化，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <br><span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> limit <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>这样优化的好处是命中了主键索引，无论多少页，性能都还不错，但是局限性是需要一个连续自增的字段。</p><p>避免使用select *，其实select后字段名全写，也比 * 效率高很多。</p><h3 id="11-SQL-优化"><a href="#11-SQL-优化" class="headerlink" title="11.SQL 优化"></a><strong>11.SQL 优化</strong></h3><p>sql优化能大幅提高接口的查询性能，结合索引、分页等关注点制定优化方案。</p><h3 id="12-锁粒度避免过粗"><a href="#12-锁粒度避免过粗" class="headerlink" title="12. 锁粒度避免过粗"></a><strong>12. 锁粒度避免过粗</strong></h3><p>锁一般是为了在高并发场景下保护共享资源采用的一种手段，但是如果锁的粒度太粗，会很影响接口性能。</p><p>关于锁粒度：就是要锁的范围有多大，不管是 synchronized 还是 redis 分布式锁，只需要在临界资源处加锁即可，不涉及共享资源的，不必要加锁，就好比你要上卫生间，只需要把卫生间的门锁上就可以，不需要把客厅的门也锁上。</p><p>错误的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intwrong</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>    share();<br>        notShare();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intright</span><span class="hljs-params">()</span>&#123;    <br>notShare();<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>share(); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;接口调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储过程</title>
    <link href="/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程介绍"><a href="#存储过程介绍" class="headerlink" title="存储过程介绍"></a>存储过程介绍</h1><p>[TOC]</p><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h3 id="1-带参存储过程语法"><a href="#1-带参存储过程语法" class="headerlink" title="1.带参存储过程语法"></a>1.带参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字(<br>    <span class="hljs-comment">--输入参数 IN NUMBER,</span><br>    <span class="hljs-comment">--输出参数 OUT NUMBER, --可以有多个输入参数和输出参数</span><br>                <span class="hljs-comment">--输入输出 INOUT NUMBER</span><br>) <span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>     <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>      <span class="hljs-keyword">rollback</span>;<br>      dbms_output.put_line(sqlcode);<br>      dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><blockquote><ul><li>​        注意：</li><li>​            其中参数IN表示输入参数，是参数的默认模式。</li><li>​            OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。</li><li>​            OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程</li><li>​            IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。</li></ul></blockquote><h3 id="2-无参存储过程语法"><a href="#2-无参存储过程语法" class="headerlink" title="2.无参存储过程语法"></a>2.无参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字<br><span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>    <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>   <span class="hljs-keyword">rollback</span>;<br>   dbms_output.put_line(sqlcode);<br>   dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1-带参存储过程语法-1"><a href="#1-带参存储过程语法-1" class="headerlink" title="1.带参存储过程语法"></a>1.带参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字([<span class="hljs-keyword">in</span>,<span class="hljs-keyword">out</span>,<span class="hljs-keyword">inout</span>] 参数名 数据类型)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><h3 id="2-无参存储过程语法-1"><a href="#2-无参存储过程语法-1" class="headerlink" title="2.无参存储过程语法"></a>2.无参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><h3 id="流程控制-判断语句"><a href="#流程控制-判断语句" class="headerlink" title="流程控制-判断语句"></a>流程控制-判断语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">if 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br>elseif 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">case</span> 参数<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure><h3 id="流程控制-循环语句"><a href="#流程控制-循环语句" class="headerlink" title="流程控制-循环语句"></a>流程控制-循环语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>while 循环条件<br>do 循环体;<br><span class="hljs-keyword">end</span> while 标签;<br></code></pre></td></tr></table></figure><h4 id="repeat语句"><a href="#repeat语句" class="headerlink" title="repeat语句"></a>repeat语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>repeat 循环体;<br>until 条件表达式<br><span class="hljs-keyword">end</span> repeat 标签;<br></code></pre></td></tr></table></figure><h4 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签:<br>loop 循环体;<br>if 条件表达式 <span class="hljs-keyword">then</span><br>leave 标签;<br><span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span> loop;<br>loop<br>    执行语句;<br>    exit <span class="hljs-keyword">when</span> <span class="hljs-operator">&lt;</span>条件语句<span class="hljs-operator">&gt;</span> <span class="hljs-comment">--条件满足，退出循环语句;</span><br><span class="hljs-keyword">end</span> loop;<br></code></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">for</span> 循环计数器 <span class="hljs-keyword">in</span> [REVERSE] 下限 .. 上限 loop<br>要执行的语句;<br><span class="hljs-keyword">end</span> loop [循环标签];<br>每循环一次，循环变量自动加<span class="hljs-number">1</span>；使用关键字REVERSE，循环变量自动减<span class="hljs-number">1</span>。<br><span class="hljs-keyword">in</span> REVERSE 后面的数字必须是从小到大的顺序，而且必须是整数，不能是变量或表达式,也可以使用EXIT退出循环，见loop语句。<br></code></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h4 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h4><blockquote><ul><li>MySQL:<ul><li>declare 游标名称 cursor for 传给游标的结果集;</li><li>open 游标名称;</li><li>fetch 游标名称 into 自定义变量;</li><li>close 游标名称;</li></ul></li><li>Oracle:<ul><li>cursor 游标名称 is 传给游标的结果集;</li><li>open 游标名称;</li><li>fetch 游标名称 into 自定义变量;</li><li>close 游标名称;</li></ul></li></ul></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th align="left">类别描述</th><th align="left">MySQL</th><th align="left">Oracle</th><th align="left">注解</th></tr></thead><tbody><tr><td align="left">创建存储过程/函数语句</td><td align="left">DROP PROCEDURE IF EXISTS <code>存储过程名称</code>;<br/>create procedure 存储过程名称()<br/>DROP FUNCTION IF EXISTS <code>函数名称</code>;<br/>CREATE  FUNCTION <code>函数名称</code>()<br/> RETURNS varchar(1000)</td><td align="left">create or replace procedure 存储过程名称（） is<br/>create or replace function 函数名称()<br/>RETURN VARCHAR2</td><td align="left">1.在创建存储过程时如果存在同名的存储过程,会删除老的存储过程. <br/>  Oracle使用create or replace.<br/>  MySQL使用先删除老的存储过程,然后再创建新的存储过程.<br/>2. Oracle存储过程可以定义在package中,也可以定义在Procedures中. 如果定义在包中,一个包中可以包含多个存储过程和方法.如果定义在Procedures中,存储过程中不可以定义多个存储过程. <br/>   MySQL存储过程中不可以定义多个存储过程.</td></tr><tr><td align="left">传参</td><td align="left">存储过程名称(参数类型  参数  参数属性)</td><td align="left">存储过程名称(参数  参数类型  参数属性)</td><td align="left">1. oracle存储过程参数可以定义为表的字段类型.<br/>   Mysql存储过程不支持这种定义方法.需要定义变量的实际类型和长度.<br/>2. oracle 参数类型in/out/inout写在参数名后面. <br/>   Mysql  参数类型in/out/inout写在参数名前面.<br/>3. oracle 参数类型in/out/inout 都必须写.<br/>   Mysql  参数类型默认in,可省略，out或inout不可省略.</td></tr><tr><td align="left">包</td><td align="left">多个存储过程或函数</td><td align="left">create or replace package/package body package name</td><td align="left">oracle可以创建包,包中可以包含多个存储过程和方法. <br/>mysql没有包，需分别创建存储过程和方法. 每个存储过程或方法都需要放在一个文件中.</td></tr><tr><td align="left">存储过程返回语句</td><td align="left">LEAVE  xx;</td><td align="left">return;</td><td align="left">oracle存储过程和方法都可以使用return退出当前过程和方法. <br/>Mysql存储过程中只能使用leave退出当前存储过程.不可以使用return. <br/>Mysql方法可以使用return退出当前方法.</td></tr><tr><td align="left">声明变量的位置</td><td align="left">begin…end内</td><td align="left">begin之前</td><td align="left"></td></tr><tr><td align="left">调用方式</td><td align="left">call 存储过程名称();</td><td align="left">存储过程名称();</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>&lt;数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储过程 Oracle MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
