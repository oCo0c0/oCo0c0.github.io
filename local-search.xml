<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内网ubuntu系统访问</title>
    <link href="/2024/03/27/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0ubuntu%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/03/27/%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0ubuntu%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="内网ubuntu系统访问"><a href="#内网ubuntu系统访问" class="headerlink" title="内网ubuntu系统访问"></a>内网ubuntu系统访问</h1><h2 id="一、内网访问"><a href="#一、内网访问" class="headerlink" title="一、内网访问"></a>一、内网访问</h2><h3 id="1-检查网络连接"><a href="#1-检查网络连接" class="headerlink" title="1. 检查网络连接"></a>1. <strong>检查网络连接</strong></h3><ul><li>确保你的Ubuntu计算机已连接到局域网，并且可以与其他计算机进行通信。</li></ul><h3 id="2-确认开启SSH服务"><a href="#2-确认开启SSH服务" class="headerlink" title="2. 确认开启SSH服务"></a>2. <strong>确认开启SSH服务</strong></h3><ul><li><p>在Ubuntu上，默认情况下可能没有安装SSH服务器。你可以通过以下命令安装OpenSSH服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>安装完成后，SSH服务会自动启动。你可以通过以下命令检查服务状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status ssh<br></code></pre></td></tr></table></figure></li><li><p>如果服务未启动，你可以使用以下命令启动它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start ssh<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-配置防火墙（如果需要）"><a href="#3-配置防火墙（如果需要）" class="headerlink" title="3. 配置防火墙（如果需要）"></a>3. <strong>配置防火墙</strong>（如果需要）</h3><ul><li><p>如果你的Ubuntu系统启用了防火墙，确保允许SSH连接。默认情况下，SSH服务监听22端口。你可以使用ufw命令（如果已安装）来配置防火墙：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ufw allow ssh<br>sudo ufw <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-获取Ubuntu计算机的IP地址"><a href="#4-获取Ubuntu计算机的IP地址" class="headerlink" title="4. 获取Ubuntu计算机的IP地址"></a>4. <strong>获取Ubuntu计算机的IP地址</strong></h3><ul><li><p>使用以下命令获取你的Ubuntu计算机的IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr show | grep inet<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-连接到Ubuntu计算机"><a href="#5-连接到Ubuntu计算机" class="headerlink" title="5. 连接到Ubuntu计算机"></a>5. <strong>连接到Ubuntu计算机</strong></h3><ul><li><p>在其他计算机上，使用SSH客户端（例如PuTTY或Terminal）连接到你的Ubuntu计算机。你需要使用Ubuntu计算机的IP地址和SSH用户名进行连接。默认情况下，你可以使用用户名ubuntu连接。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh ubuntu@&lt;Ubuntu_IP_Address&gt;<br></code></pre></td></tr></table></figure></li><li><p>如果你使用的是不同的用户名，请用你的用户名替换<code>ubuntu</code>。</p></li></ul><h2 id="二、外网访问"><a href="#二、外网访问" class="headerlink" title="二、外网访问"></a>二、外网访问</h2><h3 id="1-确认外部IP地址"><a href="#1-确认外部IP地址" class="headerlink" title="1. 确认外部IP地址"></a>1. <strong>确认外部IP地址</strong></h3><ul><li>确保你的网络环境中有一个公共IP地址，用于从外部访问你的网络。</li></ul><h3 id="2-配置路由器"><a href="#2-配置路由器" class="headerlink" title="2. 配置路由器"></a>2. <strong>配置路由器</strong></h3><ul><li>登录到你的路由器管理界面。</li><li>配置端口转发（Port Forwarding）来将外部流量转发到你的Ubuntu计算机。通常，SSH服务默认监听端口22。因此，你需要将路由器的外部端口22（或其他你想要用来远程访问的端口）映射到你的Ubuntu计算机的内部IP地址和端口22上。</li></ul><h3 id="3-设置动态DNS（可选）"><a href="#3-设置动态DNS（可选）" class="headerlink" title="3. 设置动态DNS（可选）"></a>3. <strong>设置动态DNS（可选）</strong></h3><ul><li>如果你的ISP分配的IP地址是动态的，你可能想要设置动态DNS（Dynamic DNS），这样你就可以使用一个域名来访问你的网络，而不必担心IP地址的变化。有很多免费的动态DNS服务提供商可以选择，如DynDNS、No-IP等。</li></ul><h3 id="4-防火墙配置"><a href="#4-防火墙配置" class="headerlink" title="4. 防火墙配置"></a>4. <strong>防火墙配置</strong></h3><ul><li>确保你的Ubuntu计算机的防火墙允许来自外部网络的连接。默认情况下，Ubuntu的防火墙通常允许外部SSH连接，但如果你有其他安全设置，可能需要相应地调整防火墙规则。</li></ul><h3 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5. 测试连接"></a>5. <strong>测试连接</strong></h3><ul><li><p>在外部网络中，使用SSH客户端连接到你的公共IP地址（或者你设置的动态DNS域名）和相应的端口。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh username@your_public_ip -p port_number<br></code></pre></td></tr></table></figure></li><li><p>其中，<code>username</code>是你的Ubuntu用户名，<code>your_public_ip</code>是你的公共IP地址或动态DNS域名，<code>port_number</code>是你在路由器上设置的端口号。</p></li></ul><h2 id="三、路由器转发"><a href="#三、路由器转发" class="headerlink" title="三、路由器转发"></a>三、路由器转发</h2><h3 id="1-设置静态IP地址"><a href="#1-设置静态IP地址" class="headerlink" title="1. 设置静态IP地址"></a>1. <strong>设置静态IP地址</strong></h3><ul><li><p>在你的Ubuntu服务器上设置一个静态IP地址，这样你每次连接时都知道它的地址。编辑 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/network/interfaces<br></code></pre></td></tr></table></figure><p> 文件来配置静态IP地址。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/network/interfaces<br></code></pre></td></tr></table></figure><p>在文件中添加如下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">auto eth0<br>iface eth0 inet static<br>address 192.168.1.100  <span class="hljs-comment"># 你的服务器IP地址</span><br>netmask 255.255.255.0<br>gateway 192.168.1.1     <span class="hljs-comment"># 你的路由器IP地址</span><br></code></pre></td></tr></table></figure></li><li><p>保存并关闭文件。然后重启网络服务以使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl restart networking<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-启用SSH服务"><a href="#2-启用SSH服务" class="headerlink" title="2. 启用SSH服务"></a>2. <strong>启用SSH服务</strong></h3><ul><li><p>确保SSH服务已安装并正在运行。如果尚未安装，可以使用以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br>sudo apt install openssh-server<br></code></pre></td></tr></table></figure></li><li><p>确保SSH服务正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl status ssh<br></code></pre></td></tr></table></figure></li><li><p>如果没有运行，可以使用以下命令启动SSH服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start ssh<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-端口转发设置"><a href="#3-端口转发设置" class="headerlink" title="3.端口转发设置"></a>3.<strong>端口转发设置</strong></h3><ul><li>登录到你的路由器管理界面。通常在浏览器中输入路由器的IP地址即可访问。</li><li>找到“端口转发”、“虚拟服务器”或类似选项。每个路由器界面略有不同，但通常会在“高级设置”或“网络设置”下找到。</li><li>创建一个新的端口转发规则，将外部端口（你想要使用的端口）映射到你服务器的内部IP地址和SSH端口（默认为22）上。</li></ul><h3 id="4-连接到服务器"><a href="#4-连接到服务器" class="headerlink" title="4. 连接到服务器"></a>4. <strong>连接到服务器</strong></h3><ul><li>在远程工具中输入你的公共IP地址和映射的端口号，然后连接。</li><li>如果你不知道你的公共IP地址是什么，你可以在网上搜索“我的IP地址”来找到它。</li></ul><p>获取服务器IP地址和路由器IP地址的方法取决于你的网络环境和设备配置。以下是一些获取这些信息的常见方法：</p><h3 id="5-获取服务器IP地址"><a href="#5-获取服务器IP地址" class="headerlink" title="5.获取服务器IP地址"></a>5.<strong>获取服务器IP地址</strong></h3><p>5.1 <strong>通过命令行</strong>：在Ubuntu服务器上，可以使用命令行工具来获取IP地址。</p><ul><li><p>打开终端（Ctrl + Alt + T）。</p></li><li><p>运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr show<br>ifconfig<br></code></pre></td></tr></table></figure></li><li><p>查找你正在使用的网络接口（通常是eth0或enpXsX）的IP地址。</p></li></ul><p>5.2 <strong>通过路由器管理界面</strong></p><p>登录到你的路由器管理界面，在连接设备列表或DHCP分配中查找你的Ubuntu服务器的IP地址。</p><h3 id="6-获取路由器IP地址"><a href="#6-获取路由器IP地址" class="headerlink" title="6. 获取路由器IP地址"></a>6. <strong>获取路由器IP地址</strong></h3><p>6.1 <strong>查找路由器的标签</strong>：通常，路由器设备上会有一个标签或标识包含了路由器的默认IP地址和登录信息。检查路由器本身或其文档以获取此信息。</p><p>6.2 <strong>通过命令行</strong>：如果你已经连接到你的路由器的网络中，你可以通过以下方法获取路由器的IP地址。</p><ul><li><p>在Windows上，打开命令提示符，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipconfig<br></code></pre></td></tr></table></figure><p>查找你当前使用的网络适配器（通常是以太网或Wi-Fi），然后查找“默认网关”项。这就是你的路由器的IP地址。</p></li><li><p>在Ubuntu服务器上，使用上面提到的 <code>ip addr show</code> 或 <code>ifconfig</code> 命令，然后查找你正在使用的网络接口的默认网关。</p></li></ul><p>6.3 <strong>通过路由器管理界面</strong></p><p>使用你的计算机浏览器打开默认网关的IP地址（通常是192.168.1.1或192.168.0.1），然后登录到路由器管理界面。在管理界面中，你应该能够找到路由器的IP地址。</p>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网关 ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo rpc通信</title>
    <link href="/2024/03/24/Dubbo%20rpc%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/03/24/Dubbo%20rpc%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rocketmq 消息驱动</title>
    <link href="/2024/03/24/Rocketmq%20%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/"/>
    <url>/2024/03/24/Rocketmq%20%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel 服务容错</title>
    <link href="/2024/03/24/Sentinel%20%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99/"/>
    <url>/2024/03/24/Sentinel%20%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Seata 分布式事务</title>
    <link href="/2024/03/24/Seata%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/03/24/Seata%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sleuth 链路追踪</title>
    <link href="/2024/03/24/Sleuth%20%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/"/>
    <url>/2024/03/24/Sleuth%20%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gateway 服务网关</title>
    <link href="/2024/03/21/Gateway%20%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
    <url>/2024/03/21/Gateway%20%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Gateway-服务网关"><a href="#Gateway-服务网关" class="headerlink" title="Gateway 服务网关"></a>Gateway 服务网关</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><blockquote><p>客户端多次请求不同的微服务，增加客户端代码或配置编写的复杂性<br>认证复杂，每个服务都需要独立认证。<br>存在跨域请求，在一定场景下处理相对复杂。</p></blockquote><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p><strong>API网关</strong></p><blockquote><p>​    所谓的API网关，就是指系统的统一入口，它封装了应用程序的内部结构，为客户端提供统一服<br>务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等等。</p></blockquote><p>架构变化</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-11.png"></p><h2 id="1-Gateway介绍"><a href="#1-Gateway介绍" class="headerlink" title="1. Gateway介绍"></a>1. Gateway介绍</h2><blockquote><p>​    Spring Cloud Gateway是Spring公司基于Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。它的目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控和限流。</p></blockquote><p>优点</p><ul><li>性能强劲：是第一代网关Zuul的1.6倍</li><li>功能强大：内置了很多实用的功能，例如转发、监控、限流等</li><li>设计优雅，容易扩展</li></ul><p>缺点：</p><ul><li>其实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高</li><li>不能将其部署在Tomcat、Jetty等Servlet容器里，只能打成jar包执行</li><li>需要Spring Boot 2.0及以上的版本，才支持</li></ul><h2 id="2-Gateway-Nacos搭建"><a href="#2-Gateway-Nacos搭建" class="headerlink" title="2. Gateway+Nacos搭建"></a>2. Gateway+Nacos搭建</h2><h3 id="2-1-创建一个-api-gateway-的模块-导入相关依赖"><a href="#2-1-创建一个-api-gateway-的模块-导入相关依赖" class="headerlink" title="2.1 创建一个 api-gateway 的模块,导入相关依赖"></a>2.1 创建一个 api-gateway 的模块,导入相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-along<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>api-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--gateway网关--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--nacos客户端--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-创建主类"><a href="#2-2-创建主类" class="headerlink" title="2.2 创建主类"></a>2.2 创建主类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiGatewayApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(ApiGatewayApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-添加配置文件"><a href="#2-3-添加配置文件" class="headerlink" title="2.3 添加配置文件"></a>2.3 添加配置文件</h3><p><strong>注</strong></p><blockquote><p>此处配置文件为所有配置，后续不再详细展示</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7000</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">@profileActive@</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 让gateway可以发现nacos中的微服务</span><br>      <span class="hljs-attr">routes:</span> <span class="hljs-comment"># 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span> <span class="hljs-comment"># 当前路由的标识, 要求唯一</span><br>          <span class="hljs-attr">order:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 路由的优先级,数字越小级别越高</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-product-$&#123;spring.profiles.active&#125;</span> <span class="hljs-comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br>          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 断言(就是路由转发要满足的条件)</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product-service/**</span>  <span class="hljs-comment"># 当请求路径满足Path指定的规则时,才进行路由转发</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2019-11-28T00:00:00.000+08:00</span> <span class="hljs-comment">#限制请求时间在2019-11-28之前</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Method=POST</span> <span class="hljs-comment">#限制请求方式为POST</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Age=18,60</span> <span class="hljs-comment"># 限制年龄只有在18到60岁之间的人能访问</span><br>          <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span> <span class="hljs-comment"># 转发之前去掉1层路径</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=2000</span> <span class="hljs-comment"># 修改返回状态</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Log=true,false</span> <span class="hljs-comment"># 控制日志是否开启</span><br></code></pre></td></tr></table></figure><h3 id="2-4-启动产品和网关微服务，浏览器查看效果"><a href="#2-4-启动产品和网关微服务，浏览器查看效果" class="headerlink" title="2.4 启动产品和网关微服务，浏览器查看效果"></a>2.4 启动产品和网关微服务，浏览器查看效果</h3><p>断言配置 <code>Path=/product-service/**</code>，所以请求路径必须是这个才能转发</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-12.png"></p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-13.png"></p><h2 id="3-Gateway核心"><a href="#3-Gateway核心" class="headerlink" title="3. Gateway核心"></a>3. Gateway核心</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><p>路由(Route) 是 gateway 中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息:</p><ul><li>id，路由标识符，区别于其他 Route。</li><li>uri，路由指向的目的地 uri，即客户端请求最终被转发到的微服务。</li><li>order，用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。</li><li>predicate，断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。</li><li>filter，过滤器用于修改请求和响应信息。</li></ul><h3 id="3-2-执行流程"><a href="#3-2-执行流程" class="headerlink" title="3.2 执行流程"></a>3.2 执行流程</h3><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-14.png"></p><p>执行流程大体如下：</p><ol><li>Gateway Client向Gateway Server发送请求</li><li>请求首先会被HttpWebHandlerAdapter进行提取组装成网关上下文</li><li>然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给<br>RoutePredicateHandlerMapping</li><li>RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用</li><li>如果过断言成功，由FilteringWebHandler创建过滤器链并调用</li><li>请求会一次经过PreFilter–微服务–PostFilter的方法，最终返回响应</li></ol><h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><blockquote><p>Predicate(断言, 谓词) 用于进行条件判断，只有断言都返回真，才会真正的执行路由。<br>断言就是说: 在 什么条件下 才能进行路由转发</p></blockquote><h3 id="4-1-内置路由断言工厂"><a href="#4-1-内置路由断言工厂" class="headerlink" title="4.1 内置路由断言工厂"></a>4.1 内置路由断言工厂</h3><p>SpringCloud Gateway包括许多内置的断言工厂，所有这些断言都与HTTP请求的不同属性匹配。具体如下：</p><ul><li><p>基于Datetime类型的断言工厂</p><p>此类型的断言根据时间做判断，主要有三个：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">AfterRoutePredicateFactory： 接收一个日期参数，判断请求日期是否晚于指定日期<br><span class="hljs-keyword">BeforeRoutePredicateFactory： </span>接收一个日期参数，判断请求日期是否早于指定日期<br><span class="hljs-keyword">BetweenRoutePredicateFactory： </span>接收两个日期参数，判断请求日期是否在指定时间段内<br></code></pre></td></tr></table></figure><blockquote><p>-After=2019-12-31T23:59:59.789+08:00[Asia/Shanghai]</p></blockquote></li><li><p>基于远程地址的断言工厂 RemoteAddrRoutePredicateFactory：接收一个IP地址段，判断请求主<br>机地址是否在地址段中</p><blockquote><p>-RemoteAddr=192.168.1.1/24</p></blockquote></li><li><p>基于Cookie的断言工厂</p><p>CookieRoutePredicateFactory：接收两个参数，cookie 名字和一个正则表达式。 判断请求cookie是否具有给定名称且值与正则表达式匹配。</p><blockquote><p>-Cookie=chocolate, ch.</p></blockquote></li><li><p>基于Header的断言工厂</p><p>HeaderRoutePredicateFactory：接收两个参数，标题名称和正则表达式。 判断请求Header是否<br>具有给定名称且值与正则表达式匹配。</p><blockquote><p>-Header=X-Request-Id, \d+</p></blockquote></li><li><p>基于Host的断言工厂</p><p>HostRoutePredicateFactory：接收一个参数，主机名模式。判断请求的Host是否满足匹配规则。</p><blockquote><p>-Host=**.testhost.org</p></blockquote></li><li><p>基于Method请求方法的断言工厂</p><p>MethodRoutePredicateFactory：接收一个参数，判断请求类型是否跟指定的类型匹配。</p><blockquote><p>-Method=GET</p></blockquote></li><li><p>基于Path请求路径的断言工厂</p><p>PathRoutePredicateFactory：接收一个参数，判断请求的URI部分是否满足路径规则。</p><blockquote><p>-Path=/foo/{segment}</p></blockquote></li><li><p>基于Query请求参数的断言工厂</p><p>QueryRoutePredicateFactory ：接收两个参数，请求param和正则表达式， 判断请求参数是否具<br>有给定名称且值与正则表达式匹配。</p><blockquote><p>-Query=baz, ba.</p></blockquote></li><li><p>基于路由权重的断言工厂</p><p>WeightRoutePredicateFactory：接收一个[组名,权重], 然后对于同一个组内的路由按照权重转发</p><blockquote><p>routes:<br>-id: weight_route1 uri: host1 predicates:<br>-Path=/product/**<br>-Weight=group3, 1<br>-id: weight_route2 uri: host2 predicates:<br>-Path=/product/**<br>-Weight= group3, 9</p></blockquote></li></ul><p><strong>内置路由断言工厂的使用</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span> <span class="hljs-comment"># 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span> <span class="hljs-comment"># 当前路由的标识, 要求唯一</span><br>    <span class="hljs-attr">order:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 路由的优先级,数字越小级别越高</span><br>    <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-product-$&#123;spring.profiles.active&#125;</span> <span class="hljs-comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br>    <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 断言(就是路由转发要满足的条件)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product-service/**</span>  <span class="hljs-comment"># 当请求路径满足Path指定的规则时,才进行路由转发</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2024-03-28T00:00:00.000+08:00</span> <span class="hljs-comment">#限制请求时间在2024-03-28之前</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Method=POST</span> <span class="hljs-comment">#限制请求方式为POST</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span> <span class="hljs-comment"># 转发之前去掉1层路径</span><br></code></pre></td></tr></table></figure><h3 id="4-2-自定义路由断言工厂"><a href="#4-2-自定义路由断言工厂" class="headerlink" title="4.2 自定义路由断言工厂"></a>4.2 自定义路由断言工厂</h3><p><strong>场景：应用仅让age在(min,max)之间的人来访问</strong></p><ul><li><p>在配置文件中,添加一个Age的断言配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">predicates:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Age=18,60</span> <span class="hljs-comment"># 限制年龄只有在18到60岁之间的人能访问</span><br></code></pre></td></tr></table></figure></li><li><p>自定义一个断言工厂, 实现断言方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.gateway.factory;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 自定义断言工厂</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AgeRoutePredicateFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRoutePredicateFactory</span>&lt;AgeRoutePredicateFactory.Config&gt; &#123; <span class="hljs-comment">//泛型 用于接收一个配置类,配置类用于接收中配置文件中的配置</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AgeRoutePredicateFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(AgeRoutePredicateFactory.Config.class);<br>    &#125;<br><br>    <span class="hljs-comment">// 用于从配置文件中获取参数值赋值到配置类中的属性上</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里的顺序要跟配置文件中的参数顺序一致</span><br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;minAge&quot;</span>, <span class="hljs-string">&quot;maxAge&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 断言</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Config config)</span> &#123;<br>        <span class="hljs-keyword">return</span> serverWebExchange -&gt; &#123;<br>            <span class="hljs-comment">// 从serverWebExchange获取传入的参数</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">ageStr</span> <span class="hljs-operator">=</span> serverWebExchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;age&quot;</span>);<br>            <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(ageStr)) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseInt(ageStr);<br>                <span class="hljs-keyword">return</span> age &gt;= config.getMinAge() &amp;&amp; age &lt;= config.getMaxAge();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义一个配置类, 用于接收配置文件中的参数</span><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minAge;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxAge;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>访问url</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic">http://localhost:<span class="hljs-number">7000</span>/product-service/product/<span class="hljs-number">1</span>?age=<span class="hljs-number">30</span><br>http://localhost:<span class="hljs-number">7000</span>/product-service/product/<span class="hljs-number">1</span>?age=<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="5-过滤器"><a href="#5-过滤器" class="headerlink" title="5. 过滤器"></a>5. 过滤器</h2><blockquote><ul><li>作用: 过滤器就是在请求的传递过程中,对请求和响应做一些手脚</li><li>生命周期: Pre Post</li><li>分类: 局部过滤器(作用在某一个路由上) 全局过滤器(作用全部路由上)</li></ul><p>Gateway中, Filter的生命周期只有两个：“pre” 和 “post”。</p><ul><li>PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择<br>请求的微服务、记录调试信息等。</li><li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP<br>Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li></ul><p>Gateway 的Filter从作用范围可分为两种: GatewayFilter与GlobalFilter。</p><ul><li>GatewayFilter：应用到单个路由或者一个分组的路由上。</li><li>GlobalFilter：应用到所有的路由上。</li></ul></blockquote><h3 id="5-1-局部过滤器"><a href="#5-1-局部过滤器" class="headerlink" title="5.1 局部过滤器"></a>5.1 局部过滤器</h3><blockquote><p>​    局部过滤器是针对单个路由的过滤器。</p></blockquote><h4 id="5-1-1-内置局部过滤器"><a href="#5-1-1-内置局部过滤器" class="headerlink" title="5.1.1 内置局部过滤器"></a>5.1.1 内置局部过滤器</h4><ul><li>网关路由过滤器类型</li></ul><table><thead><tr><th>过滤器工厂</th><th>作用</th><th>参数</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>为原始请求添加Header</td><td>Header的名称及值</td></tr><tr><td>AddRequestParameter</td><td>为原始请求添加请求参数</td><td>参数名称及值</td></tr><tr><td>AddResponseHeader</td><td>为原始响应添加Header</td><td>Header的名称及值</td></tr><tr><td>DedupeResponseHeader</td><td>剔除响应头中重复的值</td><td>需要去重的Header名称及去重策略</td></tr><tr><td>Hystrix</td><td>为路由引入Hystrix的断路器保护</td><td>HystrixCommand的名称</td></tr><tr><td>FallbackHeaders</td><td>为fallbackUri的请求头中添加具体的异常信息</td><td>Header的名称</td></tr><tr><td>PrefixPath</td><td>为原始请求路径添加前缀</td><td>前缀路径</td></tr><tr><td>PreserveHostHeader</td><td>为请求添加一个preserveHostHeader=true的属性，路由过滤器会检查该属性以决定是否要发送原始的Host</td><td></td></tr><tr><td>RequestRateLimiter</td><td>用于对请求限流，限流算法为令牌桶</td><td>keyResolver、<br/>rateLimiter、<br/>statusCode、<br/>denyEmptyKey、<br/>emptyKeyStatus</td></tr><tr><td>RedirectTo</td><td>将原始请求重定向到指定的URL</td><td>http状态码及重定向的url</td></tr><tr><td>RemoveHopByHopHeadersFilter</td><td>为原始请求删除IETF组织规定的一系列Header</td><td>默认就会启用，可以通过配置指定仅删除哪些Header</td></tr><tr><td>RemoveRequestHeader</td><td>为原始请求删除某个Header</td><td>Header名称</td></tr><tr><td>RemoveResponseHeader</td><td>为原始响应删除某个Header</td><td>Header名称</td></tr><tr><td>RewritePath</td><td>重写原始的请求路径</td><td>原始路径正则表达式以及重写后路径的正则表达式</td></tr><tr><td>RewriteResponseHeader</td><td>重写原始响应中的某个Header</td><td>Header名称，值的正则表达式，重写后的值</td></tr><tr><td>SaveSession</td><td>在转发请求之前，强制执行<code>WebSession::save</code>操作</td><td></td></tr><tr><td>secureHeaders</td><td>为原始响应添加一系列起安全作用的响应头</td><td>无，支持修改这些安全响应头的值</td></tr><tr><td>SetPath</td><td>修改原始的请求路径</td><td>修改后的路径</td></tr><tr><td>SetResponseHeader</td><td>修改原始响应中某个Header的值</td><td>Header名称，修改后的值</td></tr><tr><td>SetStatus</td><td>修改原始响应的状态码</td><td>HTTP 状态码，可以是数字，也可以是字符串</td></tr><tr><td>StripPrefix</td><td>用于截断原始请求的路径</td><td>使用数字表示要截断的路径的数量</td></tr><tr><td>Retry</td><td>针对不同的响应进行重试</td><td>retries、statuses、methods、series</td></tr><tr><td>RequestSize</td><td>设置允许接收最大请求包的大小。如果请求包大小超过设置的值，则返回 413 Payload TooLarge</td><td>请求包大小，单位为字节，默认值为5M</td></tr><tr><td>ModifyRequestBody</td><td>在转发请求之前修改原始请求体内容</td><td>修改后的请求体内容</td></tr><tr><td>ModifyResponseBody</td><td>修改原始响应体的内容</td><td>修改后的响应体内容</td></tr></tbody></table><h4 id="5-1-2-内置局部过滤器的使用"><a href="#5-1-2-内置局部过滤器的使用" class="headerlink" title="5.1.2 内置局部过滤器的使用"></a>5.1.2 内置局部过滤器的使用</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span> <span class="hljs-comment"># 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span> <span class="hljs-comment"># 当前路由的标识, 要求唯一</span><br>    <span class="hljs-attr">order:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 路由的优先级,数字越小级别越高</span><br>    <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-product-$&#123;spring.profiles.active&#125;</span> <span class="hljs-comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br>    <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 断言(就是路由转发要满足的条件)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product-service/**</span>  <span class="hljs-comment"># 当请求路径满足Path指定的规则时,才进行路由转发</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span> <span class="hljs-comment"># 转发之前去掉1层路径</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=2000</span> <span class="hljs-comment"># 修改返回状态</span><br></code></pre></td></tr></table></figure><ul><li><p>自定义局部过滤器</p><p>第1步：在配置文件中,添加一个Log的过滤器配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">routes:</span> <span class="hljs-comment"># 路由数组[路由 就是指定当请求满足什么条件的时候转到哪个微服务]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">product_route</span> <span class="hljs-comment"># 当前路由的标识, 要求唯一</span><br>    <span class="hljs-attr">order:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 路由的优先级,数字越小级别越高</span><br>    <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-product-$&#123;spring.profiles.active&#125;</span> <span class="hljs-comment"># lb指的是从nacos中按照名称获取微服务,并遵循负载均衡策略</span><br>    <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 断言(就是路由转发要满足的条件)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/product-service/**</span>  <span class="hljs-comment"># 当请求路径满足Path指定的规则时,才进行路由转发</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-comment"># 过滤器,请求在传递过程中可以通过过滤器对其进行一定的修改</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span> <span class="hljs-comment"># 转发之前去掉1层路径</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SetStatus=2000</span> <span class="hljs-comment"># 修改返回状态</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Log=true,false</span> <span class="hljs-comment"># 控制日志是否开启</span><br></code></pre></td></tr></table></figure><p>第2步：自定义一个过滤器工厂,实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.gateway.factory;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 过滤器工厂</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractGatewayFilterFactory</span>&lt;LogGatewayFilterFactory.Config&gt; &#123;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogGatewayFilterFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(LogGatewayFilterFactory.Config.class);<br>    &#125;<br><br>    <span class="hljs-comment">// 读取配置文件中的参数 赋值到 配置类中</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;consoleLog&quot;</span>, <span class="hljs-string">&quot;cacheLog&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 过滤器逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title function_">apply</span><span class="hljs-params">(LogGatewayFilterFactory.Config config)</span> &#123;<br>        <span class="hljs-keyword">return</span> (exchange, chain) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (config.isCacheLog()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;cacheLog已经开启了....&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (config.isConsoleLog()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;consoleLog已经开启了....&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 配置类 接收配置参数</span><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-meta">@NoArgsConstructor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> consoleLog;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> cacheLog;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-2-全局过滤器"><a href="#5-2-全局过滤器" class="headerlink" title="5.2 全局过滤器"></a>5.2 全局过滤器</h3><blockquote><p>​    全局过滤器作用于所有路由, 无需配置。通过全局过滤器可以实现对权限的统一校验，安全性验证等功能。</p></blockquote><h4 id="5-2-1-内置全局过滤器"><a href="#5-2-1-内置全局过滤器" class="headerlink" title="5.2.1 内置全局过滤器"></a>5.2.1 内置全局过滤器</h4><p>SpringCloud Gateway内部也是通过一系列的内置全局过滤器对整个路由转发进行处理如下：</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-15.png"></p><h4 id="5-2-2-内置全局过滤器的使用"><a href="#5-2-2-内置全局过滤器的使用" class="headerlink" title="5.2.2 内置全局过滤器的使用"></a>5.2.2 内置全局过滤器的使用</h4><blockquote><p>​    内置的过滤器已经可以完成大部分的功能，但是对于企业开发的一些业务功能处理，还是需要我们自己编写过滤器来实现的，那么我们一起通过代码的形式自定义一个过滤器，去完成统一的权限校验。</p></blockquote><p>开发中的鉴权逻辑：</p><ul><li>当客户端第一次请求服务时，服务端对用户进行信息认证（登录）</li><li>认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证</li><li>以后每次请求，客户端都携带认证的token</li><li>服务端对token进行解密，判断是否有效。</li></ul><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-16.png"></p><ul><li><p>自定义全局过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.gateway.filter;<br><br><span class="hljs-keyword">import</span> com.alibaba.nacos.client.utils.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.core.Ordered;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 全局过滤器 实现GlobalFilter和Ordered接口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-comment">// 完成判断逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain</span><br><span class="hljs-params">            chain)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span> (StringUtils.isBlank(token)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;鉴权失败&quot;</span>);<br>            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>        &#125;<br>        <span class="hljs-comment">// 调用chain.filter继续向下游执行</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br><br>    <span class="hljs-comment">// 顺序,数值越小,优先级越高</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-3-测试结果"><a href="#5-2-3-测试结果" class="headerlink" title="5.2.3 测试结果"></a>5.2.3 测试结果</h4><p>带token请求</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-17.png"></p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-20.png"></p><p>不带token请求</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-18.png"></p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-19.png"></p></li></ul><h2 id="6-网关限流"><a href="#6-网关限流" class="headerlink" title="6.网关限流"></a>6.网关限流</h2><blockquote><p>​    网关是所有请求的公共入口，所以可以在网关进行限流，而且限流的方式也很多，我们本次采用前<br>面学过的Sentinel组件来实现网关的限流。Sentinel支持对SpringCloud Gateway、Zuul等主流网关进行限流。</p></blockquote><p>Sentinel提供了SpringCloud Gateway的适配模块，可以提供两种资源维度的限流：</p><ul><li>route维度：即在Spring配置文件中配置的路由条目，资源名为对应的routeId</li><li>自定义API维度：用户可以利用Sentinel提供的API来自定义一些API分组</li></ul><h3 id="6-1-导入依赖"><a href="#6-1-导入依赖" class="headerlink" title="6.1 导入依赖"></a>6.1 导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-spring-cloud-gateway-adapter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-2-编写配置类"><a href="#6-2-编写配置类" class="headerlink" title="6.2 编写配置类"></a>6.2 编写配置类</h3><ul><li><p>基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter实例以及SentinelGatewayBlockExceptionHandler 实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.gateway.config;<br><br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayRuleManager;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.sc.SentinelGatewayFilter;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.sc.callback.BlockRequestHandler;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.sc.callback.GatewayCallbackManager;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.sc.exception.SentinelGatewayBlockExceptionHandler;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.ObjectProvider;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.core.Ordered;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.http.MediaType;<br><span class="hljs-keyword">import</span> org.springframework.http.codec.ServerCodecConfigurer;<br><span class="hljs-keyword">import</span> org.springframework.web.reactive.function.BodyInserters;<br><span class="hljs-keyword">import</span> org.springframework.web.reactive.function.server.ServerResponse;<br><span class="hljs-keyword">import</span> org.springframework.web.reactive.result.view.ViewResolver;<br><br><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> Filter 限流配置类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayConfiguration</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GatewayConfiguration</span><span class="hljs-params">(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt;</span><br><span class="hljs-params">                                        viewResolversProvider,</span><br><span class="hljs-params">                                ServerCodecConfigurer serverCodecConfigurer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.viewResolvers =<br>                viewResolversProvider.getIfAvailable(Collections::emptyList);<br>        <span class="hljs-built_in">this</span>.serverCodecConfigurer = serverCodecConfigurer;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化一个限流的过滤器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br>    <span class="hljs-keyword">public</span> GlobalFilter <span class="hljs-title function_">sentinelGatewayFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelGatewayFilter</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 配置初始化的限流参数</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initGatewayRules</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;GatewayFlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        rules.add(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFlowRule</span>(<span class="hljs-string">&quot;product_route&quot;</span>) <span class="hljs-comment">//资源名称,对应路由id</span><br>                        .setCount(<span class="hljs-number">1</span>) <span class="hljs-comment">// 限流阈值</span><br>                        .setIntervalSec(<span class="hljs-number">5</span>) <span class="hljs-comment">// 统计时间窗口，单位是秒，默认是 1 秒</span><br>        );<br>        GatewayRuleManager.loadRules(rules);<br>    &#125;<br><br>    <span class="hljs-comment">// 配置限流的异常处理器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span><br>    <span class="hljs-keyword">public</span> SentinelGatewayBlockExceptionHandler<br>    <span class="hljs-title function_">sentinelGatewayBlockExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SentinelGatewayBlockExceptionHandler</span>(viewResolvers,<br>                serverCodecConfigurer);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义限流异常页面</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBlockHandlers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">BlockRequestHandler</span> <span class="hljs-variable">blockRequestHandler</span> <span class="hljs-operator">=</span> (serverWebExchange, throwable) -&gt; &#123;<br>            Map&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            map.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-number">0</span>);<br>            map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;接口被限流了&quot;</span>);<br>            <span class="hljs-keyword">return</span> ServerResponse.status(HttpStatus.OK).<br>                    contentType(MediaType.APPLICATION_JSON_UTF8).<br>                    body(BodyInserters.fromObject(map));<br>        &#125;;<br>        GatewayCallbackManager.setBlockHandler(blockRequestHandler);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义API分组</p><p>自定义API分组是一种更细粒度的限流规则定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.gateway.config;<br><br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.SentinelGatewayConstants;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiDefinition;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiPathPredicateItem;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiPredicateItem;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.api.GatewayApiDefinitionManager;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayRuleManager;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.annotation.PostConstruct;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> Gateway rules configuration</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayRulesConfiguration</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化网关流规则</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initGatewayRules</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;GatewayFlowRule&gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        rules.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFlowRule</span>(<span class="hljs-string">&quot;product_api1&quot;</span>).setCount(<span class="hljs-number">1</span>).setIntervalSec(<span class="hljs-number">1</span>));<br>        rules.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFlowRule</span>(<span class="hljs-string">&quot;product_api2&quot;</span>).setCount(<span class="hljs-number">1</span>).setIntervalSec(<span class="hljs-number">1</span>));<br>        GatewayRuleManager.loadRules(rules);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化自定义API</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initCustomizedApis</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;ApiDefinition&gt; definitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">ApiDefinition</span> <span class="hljs-variable">api1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiDefinition</span>(<span class="hljs-string">&quot;product_api1&quot;</span>)<br>                .setPredicateItems(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;ApiPredicateItem&gt;() &#123;&#123;<br>                    add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiPathPredicateItem</span>().setPattern(<span class="hljs-string">&quot;/productserv/product/api1/**&quot;</span>)<br>                            .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));<br>                &#125;&#125;);<br>        <span class="hljs-type">ApiDefinition</span> <span class="hljs-variable">api2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiDefinition</span>(<span class="hljs-string">&quot;product_api2&quot;</span>)<br>                .setPredicateItems(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;ApiPredicateItem&gt;() &#123;&#123;<br>                    add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiPathPredicateItem</span>().setPattern(<span class="hljs-string">&quot;/productserv/product/api2/demo1&quot;</span>));<br>                &#125;&#125;);<br>        definitions.add(api1);<br>        definitions.add(api2);<br>        GatewayApiDefinitionManager.loadApiDefinitions(definitions);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-3-测试"><a href="#6-3-测试" class="headerlink" title="6.3 测试"></a>6.3 测试</h3><p>连续请求，查看效果如下</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-21.png"></p>]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos Config 服务配置</title>
    <link href="/2024/03/21/Nacos%20Config%20%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/03/21/Nacos%20Config%20%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos-Config-服务配置"><a href="#Nacos-Config-服务配置" class="headerlink" title="Nacos Config 服务配置"></a>Nacos Config 服务配置</h1><h2 id="1-服务配置中心"><a href="#1-服务配置中心" class="headerlink" title="1. 服务配置中心"></a>1. 服务配置中心</h2><p>问题</p><blockquote><ol><li>配置文件相对分散。在一个微服务架构下，配置文件会随着微服务的增多变的越来越多，而且分散<br>在各个微服务中，不好统一配置和管理。</li><li>配置文件无法区分环境。微服务项目可能会有多个环境，例如：测试环境、预发布环境、生产环<br>境。每一个环境所使用的配置理论上都是不同的，一旦需要修改，就需要我们去各个微服务下手动<br>维护，这比较困难。</li><li>配置文件无法实时更新。我们修改了配置文件之后，必须重新启动微服务才能使配置生效，这对一<br>个正在运行的项目来说是非常不友好的。</li></ol></blockquote><p>加入配置中心，系统架构图</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-4.png"></p><h2 id="2-Nacos-Config初配置"><a href="#2-Nacos-Config初配置" class="headerlink" title="2. Nacos Config初配置"></a>2. Nacos Config初配置</h2><p>使用nacos作为配置中心，其实就是将nacos当做一个服务端，将各个微服务看成是客户端，我们<br>将各个微服务的配置文件统一存放在nacos上，然后各个微服务从nacos上拉取配置即可。</p><h3 id="2-1-在微服务中引入nacos的依赖"><a href="#2-1-在微服务中引入nacos的依赖" class="headerlink" title="2.1 在微服务中引入nacos的依赖"></a>2.1 在微服务中引入nacos的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-在微服务中添加nacos-config的配置"><a href="#2-2-在微服务中添加nacos-config的配置" class="headerlink" title="2.2 在微服务中添加nacos config的配置"></a>2.2 在微服务中添加nacos config的配置</h3><blockquote><p><strong>注意:不能使用原来的application.yml作为配置文件，而是新建一个bootstrap.yml作为配置文件</strong></p><p>配置文件优先级(由高到低):<br>bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">@profileActive@</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-order-$&#123;spring.profiles.active&#125;</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#nacos中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure><h3 id="2-3-在nacos中添加配置"><a href="#2-3-在nacos中添加配置" class="headerlink" title="2.3 在nacos中添加配置"></a>2.3 在nacos中添加配置</h3><blockquote><p>点击配置列表，点击右边+号，新建配置。在新建配置过程中，要注意下面的细节：<br>1）Data ID不能随便写，要跟配置文件中的对应，对应关系如图所示<br>2）配置文件格式要跟配置文件的格式对应，且目前仅仅支持YAML和Properties<br>3）配置内容按照上面选定的格式书写</p></blockquote><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-5.png"></p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-6.png"></p><p>如下图，读取nacos配置，服务注册成功</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-7.png"></p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-8.png"></p><h2 id="3-Nacos-Config功能"><a href="#3-Nacos-Config功能" class="headerlink" title="3. Nacos Config功能"></a>3. Nacos Config功能</h2><h3 id="3-1-配置动态刷新"><a href="#3-1-配置动态刷新" class="headerlink" title="3.1 配置动态刷新"></a>3.1 配置动态刷新</h3><p>在nacos中的service-order-dev.yaml配置项中添加下面配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">config:</span><br><span class="hljs-attr">appName:</span> <span class="hljs-string">order</span><br></code></pre></td></tr></table></figure><p>方式一：硬编码方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.order.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.context.ConfigurableApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosConfigController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ConfigurableApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/nacos-config-test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfingTest1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getEnvironment().getProperty(<span class="hljs-string">&quot;config.appName&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式二: 注解方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RefreshScope</span> <span class="hljs-comment">//只需要在需要动态读取配置的类上添加此注解就可以</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-9.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;xxx&quot;)</span> <span class="hljs-comment">// 针对于复杂配置的使用，添加config配置类</span><br></code></pre></td></tr></table></figure><h3 id="3-2-配置共享"><a href="#3-2-配置共享" class="headerlink" title="3.2 配置共享"></a>3.2 配置共享</h3><ul><li><strong>同一个微服务的不同环境之间共享配置</strong></li></ul><blockquote><p>同一个微服务的不同环境之间实现配置共享,只需要提取一个以 spring.application.name 命名的配置文件，然后将其所有环境的公共配置放在里<br>面即可。</p></blockquote><p>例如：上面新建service-order-dev.yaml 为单独dev的配置，只需新增service-order.yaml配置文件，将公共模块添加进去。service-order-dev.yaml配置文件可单独添加所属环境的其他信息，service-order-sit.yaml同理</p><p>各环境配置文件可添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">config:</span><br><span class="hljs-attr">env:</span> <span class="hljs-string">dev/sit</span><br></code></pre></td></tr></table></figure><p>添加测试类进行验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.order.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.context.ConfigurableApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosConfigController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ConfigurableApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/nacos-config-test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfingTest1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getEnvironment().getProperty(<span class="hljs-string">&quot;config.appName&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;config.env&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String env;<br>    <span class="hljs-comment">// 同一微服务的不同环境下共享配置</span><br>    <span class="hljs-meta">@GetMapping(&quot;/nacos-config-test1&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">nacosConfingTest3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> env;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>不同微服务中间共享配置</strong></li></ul><blockquote><p>不同为服务之间实现配置共享的原理类似于文件引入，就是定义一个公共配置，然后在当前配置中引<br>入。</p></blockquote><p>1 在nacos中定义一个DataID为all-service.yaml的配置，用于所有微服务共享</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://150.158.79.228:3306/springcloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">113114Wtl.</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">include:</span> <span class="hljs-string">ribbon</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">hibernate:</span><br>        <span class="hljs-attr">hbm2ddl:</span><br>          <span class="hljs-attr">auto:</span> <span class="hljs-string">update</span><br>        <span class="hljs-attr">dialect:</span> <span class="hljs-string">org.hibernate.dialect.MySQL5InnoDBDialect</span><br></code></pre></td></tr></table></figure><p>2 在nacos的中修改service-product.yaml中为下面内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">config:</span><br><span class="hljs-attr">appName:</span> <span class="hljs-string">product</span><br></code></pre></td></tr></table></figure><p>3 修改bootstrap.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">@profileActive@</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-order-$&#123;spring.profiles.active&#125;</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#nacos中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 配置文件格式</span><br>        <span class="hljs-attr">shared-dataids:</span> <span class="hljs-string">all-service.yaml</span> <span class="hljs-comment"># 配置要引入的配置</span><br>        <span class="hljs-attr">refreshable-dataids:</span> <span class="hljs-string">all-service.yaml</span> <span class="hljs-comment"># 配置要实现动态配置刷新的配置</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure><p>4 启动商品微服务进行测试</p><h2 id="4-nacos概念"><a href="#4-nacos概念" class="headerlink" title="4. nacos概念"></a>4. nacos概念</h2><blockquote><p><strong>命名空间(Namespace)</strong><br>    命名空间可用于进行不同环境的配置隔离。一般一个环境划分到一个命名空间<br><strong>配置分组(Group)</strong><br>    配置分组用于将不同的服务可以归类到同一分组。一般将一个项目的配置分到一组<br><strong>配置集(Data ID)</strong><br>    在系统中，一个配置文件通常就是一个配置集。一般微服务的配置就是一个配置集</p></blockquote><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-10.png"></p>]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos Discovery 服务治理</title>
    <link href="/2024/03/20/Nacos%20Discovery%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <url>/2024/03/20/Nacos%20Discovery%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos-Discovery-服务治理"><a href="#Nacos-Discovery-服务治理" class="headerlink" title="Nacos Discovery 服务治理"></a>Nacos Discovery 服务治理</h1><h2 id="1-服务治理"><a href="#1-服务治理" class="headerlink" title="1. 服务治理"></a>1. 服务治理</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为解决网络地址硬编码所带来的问题：</p><ul><li><p>一旦服务提供者地址变化，就需要手工修改代码</p></li><li><p>一旦是多个服务提供者，无法实现负载均衡功能</p></li><li><p>一旦服务变得越来越多，人工维护调用关系困难</p></li></ul><p>通过注册中心动态的实现<strong>服务治理</strong></p><h3 id="什么是服务治理"><a href="#什么是服务治理" class="headerlink" title="什么是服务治理"></a>什么是服务治理</h3><p>服务治理是微服务架构中最核心最基本的模块。用于实现各个微服务的自动化注册与发现。</p><ul><li><p>服务注册：在服务治理框架中，都会构建一个注册中心，每个服务单元向注册中心登记自己提供服<br>务的详细信息。并在注册中心形成一张服务的清单，服务注册中心需要以心跳的方式去监测清单中<br>的服务是否可用，如果不可用，需要在服务清单中剔除不可用的服务。</p></li><li><p>服务发现：服务调用方向服务注册中心咨询服务，并获取所有服务的实例清单，实现对具体服务实<br>例的访问。</p></li></ul><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-1.png"></p><p>通过上面的调用图会发现，除了微服务，还有一个组件是服务注册中心，它是微服务架构非常重要<br>的一个组件，在微服务架构里主要起到了协调者的一个作用。注册中心一般包含如下几个功能：</p><ol><li>服务发现：<br>服务注册：保存服务提供者和服务调用者的信息<br>服务订阅：服务调用者订阅服务提供者的信息，注册中心向订阅者推送提供者的信息</li><li>服务配置：<br>配置订阅：服务提供者和服务调用者订阅微服务相关的配置<br>配置下发：主动将配置推送给服务提供者和服务调用者</li><li>服务健康检测<br>检测服务提供者的健康情况，如果发现异常，执行服务剔除</li></ol><h2 id="2-Nacos"><a href="#2-Nacos" class="headerlink" title="2. Nacos"></a>2. Nacos</h2><h3 id="2-1-搭建nacos环境"><a href="#2-1-搭建nacos环境" class="headerlink" title="2.1 搭建nacos环境"></a>2.1 搭建nacos环境</h3><p>第1步：安装nacos</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name nacos-server -p 8848:8848 -p 9848:9848 -e MODE=standalone -e JVM_XMS=512m -e JVM_XMX=512m -e SPRING_DATASOURCE_PLATFORM=mysql -e MYSQL_SERVICE_HOST=150.158.79.228 -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_DB_NAME=nacos_config -e MYSQL_SERVICE_USER=root -e MYSQL_SERVICE_PASSWORD=113114Wtl. -v /opt/nacos/logs:/home/nacos/logs nacos/nacos-server:v2.2.3<br></code></pre></td></tr></table></figure><p>可访问官方文档，自行查阅，需要创建nacos数据库，docker run时指定</p><p>第2步：访问nacos</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-2.png"></p><h3 id="2-2-将商品微服务注册到nacos"><a href="#2-2-将商品微服务注册到nacos" class="headerlink" title="2.2 将商品微服务注册到nacos"></a>2.2 将商品微服务注册到nacos</h3><p>接下来开始修改 shop-product 模块的代码， 将其注册到nacos服务上</p><ul><li><p>在pom.xml中添加nacos的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos客户端--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sp<br></code></pre></td></tr></table></figure></li><li><p>在主类上添加**<code>@EnableDiscoveryClient</code>**注解</p></li><li><p>在application.yml中添加nacos服务的地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure></li><li><p>启动服务， 观察nacos的控制面板中是否有注册上来的商品微服务,订单微服务同理</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-nacos-3.png"></p></li></ul><h2 id="3-实现服务调用的负载均衡"><a href="#3-实现服务调用的负载均衡" class="headerlink" title="3. 实现服务调用的负载均衡"></a>3. 实现服务调用的负载均衡</h2><h3 id="3-1-自定义实现负载均衡"><a href="#3-1-自定义实现负载均衡" class="headerlink" title="3.1 自定义实现负载均衡"></a>3.1 自定义实现负载均衡</h3><ul><li><p>通过idea再启动一个 shop-product 微服务，设置其端口为8082</p></li><li><p>通过nacos查看微服务的启动情况</p></li><li><p>修改 shop-order 的代码，实现负载均衡</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义负载均衡</span><br>    <span class="hljs-meta">@GetMapping(&quot;/order/loadBalancing-prod/&#123;pid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrderByloadBalancing</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;pid&quot;)</span> Integer pid)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);<br>        <span class="hljs-comment">// 从nacos中获取服务地址</span><br>        <span class="hljs-comment">// 自定义规则实现随机挑选服务</span><br>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">&quot;serviceproduct&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(instances.size());<br>        <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> instances.get(index);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> serviceInstance.getHost() + <span class="hljs-string">&quot;:&quot;</span> +<br>                serviceInstance.getPort();<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;从nacos中获取到的微服务地址为:&quot;</span> + url);<br>        <span class="hljs-comment">// 通过restTemplate调用商品微服务</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://&quot;</span> + url +<br>                <span class="hljs-string">&quot;/product/&quot;</span> + pid, Product.class);<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;商品信息，查询结果:&quot;</span> + JSON.toJSONString(product));<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setUid(<span class="hljs-number">1</span>);<br>        order.setUsername(<span class="hljs-string">&quot;测试用户&quot;</span>);<br>        order.setPid(product.getPid());<br>        order.setPname(product.getPname());<br>        order.setPprice(product.getPprice());<br>        order.setNumber(<span class="hljs-number">1</span>);<br>        orderService.save(order);<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-2-基于Ribbon实现负载均衡"><a href="#3-2-基于Ribbon实现负载均衡" class="headerlink" title="3.2 基于Ribbon实现负载均衡"></a>3.2 基于Ribbon实现负载均衡</h3><blockquote><p><strong>Ribbon是Spring Cloud的一个组件， 它可以让我们使用一个注解就能轻松的搞定负载均衡</strong></p></blockquote><ul><li>在RestTemplate 的生成方法上添加@LoadBalanced注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.order;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.domain.EntityScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.client.RestTemplateBuilder;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EntityScan(basePackages = &quot;com.along.common.entity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// Ribbon实现负载均衡注解</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">(RestTemplateBuilder builder)</span> &#123;<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>修改服务调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/order/ribbon-prod/&#123;pid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrderByRibbon</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;pid&quot;)</span> Integer pid)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);<br>        <span class="hljs-comment">// 直接使用微服务名字， 从nacos中获取服务地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;service-product&quot;</span>;<br>        <span class="hljs-comment">// 通过restTemplate调用商品微服务</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<br>                <span class="hljs-string">&quot;http://&quot;</span> + url + <span class="hljs-string">&quot;/product/&quot;</span> + pid, Product.class);<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;商品信息，查询结果:&quot;</span> + JSON.toJSONString(product));<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setUid(<span class="hljs-number">1</span>);<br>        order.setUsername(<span class="hljs-string">&quot;测试用户&quot;</span>);<br>        order.setPid(product.getPid());<br>        order.setPname(product.getPname());<br>        order.setPprice(product.getPprice());<br>        order.setNumber(<span class="hljs-number">1</span>);<br>        orderService.save(order);<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>Ribbon支持的负载均衡策略<br>Ribbon内置了多种负载均衡策略,内部负载均衡的顶级接口:com.netflix.loadbalancer.IRule , 具体的负载策略如下图所示:</p></blockquote><table><thead><tr><th>策略名</th><th>策略描述</th><th>实现说明</th></tr></thead><tbody><tr><td>BestAvailableRule</td><td>选择一个最小的并发请求的server</td><td>逐个考察Server，如果Server被<br/>tripped了，则忽略，在选择其中<br/>ActiveRequestsCount最小的server</td></tr><tr><td>AvailabilityFilteringRule</td><td>过滤掉那些因为一直<br/>连接失败的被标记为<br/>circuit tripped的后<br/>端server，并过滤掉<br/>那些高并发的的后端<br/>server（active<br/>connections 超过配<br/>置的阈值）</td><td>使用一个AvailabilityPredicate来包含<br/>过滤server的逻辑，其实就就是检查<br/>status里记录的各个server的运行状<br/>态</td></tr><tr><td>WeightedResponseTimeRule</td><td>根据相应时间分配一<br/>个weight，相应时<br/>间越长，weight越<br/>小，被选中的可能性<br/>越低。</td><td>一个后台线程定期的从status里面读<br/>取评价响应时间，为每个server计算<br/>一个weight。Weight的计算也比较简<br/>单responsetime 减去每个server自己<br/>平均的responsetime是server的权<br/>重。当刚开始运行，没有形成statas<br/>时，使用roubine策略选择server。</td></tr><tr><td>RetryRule</td><td>对选定的负载均衡策<br/>略机上重试机制。</td><td>在一个配置时间段内当选择server不<br/>成功，则一直尝试使用subRule的方<br/>式选择一个可用的server</td></tr><tr><td>RoundRobinRule</td><td>轮询方式轮询选择<br/>server</td><td>轮询index，选择index对应位置的<br/>server</td></tr><tr><td>RandomRule</td><td>随机选择一个server</td><td>在index上随机，选择index对应位置<br/>的server</td></tr><tr><td>ZoneAvoidanceRule</td><td>复合判断server所在<br/>区域的性能和server<br/>的可用性选择server</td><td>使用ZoneAvoidancePredicate和<br/>AvailabilityPredicate来判断是否选择<br/>某个server，前一个判断判定一个<br/>zone的运行性能是否可用，剔除不可<br/>用的zone（的所有server），<br/>AvailabilityPredicate用于过滤掉连接<br/>数过多的Server。</td></tr></tbody></table><p>我们可以通过修改配置来调整Ribbon的负载均衡策略，具体代码如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">service-product:</span> <span class="hljs-comment"># 调用的提供者的名称</span><br><span class="hljs-attr">ribbon:</span><br><span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span><br></code></pre></td></tr></table></figure><h3 id="3-3-基于Feign实现服务调用"><a href="#3-3-基于Feign实现服务调用" class="headerlink" title="3.3 基于Feign实现服务调用"></a>3.3 基于Feign实现服务调用</h3><h4 id="3-3-1-Feign"><a href="#3-3-1-Feign" class="headerlink" title="3.3.1 Feign"></a>3.3.1 Feign</h4><blockquote><p>Feign是Spring Cloud提供的一个声明式的伪Http客户端， 它使得调用远程服务就像调用本地服务<br>一样简单， 只需要创建一个接口并添加一个注解即可。<br>Nacos很好的兼容了Feign， Feign默认集成了 Ribbon， 所以在Nacos下使用Fegin默认就实现了负<br>载均衡的效果。</p></blockquote><h4 id="3-3-2-Feign的使用"><a href="#3-3-2-Feign的使用" class="headerlink" title="3.3.2 Feign的使用"></a>3.3.2 Feign的使用</h4><ul><li><p>加入Fegin的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--fegin组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在主类上添加Fegin的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.order;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.domain.EntityScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.web.client.RestTemplateBuilder;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EntityScan(basePackages = &quot;com.along.common.entity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderApplication</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// Ribbon实现负载均衡注解</span><br>    <span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">(RestTemplateBuilder builder)</span> &#123;<br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(OrderApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个service， 并使用Fegin实现微服务调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.order.service;<br><br><span class="hljs-keyword">import</span> com.along.common.entity.Product;<br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> Feign创建一个接口实现其他服务接口的调用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@FeignClient(&quot;service-product-$&#123;spring.profiles.active&#125;&quot;)</span> <span class="hljs-comment">// 声明调用的提供者的name</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductService</span> &#123;<br><br>    <span class="hljs-comment">// 指定调用提供者的哪个方法</span><br>    <span class="hljs-comment">// @FeignClient+@GetMapping 就是一个完整的请求路径 http://service-product/product/&#123;pid&#125;</span><br>    <span class="hljs-meta">@GetMapping(value = &quot;/product/&#123;pid&#125;&quot;)</span><br>    Product <span class="hljs-title function_">findByPid</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;pid&quot;)</span> Integer pid)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改controller代码，并启动验证</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// feign调用</span><br>    <span class="hljs-meta">@GetMapping(&quot;/order/feign-prod/&#123;pid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">getOrderByFeign</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;pid&quot;)</span> Integer pid)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;客户下单,这时候要调用商品微服务查询商品信息&quot;</span>);<br>        <span class="hljs-comment">// 通过fegin调用商品微服务</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productService.findByPid(pid);<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setUid(<span class="hljs-number">1</span>);<br>        order.setUsername(<span class="hljs-string">&quot;测试用户&quot;</span>);<br>        order.setPid(product.getPid());<br>        order.setPname(product.getPname());<br>        order.setPprice(product.getPprice());<br>        order.setNumber(<span class="hljs-number">1</span>);<br>        orderService.save(order);<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>重启order微服务和product微服务,查看效果</li></ul>]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务环境搭建</title>
    <link href="/2024/03/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/03/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务环境搭建"><a href="#微服务环境搭建" class="headerlink" title="微服务环境搭建"></a>微服务环境搭建</h1><h2 id="1-1-创建父工程"><a href="#1-1-创建父工程" class="headerlink" title="1.1 创建父工程"></a>1.1 创建父工程</h2><p>创建一个maven工程，然后在pom.xml文件中添加下面内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-along<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>shop-common<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>shop-user<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>shop_product<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>shop-order<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>api-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Greenwich.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.13.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;resource&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                &lt;directory&gt;src/main/resources&lt;/directory&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                &amp;lt;!&amp;ndash; 处理文件时替换文件中的变量 &amp;ndash;&amp;gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                &lt;filtering&gt;true&lt;/filtering&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                &lt;excludes&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                    &amp;lt;!&amp;ndash; 打包时排除文件，可自行添加test.yml &amp;ndash;&amp;gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                    &lt;exclude&gt;bootstrap.yml&lt;/exclude&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                    &lt;exclude&gt;bootstrap-dev.yml&lt;/exclude&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--                &lt;/excludes&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;/resource&gt;--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">profileActive</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">profileActive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>sit<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">profileActive</span>&gt;</span>sit<span class="hljs-tag">&lt;/<span class="hljs-name">profileActive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>uat<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">profileActive</span>&gt;</span>uat<span class="hljs-tag">&lt;/<span class="hljs-name">profileActive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>pre<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">profileActive</span>&gt;</span>pre<span class="hljs-tag">&lt;/<span class="hljs-name">profileActive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">profileActive</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">profileActive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-1-创建基础模块"><a href="#2-1-创建基础模块" class="headerlink" title="2.1 创建基础模块"></a>2.1 创建基础模块</h2><ul><li>创建 shop-common 模块，在pom.xml中添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-along<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.common.entity;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.GenerationType;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 用户实体</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Entity(name = &quot;shop_user&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Integer uid;<span class="hljs-comment">//主键</span><br>    <span class="hljs-keyword">private</span> String username;<span class="hljs-comment">//用户名</span><br>    <span class="hljs-keyword">private</span> String password;<span class="hljs-comment">//密码</span><br>    <span class="hljs-keyword">private</span> String telephone;<span class="hljs-comment">//手机号</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.common.entity;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.GenerationType;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 用户实体</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Entity(name = &quot;shop_product&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Integer pid;<span class="hljs-comment">//主键</span><br>    <span class="hljs-keyword">private</span> String pname;<span class="hljs-comment">//商品名称</span><br>    <span class="hljs-keyword">private</span> Double pprice;<span class="hljs-comment">//商品价格</span><br>    <span class="hljs-keyword">private</span> Integer stock;<span class="hljs-comment">//库存</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.common.entity;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.GenerationType;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 订单实体类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Entity(name = &quot;shop_order&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br>    <span class="hljs-keyword">private</span> Long oid;<span class="hljs-comment">//订单id</span><br>    <span class="hljs-keyword">private</span> Integer uid;<span class="hljs-comment">//用户id</span><br>    <span class="hljs-keyword">private</span> String username;<span class="hljs-comment">//用户名</span><br>    <span class="hljs-keyword">private</span> Integer pid;<span class="hljs-comment">//商品id</span><br>    <span class="hljs-keyword">private</span> String pname;<span class="hljs-comment">//商品名称</span><br>    <span class="hljs-keyword">private</span> Double pprice;<span class="hljs-comment">//商品单价</span><br>    <span class="hljs-keyword">private</span> Integer number;<span class="hljs-comment">//购买数量</span><br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-2-创建用户微服务"><a href="#2-2-创建用户微服务" class="headerlink" title="2.2 创建用户微服务"></a>2.2 创建用户微服务</h2><p>步骤:<br>1 创建模块 导入依赖<br>2 创建SpringBoot主类<br>3 加入配置文件<br>4 创建必要的接口和实现类(controller service dao)<br>新建一个 shop-user 模块，然后进行下面操作</p><ul><li>创建pom.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-along<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shop-user<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>编写主类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.user;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(UserApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>创建配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8071</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-product</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://150.158.79.228:3306/springcloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">113114Wtl.</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">hibernate:</span><br>        <span class="hljs-attr">hbm2ddl:</span><br>          <span class="hljs-attr">auto:</span> <span class="hljs-string">update</span><br>        <span class="hljs-attr">dialect:</span> <span class="hljs-string">org.hibernate.dialect.MySQL5InnoDBDialect</span><br></code></pre></td></tr></table></figure><h2 id="2-3-创建商品微服务"><a href="#2-3-创建商品微服务" class="headerlink" title="2.3 创建商品微服务"></a>2.3 创建商品微服务</h2><ul><li><p>创建一个名为 shop_product 的模块，并添加springboot依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0</span></span><br><span class="hljs-string"><span class="hljs-tag">http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springcloud-along<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shop-product<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--nacos客户端--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.along<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shop-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建工程的主类</p></li><li><p>创建配置文件application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">@profileActive@</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">service-product-$&#123;spring.profiles.active&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://150.158.79.228:3306/springcloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">113114Wtl.</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">150.158</span><span class="hljs-number">.79</span><span class="hljs-number">.228</span><span class="hljs-string">:8848</span><br>  <span class="hljs-attr">jpa:</span><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">hibernate:</span><br>        <span class="hljs-attr">hbm2ddl:</span><br>          <span class="hljs-attr">auto:</span> <span class="hljs-string">update</span><br>        <span class="hljs-attr">dialect:</span> <span class="hljs-string">org.hibernate.dialect.MySQL5InnoDBDialect</span><br></code></pre></td></tr></table></figure></li><li><p>创建ProductDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.product.dao;<br><br><span class="hljs-keyword">import</span> com.along.common.entity.Product;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;Product, Integer&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建ProductService接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.product.service;<br><br><span class="hljs-keyword">import</span> com.along.common.entity.Product;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductService</span> &#123;<br><br>    Product <span class="hljs-title function_">findByPid</span><span class="hljs-params">(Integer pid)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.product.service.impl;<br><br><span class="hljs-keyword">import</span> com.along.common.entity.Product;<br><span class="hljs-keyword">import</span> com.along.product.dao.ProductDao;<br><span class="hljs-keyword">import</span> com.along.product.service.ProductService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProductService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductDao productDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">findByPid</span><span class="hljs-params">(Integer pid)</span> &#123;<br>        <span class="hljs-keyword">return</span> productDao.findById(pid).get();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.along.product.controller;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.along.common.entity.Product;<br><span class="hljs-keyword">import</span> com.along.product.service.ProductService;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductService productService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/product/&#123;pid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">product</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;pid&quot;)</span> Integer pid)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productService.findByPid(pid);<br>        log.info(<span class="hljs-string">&quot;查询到商品:&quot;</span> + JSON.toJSONString(product));<br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>启动工程，等到数据库表创建完毕之后，加入测试数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO shop_product VALUE(NULL,&#x27;小米&#x27;,&#x27;1000&#x27;,&#x27;5000&#x27;);<br>INSERT INTO shop_product VALUE(NULL,&#x27;华为&#x27;,&#x27;2000&#x27;,&#x27;5000&#x27;);<br>INSERT INTO shop_product VALUE(NULL,&#x27;苹果&#x27;,&#x27;3000&#x27;,&#x27;5000&#x27;);<br>INSERT INTO shop_product VALUE(NULL,&#x27;OPPO&#x27;,&#x27;4000&#x27;,&#x27;5000&#x27;);<br></code></pre></td></tr></table></figure></li><li><p>通过浏览器访问服务</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/springcloud-service-product-1.png"></p></li></ul><h2 id="2-4-创建订单微服务"><a href="#2-4-创建订单微服务" class="headerlink" title="2.4 创建订单微服务"></a>2.4 创建订单微服务</h2><p>前置同理，省略</p><ul><li><p>创建Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 准备买1件商品</span><br>    <span class="hljs-meta">@GetMapping(&quot;/order/prod/&#123;pid&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Order <span class="hljs-title function_">order</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;pid&quot;)</span> Integer pid)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;客户下单，这时候要调用商品微服务查询商品信息&quot;</span>);<br>        <span class="hljs-comment">// 通过restTemplate调用商品微服务</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8081/product/&quot;</span> + pid, Product.class);<br>        log.info(<span class="hljs-string">&quot;&gt;&gt;商品信息,查询结果:&quot;</span> + JSON.toJSONString(product));<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>();<br>        order.setUid(<span class="hljs-number">1</span>);<br>        order.setUsername(<span class="hljs-string">&quot;测试用户&quot;</span>);<br>        order.setPid(product.getPid());<br>        order.setPname(product.getPname());<br>        order.setPprice(product.getPprice());<br>        order.setNumber(<span class="hljs-number">1</span>);<br>        orderService.save(order);<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>启动工程,通过浏览器访问服务进行测试 localhost:8091/order/prod/1</p></li></ul><p>源码地址：<a href="https://github.com/oCo0c0/springcloud-along">https://github.com/oCo0c0/springcloud-along</a></p>]]></content>
    
    
    <categories>
      
      <category>&lt;微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务 springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes命令</title>
    <link href="/2024/03/10/Kubernetes%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/03/10/Kubernetes%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="集群信息："><a href="#集群信息：" class="headerlink" title="集群信息："></a><strong>集群信息：</strong></h3><ol><li>显示 Kubernetes 版本：<code>kubectl version</code></li><li>显示集群信息：<code>kubectl cluster-info</code></li><li>列出集群中的所有节点：<code>kubectl get nodes</code></li><li>查看一个具体的节点详情：<code>kubectl describe node &lt;node-name&gt;</code></li><li>列出所有命名空间：<code>kubectl get namespaces</code></li><li>列出所有命名空间中的所有 pod：<code>kubectl get pods --all-namespaces</code></li></ol><h3 id="Pod-诊断："><a href="#Pod-诊断：" class="headerlink" title="Pod 诊断："></a><strong>Pod 诊断：</strong></h3><ol><li>列出特定命名空间中的 pod：<code>kubectl get pods -n &lt;namespace&gt;</code></li><li>查看一个 Pod 详情：<code>kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>查看 Pod 日志：<code>kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>尾部 Pod 日志：<code>kubectl logs -f &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>在 pod 中执行命令：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- &lt;command&gt;</code></li></ol><h3 id="Pod-健康检查："><a href="#Pod-健康检查：" class="headerlink" title="Pod 健康检查："></a><strong>Pod 健康检查：</strong></h3><ol><li>检查 Pod 准备情况：<code>kubectl get pods &lt;pod-name&gt; -n &lt;namespace&gt; -o jsonpath=&#39;&#123;.status.conditions[?(@.type==&quot;Ready&quot;)].status&#125;&#39;</code></li><li>检查 Pod 事件：<code>kubectl get events -n &lt;namespace&gt; --field-selector involvedObject.name=&lt;pod-name&gt;</code></li></ol><h3 id="Service诊断："><a href="#Service诊断：" class="headerlink" title="Service诊断："></a><strong>Service诊断：</strong></h3><ol><li>列出命名空间中的所有服务：<code>kubectl get svc -n &lt;namespace&gt;</code></li><li>查看一个服务详情：<code>kubectl describe svc &lt;service-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="Deployment诊断："><a href="#Deployment诊断：" class="headerlink" title="Deployment诊断："></a><strong>Deployment诊断：</strong></h3><ol><li>列出命名空间中的所有Deployment：<code>kubectl get deployments -n &lt;namespace&gt;</code></li><li>查看一个Deployment详情：<code>kubectl describe deployment &lt;deployment-name&gt; -n &lt;namespace&gt;</code></li><li>查看滚动发布状态：<code>kubectl rollout status deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</code></li><li>查看滚动发布历史记录：<code>kubectl rollout history deployment/&lt;deployment-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="StatefulSet诊断："><a href="#StatefulSet诊断：" class="headerlink" title="StatefulSet诊断："></a><strong>StatefulSet诊断：</strong></h3><ol><li>列出命名空间中的所有 StatefulSet：<code>kubectl get statefulsets -n &lt;namespace&gt;</code></li><li>查看一个 StatefulSet详情：<code>kubectl describe statefulset &lt;statefulset-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="ConfigMap-和Secret诊断："><a href="#ConfigMap-和Secret诊断：" class="headerlink" title="ConfigMap 和Secret诊断："></a><strong>ConfigMap 和Secret诊断：</strong></h3><ol><li>列出命名空间中的 ConfigMap：<code>kubectl get configmaps -n &lt;namespace&gt;</code></li><li>查看一个ConfigMap详情：<code>kubectl describe configmap &lt;configmap-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的 Secret：<code>kubectl get secrets -n &lt;namespace&gt;</code></li><li>查看一个Secret详情：<code>kubectl describe secret &lt;secret-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="命名空间诊断："><a href="#命名空间诊断：" class="headerlink" title="命名空间诊断："></a><strong>命名空间诊断：</strong></h3><ol><li>查看一个命名空间详情：<code>kubectl describe namespace &lt;namespace-name&gt;</code></li></ol><h3 id="资源使用情况："><a href="#资源使用情况：" class="headerlink" title="资源使用情况："></a><strong>资源使用情况：</strong></h3><ol><li>检查 pod 的资源使用情况：<code>kubectl top pod &lt;pod-name&gt; -n &lt;namespace&gt;</code></li><li>检查节点资源使用情况：<code>kubectl top nodes</code></li></ol><h3 id="网络诊断："><a href="#网络诊断：" class="headerlink" title="网络诊断："></a><strong>网络诊断：</strong></h3><ol><li>显示命名空间中 Pod 的 IP 地址：<code>kubectl get pods -n &lt;namespace&gt; -o custom-columns=POD:metadata.name,IP:status.podIP --no-headers</code></li><li>列出命名空间中的所有网络策略：<code>kubectl get networkpolicies -n &lt;namespace&gt;</code></li><li>查看一个网络策略详情：<code>kubectl describe networkpolicy &lt;network-policy-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="持久卷-PV-和持久卷声明-PVC-诊断："><a href="#持久卷-PV-和持久卷声明-PVC-诊断：" class="headerlink" title="持久卷 (PV) 和持久卷声明 (PVC) 诊断："></a><strong>持久卷 (PV) 和持久卷声明 (PVC) 诊断：</strong></h3><ol><li>列出PV：<code>kubectl get pv</code></li><li>查看一个PV详情：<code>kubectl describe pv &lt;pv-name&gt;</code></li><li>列出命名空间中的 PVC：<code>kubectl get pvc -n &lt;namespace&gt;</code></li><li>查看PVC详情：<code>kubectl describe pvc &lt;pvc-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="节点诊断："><a href="#节点诊断：" class="headerlink" title="节点诊断："></a><strong>节点诊断：</strong></h3><ol><li>获取特定节点上运行的 Pod 列表：<code>kubectl get pods --field-selector spec.nodeName=&lt;node-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源配额和限制："><a href="#资源配额和限制：" class="headerlink" title="资源配额和限制："></a><strong>资源配额和限制：</strong></h3><ol><li>列出命名空间中的资源配额：<code>kubectl get resourcequotas -n &lt;namespace&gt;</code></li><li>查看一个资源配额详情：<code>kubectl describe resourcequota &lt;resource-quota-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="自定义资源定义-CRD-诊断："><a href="#自定义资源定义-CRD-诊断：" class="headerlink" title="自定义资源定义 (CRD) 诊断："></a><strong>自定义资源定义 (CRD) 诊断：</strong></h3><ol><li>列出命名空间中的自定义资源：<code>kubectl get &lt;custom-resource-name&gt; -n &lt;namespace&gt;</code></li><li>查看自定义资源详情：<code>kubectl describe &lt;custom-resource-name&gt; &lt;custom-resource-instance-name&gt; -n &lt;namespace&gt;</code></li></ol><p>使用这些命令时，请记住将<code>&lt;namespace&gt;</code>, <code>&lt;pod-name&gt;</code>, <code>&lt;service-name&gt;</code>, <code>&lt;deployment-name&gt;</code>, <code>&lt;statefulset-name&gt;</code>, <code>&lt;configmap-name&gt;</code>, <code>&lt;secret-name&gt;</code>, <code>&lt;namespace-name&gt;</code>, <code>&lt;pv-name&gt;</code>, <code>&lt;pvc-name&gt;</code>, <code>&lt;node-name&gt;</code>, <code>&lt;network-policy-name&gt;</code>, <code>&lt;resource-quota-name&gt;</code>, <code>&lt;custom-resource-name&gt;</code>, 和替换为你的特定值。</p><p><code>&lt;custom-resource-instance-name&gt;</code>这些命令应该可以帮助你诊断 Kubernetes 集群以及在其中运行的应用程序。</p><h3 id="资源伸缩和自动伸缩"><a href="#资源伸缩和自动伸缩" class="headerlink" title="资源伸缩和自动伸缩"></a><strong>资源伸缩和自动伸缩</strong></h3><ol><li>Deployment伸缩：<code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replica-count&gt; -n &lt;namespace&gt;</code></li><li>设置Deployment的自动伸缩：<code>kubectl autoscale deployment &lt;deployment-name&gt; --min=&lt;min-pods&gt; --max=&lt;max-pods&gt; --cpu-percent=&lt;cpu-percent&gt; -n &lt;namespace&gt;</code></li><li>检查水平伸缩器状态：<code>kubectl get hpa -n &lt;namespace&gt;</code></li></ol><h3 id="作业和-CronJob-诊断："><a href="#作业和-CronJob-诊断：" class="headerlink" title="作业和 CronJob 诊断："></a><strong>作业和 CronJob 诊断：</strong></h3><ol><li>列出命名空间中的所有作业：<code>kubectl get jobs -n &lt;namespace&gt;</code></li><li>查看一份工作详情：<code>kubectl describe job &lt;job-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的所有 cron 作业：<code>kubectl get cronjobs -n &lt;namespace&gt;</code></li><li>查看一个 cron 作业详情：<code>kubectl describe cronjob &lt;cronjob-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="容量诊断："><a href="#容量诊断：" class="headerlink" title="容量诊断："></a><strong>容量诊断：</strong></h3><ol><li>列出按容量排序的持久卷 (PV)：<code>kubectl get pv --sort-by=.spec.capacity.storage</code></li><li>查看PV回收策略：<code>kubectl get pv &lt;pv-name&gt; -o=jsonpath=&#39;&#123;.spec.persistentVolumeReclaimPolicy&#125;&#39;</code></li><li>列出所有存储类别：<code>kubectl get storageclasses</code></li></ol><h3 id="Ingress和服务网格诊断："><a href="#Ingress和服务网格诊断：" class="headerlink" title="Ingress和服务网格诊断："></a><strong>Ingress和服务网格诊断：</strong></h3><ol><li>列出命名空间中的所有Ingress：<code>kubectl get ingress -n &lt;namespace&gt;</code></li><li>查看一个Ingress详情：<code>kubectl describe ingress &lt;ingress-name&gt; -n &lt;namespace&gt;</code></li><li>列出命名空间中的所有 VirtualServices (Istio)：<code>kubectl get virtualservices -n &lt;namespace&gt;</code></li><li>查看一个 VirtualService (Istio)详情：<code>kubectl describe virtualservice &lt;virtualservice-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="Pod-网络故障排除："><a href="#Pod-网络故障排除：" class="headerlink" title="Pod 网络故障排除："></a><strong>Pod 网络故障排除：</strong></h3><ol><li>运行网络诊断 Pod（例如 busybox）进行调试：<code>kubectl run -it --rm --restart=Never --image=busybox net-debug-pod -- /bin/sh</code></li><li>测试从 Pod 到特定端点的连接：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- curl &lt;endpoint-url&gt;</code></li><li>跟踪从一个 Pod 到另一个 Pod 的网络路径：<code>kubectl exec -it &lt;source-pod-name&gt; -n &lt;namespace&gt; -- traceroute &lt;destination-pod-ip&gt;</code></li><li>检查 Pod 的 DNS 解析：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- nslookup &lt;domain-name&gt;</code></li></ol><h3 id="配置和资源验证："><a href="#配置和资源验证：" class="headerlink" title="配置和资源验证："></a><strong>配</strong>置和资源验证：</h3><ol><li>验证 Kubernetes YAML 文件而不应用它：<code>kubectl apply --dry-run=client -f &lt;yaml-file&gt;</code></li><li>验证 pod 的安全上下文和功能：<code>kubectl auth can-i list pods --as=system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccount-name&gt;</code></li></ol><h3 id="RBAC-和安全性："><a href="#RBAC-和安全性：" class="headerlink" title="RBAC 和安全性："></a><strong>RBAC 和安全性：</strong></h3><ol><li>列出命名空间中的角色和角色绑定：<code>kubectl get roles,rolebindings -n &lt;namespace&gt;</code></li><li>查看角色或角色绑定详情：<code>kubectl describe role &lt;role-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="服务帐户诊断："><a href="#服务帐户诊断：" class="headerlink" title="服务帐户诊断："></a><strong>服务帐户诊断：</strong></h3><ol><li>列出命名空间中的服务帐户：<code>kubectl get serviceaccounts -n &lt;namespace&gt;</code></li><li>查看一个服务帐户详情：<code>kubectl describe serviceaccount &lt;serviceaccount-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="清空节点和解除封锁："><a href="#清空节点和解除封锁：" class="headerlink" title="清空节点和解除封锁："></a><strong>清空节点和解除封锁：</strong></h3><ol><li>清空节点以进行维护：<code>kubectl drain &lt;node-name&gt; --ignore-daemonsets</code></li><li>解除对节点的封锁：<code>kubectl uncordon &lt;node-name&gt;</code></li></ol><h3 id="资源清理："><a href="#资源清理：" class="headerlink" title="资源清理："></a><strong>资源清理：</strong></h3><ol><li>强制删除 pod（不推荐）：<code>kubectl delete pod &lt;pod-name&gt; -n &lt;namespace&gt; --grace-period=0 --force</code></li></ol><h3 id="Pod-亲和性和反亲和性："><a href="#Pod-亲和性和反亲和性：" class="headerlink" title="Pod 亲和性和反亲和性："></a><strong>Pod 亲和性和反亲和性：</strong></h3><ol><li>列出 pod 的 pod 亲和性规则：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.affinity&#125;&#39;</code></li><li>列出 pod 的 pod 反亲和性规则：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.affinity.podAntiAffinity&#125;&#39;</code></li></ol><h3 id="Pod-安全策略-PSP-："><a href="#Pod-安全策略-PSP-：" class="headerlink" title="Pod 安全策略 (PSP)："></a><strong>Pod 安全策略 (PSP)：</strong></h3><ol><li>列出所有 Pod 安全策略（如果启用）：<code>kubectl get psp</code></li></ol><h3 id="事件："><a href="#事件：" class="headerlink" title="事件："></a><strong>事件：</strong></h3><ol><li>查看最近的集群事件：<code>kubectl get events --sort-by=.metadata.creationTimestamp</code></li><li>按特定命名空间过滤事件：<code>kubectl get events -n &lt;namespace&gt;</code></li></ol><h3 id="节点故障排除："><a href="#节点故障排除：" class="headerlink" title="节点故障排除："></a><strong>节点故障排除：</strong></h3><ol><li>检查节点情况：<code>kubectl describe node &lt;node-name&gt; | grep Conditions -A5</code></li><li>列出节点容量和可分配资源：<code>kubectl describe node &lt;node-name&gt; | grep -E &quot;Capacity|Allocatable&quot;</code></li></ol><h3 id="临时容器（Kubernetes-1-18-）："><a href="#临时容器（Kubernetes-1-18-）：" class="headerlink" title="临时容器（Kubernetes 1.18+）："></a><strong>临时容器（Kubernetes 1.18+）：</strong></h3><ol><li>运行临时调试容器：<code>kubectl debug -it &lt;pod-name&gt; -n &lt;namespace&gt; --image=&lt;debug-image&gt; -- /bin/sh</code></li></ol><h3 id="资源指标（需要指标服务器）："><a href="#资源指标（需要指标服务器）：" class="headerlink" title="资源指标（需要指标服务器）："></a><strong>资源指标（需要指标服务器）：</strong></h3><ol><li>获取 Pod 的 CPU 和内存使用情况：<code>kubectl top pod -n &lt;namespace&gt;</code></li></ol><h3 id="kuelet诊断："><a href="#kuelet诊断：" class="headerlink" title="kuelet诊断："></a><strong>kuelet诊断：</strong></h3><ol><li>查看节点上的kubelet日志：<code>kubectl logs -n kube-system kubelet-&lt;node-name&gt;</code></li></ol><h3 id="使用Telepresence-进行高级调试："><a href="#使用Telepresence-进行高级调试：" class="headerlink" title="使用Telepresence 进行高级调试："></a><strong>使用Telepresence 进行高级调试：</strong></h3><ol><li>使用 Telepresence 调试 pod：<code>telepresence --namespace &lt;namespace&gt; --swap-deployment &lt;pod-name&gt;</code></li></ol><h3 id="Kubeconfig-和上下文："><a href="#Kubeconfig-和上下文：" class="headerlink" title="Kubeconfig 和上下文："></a><strong>Kubeconfig 和上下文：</strong></h3><ol><li>列出可用的上下文：<code>kubectl config get-contexts</code></li><li>切换到不同的上下文：<code>kubectl config use-context &lt;context-name&gt;</code></li></ol><h3 id="Pod-安全标准（PodSecurity-准入控制器）："><a href="#Pod-安全标准（PodSecurity-准入控制器）：" class="headerlink" title="Pod 安全标准（PodSecurity 准入控制器）："></a><strong>Pod 安全标准（PodSecurity 准入控制器）：</strong></h3><ol><li>列出 PodSecurityPolicy (PSP) 违规行为：<code>kubectl get psp -A | grep -vE &#39;NAME|REVIEWED&#39;</code></li></ol><h3 id="Pod-中断预算-PDB-诊断："><a href="#Pod-中断预算-PDB-诊断：" class="headerlink" title="Pod 中断预算 (PDB) 诊断："></a><strong>Pod 中断预算 (PDB) 诊断：</strong></h3><ol><li>列出命名空间中的所有 PDB：<code>kubectl get pdb -n &lt;namespace&gt;</code></li><li>查看一个PDB详情：<code>kubectl describe pdb &lt;pdb-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源锁诊断（如果使用资源锁）："><a href="#资源锁诊断（如果使用资源锁）：" class="headerlink" title="资源锁诊断（如果使用资源锁）："></a><strong>资源锁诊断（如果使用资源锁）：</strong></h3><ol><li>列出命名空间中的资源锁：<code>kubectl get resourcelocks -n &lt;namespace&gt;</code></li></ol><h3 id="服务端点和-DNS："><a href="#服务端点和-DNS：" class="headerlink" title="服务端点和 DNS："></a><strong>服务端点和 DNS：</strong></h3><ol><li>列出服务的服务端点：<code>kubectl get endpoints &lt;service-name&gt; -n &lt;namespace&gt;</code></li><li>检查 Pod 中的 DNS 配置：<code>kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- cat /etc/resolv.conf</code></li></ol><h3 id="自定义指标（Prometheus、Grafana）："><a href="#自定义指标（Prometheus、Grafana）：" class="headerlink" title="自定义指标（Prometheus、Grafana）："></a><strong>自定义指标（Prometheus、Grafana）：</strong></h3><ol><li>查询Prometheus指标：用于<code>kubectl port-forward</code>访问Prometheus和Grafana服务来查询自定义指标。</li></ol><h3 id="Pod-优先级和抢占："><a href="#Pod-优先级和抢占：" class="headerlink" title="Pod 优先级和抢占："></a><strong>Pod 优先级和抢占：</strong></h3><ol><li>列出优先级：<code>kubectl get priorityclasses</code></li></ol><h3 id="Pod-开销（Kubernetes-1-18-）："><a href="#Pod-开销（Kubernetes-1-18-）：" class="headerlink" title="Pod 开销（Kubernetes 1.18+）："></a><strong>Pod 开销（Kubernetes 1.18+）：</strong></h3><ol><li>列出 pod 中的开销：<code>kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -o=jsonpath=&#39;&#123;.spec.overhead&#125;&#39;</code></li></ol><h3 id="存储卷快照诊断（如果使用存储卷快照）："><a href="#存储卷快照诊断（如果使用存储卷快照）：" class="headerlink" title="存储卷快照诊断（如果使用存储卷快照）："></a><strong>存储卷快照诊断（如果使用存储卷快照）：</strong></h3><ol><li>列出存储卷快照：<code>kubectl get volumesnapshot -n &lt;namespace&gt;</code></li><li>查看存储卷快照详情：<code>kubectl describe volumesnapshot &lt;snapshot-name&gt; -n &lt;namespace&gt;</code></li></ol><h3 id="资源反序列化诊断："><a href="#资源反序列化诊断：" class="headerlink" title="资源反序列化诊断："></a><strong>资源反序列化诊断：</strong></h3><ol><li>反序列化并打印 Kubernetes 资源：<code>kubectl get &lt;resource-type&gt; &lt;resource-name&gt; -n &lt;namespace&gt; -o=json</code></li></ol><h3 id="节点污点："><a href="#节点污点：" class="headerlink" title="节点污点："></a><strong>节点污点：</strong></h3><ol><li>列出节点污点：<code>kubectl describe node &lt;node-name&gt; | grep Taints</code></li></ol><h3 id="更改和验证-Webhook-配置："><a href="#更改和验证-Webhook-配置：" class="headerlink" title="更改和验证 Webhook 配置："></a><strong>更改和验证 Webhook 配置：</strong></h3><ol><li>列出变异 webhook 配置：<code>kubectl get mutatingwebhookconfigurations</code></li><li>列出验证 Webhook 配置：<code>kubectl get validatingwebhookconfigurations</code></li></ol><h3 id="Pod-网络策略："><a href="#Pod-网络策略：" class="headerlink" title="Pod 网络策略："></a><strong>Pod 网络策略：</strong></h3><ol><li>列出命名空间中的 pod 网络策略：<code>kubectl get networkpolicies -n &lt;namespace&gt;</code></li></ol><h3 id="节点条件（Kubernetes-1-17-）："><a href="#节点条件（Kubernetes-1-17-）：" class="headerlink" title="节点条件（Kubernetes 1.17+）："></a><strong>节点条件（Kubernetes 1.17+）：</strong></h3><ol><li>自定义查询输出：<code>kubectl get nodes -o custom-columns=NODE:.metadata.name,READY:.status.conditions[?(@.type==&quot;Ready&quot;)].status -l &#39;node-role.kubernetes.io/worker=&#39;</code></li></ol><h3 id="审核日志："><a href="#审核日志：" class="headerlink" title="审核日志："></a><strong>审核日志：</strong></h3><ol><li>检索审核日志（如果启用）：检查 Kubernetes 审核日志配置以了解审核日志的位置。</li></ol><h3 id="节点操作系统详细信息："><a href="#节点操作系统详细信息：" class="headerlink" title="节点操作系统详细信息："></a><strong>节点操作系统详细信息：</strong></h3><ol><li>获取节点的操作系统信息：<code>kubectl get node &lt;node-name&gt; -o jsonpath=&#39;&#123;.status.nodeInfo.osImage&#125;&#39;</code></li></ol><p>这些命令应该涵盖 Kubernetes 中的各种诊断场景。确保将<code>&lt;namespace&gt;</code>、<code>&lt;pod-name&gt;</code>、<code>&lt;deployment-name&gt;</code>等占位符替换为你的集群和用例的实际值。</p>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot限流方案</title>
    <link href="/2024/02/20/SpringBoot%20%E9%80%9A%E7%94%A8%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/"/>
    <url>/2024/02/20/SpringBoot%20%E9%80%9A%E7%94%A8%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-通用限流方案"><a href="#SpringBoot-通用限流方案" class="headerlink" title="SpringBoot 通用限流方案"></a>SpringBoot 通用限流方案</h1><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><blockquote><p>限流对于一个微服务架构系统来说具有非常重要的意义，否则其中的某个微服务将成为整个系统隐藏的雪崩因素，为什么这么说？</p><p>举例来讲，某个SAAS平台有100多个微服务应用，但是作为底层的某个或某几个应用来说，将会被所有上层应用频繁调用，业务高峰期时，如果底层应用不做限流处理，该应用必将面临着巨大的压力，尤其是那些个别被高频调用的接口来说，最直接的表现就是导致后续新进来的请求阻塞、排队、响应超时…最后直到该服务所在JVM资源被耗尽。</p></blockquote><h1 id="二、限流概述"><a href="#二、限流概述" class="headerlink" title="二、限流概述"></a>二、限流概述</h1><blockquote><p>在大多数的微服务架构在设计之初，比如在技术选型阶段，架构师会从一个全局的视角去规划技术栈的组合，比如结合当前产品的现状考虑是使用dubbo？还是springcloud？作为微服务治理的底层框架。甚至为了满足快速的上线、迭代和交付，直接以springboot为基座进行开发，后续再引入新的技术栈等…</p><p>所以在谈论某个业务场景具体的技术解决方案时不可一概而论，而是需要结合产品和业务的现状综合评估，以限流来说，在下面的不同的技术架构下具体在选择的时候可能也不一样。</p></blockquote><h3 id="2-1-dubbo-服务治理模式"><a href="#2-1-dubbo-服务治理模式" class="headerlink" title="2.1 dubbo 服务治理模式"></a>2.1 dubbo 服务治理模式</h3><blockquote><p>选择dubbo框架作为基础服务治理对于那种偏向内部平台的应用还是不错的，dubbo底层走netty，这一点相比http协议来说，在一定场景下还是具有优势的，如果选择dubbo，在选择限流方案上可以做如下的参考。</p></blockquote><h3 id="2-1-1-dubbo框架级限流"><a href="#2-1-1-dubbo框架级限流" class="headerlink" title="2.1.1 dubbo框架级限流"></a>2.1.1 dubbo框架级限流</h3><p>dubbo官方提供了完善的服务治理，能够满足大多数开发场景中的需求，针对限流这个场景，具体来说包括如下手段，具体的配置，可以参考官方手册；</p><p><strong>客户端限流</strong></p><ul><li>信号量限流 （通过统计的方式）</li><li>连接数限流 (socket-&gt;tcp)</li></ul><p><strong>服务端限流</strong></p><ul><li>线程池限流 (隔离手段)</li><li>信号量限流 (非隔离手段)</li><li>接收数限流 (socket-&gt;tcp)</li></ul><h3 id="2-1-2-线程池设置"><a href="#2-1-2-线程池设置" class="headerlink" title="2.1.2 线程池设置"></a>2.1.2 线程池设置</h3><p>多线程并发操作一定离不开线程池，Dubbo自身提供了支持了四种线程池类型支持。生产者<code>&lt;dubbo:protocol&gt;</code>标签中可配置线程池关键参数，线程池类型、阻塞队列大小、核心线程数量等，通过配置生产端的线程池数量可以在一定程度上起到限流的效果。</p><h3 id="2-1-3-集成第三方组件"><a href="#2-1-3-集成第三方组件" class="headerlink" title="2.1.3 集成第三方组件"></a>2.1.3 集成第三方组件</h3><p>如果是springboot框架的项目，可以考虑直接引入地方的组件或SDK，比如hystrix，guava，sentinel原生SDK等，如果技术实力足够强甚至可以考虑自己造轮子。</p><h3 id="2-2-springcloud-服务治理模式"><a href="#2-2-springcloud-服务治理模式" class="headerlink" title="2.2 springcloud 服务治理模式"></a>2.2 springcloud 服务治理模式</h3><p>如果你的服务治理框架选用的是springcloud或springcloud-alibaba，其框架自身的生态中已经包含了相应的限流组件，可以实现开箱即用，下面列举几种常用的基于springcloud框架的限流组件。</p><h3 id="2-2-1-hystrix"><a href="#2-2-1-hystrix" class="headerlink" title="2.2.1 hystrix"></a>2.2.1 hystrix</h3><p>Hystrix是Netflix开源的一款容错框架，在springcloud早期推出市场的时候，作为springcloud生态中用于限流、熔断、降级的一款组件。</p><p>Hystrix提供了限流功能，在springcloud架构的系统中，可以在网关启用Hystrix，进行限流处理，每个微服务也可以各自启用Hystrix进行限流。</p><blockquote><p>Hystrix默认使用线程隔离模式，可以通过线程数+队列大小进行限流，具体参数配置可以参考官网相关资料。</p></blockquote><h3 id="2-2-2-sentinel"><a href="#2-2-2-sentinel" class="headerlink" title="2.2.2 sentinel"></a>2.2.2 sentinel</h3><p>Sentinel 号称分布式系统的流量防卫兵，属于springcloud-alibaba生态中的重要组件，面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p><h3 id="2-3-网关层限流"><a href="#2-3-网关层限流" class="headerlink" title="2.3 网关层限流"></a>2.3 网关层限流</h3><p>随着微服务规模的增加，整个系统中很多微服务都需要实现限流这种需求时，就可以考虑在网关这一层进行限流了，通常来说，网关层的限流面向的是通用的业务，比如那些恶意的请求，爬虫，攻击等，简单来说，网关层面的限流提供了一层对系统整体的保护措施。</p><h1 id="三、常用限流策略"><a href="#三、常用限流策略" class="headerlink" title="三、常用限流策略"></a>三、常用限流策略</h1><h3 id="3-1-限流常用的算法"><a href="#3-1-限流常用的算法" class="headerlink" title="3.1 限流常用的算法"></a>3.1 限流常用的算法</h3><p>不管是哪种限流组件，其底层的限流实现算法大同小异，这里列举几种常用的限流算法以供了解。</p><h3 id="3-1-1-令牌桶算法"><a href="#3-1-1-令牌桶算法" class="headerlink" title="3.1.1 令牌桶算法"></a>3.1.1 令牌桶算法</h3><p>令牌桶算法是目前应用最为广泛的限流算法，顾名思义，它有以下两个关键角色：</p><ul><li>令牌 ：获取到令牌的Request才会被处理，其他Requests要么排队要么被直接丢弃；</li><li>桶 ：用来装令牌的地方，所有Request都从这个桶里面获取令牌</li></ul><p>令牌桶主要涉及到2个过程，即令牌的生成，令牌的获取</p><h3 id="3-1-2-漏桶算法"><a href="#3-1-2-漏桶算法" class="headerlink" title="3.1.2 漏桶算法"></a>3.1.2 漏桶算法</h3><p>漏桶算法的前半段和令牌桶类似，但是操作的对象不同。</p><p>令牌桶是将令牌放入桶里，而漏桶是将访问请求的数据包放到桶里。同样的是，如果桶满了，那么后面新来的数据包将被丢弃。</p><h3 id="3-1-3-滑动时间窗口"><a href="#3-1-3-滑动时间窗口" class="headerlink" title="3.1.3 滑动时间窗口"></a>3.1.3 滑动时间窗口</h3><p>简单描述下滑动时间窗口这种过程：</p><ul><li>黑色大框为时间窗口，可以设定窗口时间单位为5秒，它会随着时间推移向后滑动。我们将窗口内的时间划分为五个小格子，每个格子代表1秒钟，同时这个格子还包含一个计数器，用来计算在当前时间内访问的请求数量。那么这个时间窗口内的总访问量就是所有格子计数器累加后的数值；</li><li>比如说，我们在每一秒内有5个用户访问，第5秒内有10个用户访问，那么在0到5秒这个时间窗口内访问量就是15。如果我们的接口设置了时间窗口内访问上限是20，那么当时间到第六秒的时候，这个时间窗口内的计数总和就变成了10，因为1秒的格子已经退出了时间窗口，因此在第六秒内可以接收的访问量就是20-10=10个；</li></ul><p>滑动窗口其实也是一种计算器算法，它有一个显著特点，当时间窗口的跨度越长时，限流效果就越平滑。打个比方，如果当前时间窗口只有两秒，而访问请求全部集中在第一秒的时候，当时间向后滑动一秒后，当前窗口的计数量将发生较大的变化，拉长时间窗口可以降低这种情况的发生概率</p><h1 id="四、通用限流实现方案"><a href="#四、通用限流实现方案" class="headerlink" title="四、通用限流实现方案"></a>四、通用限流实现方案</h1><p>抛开网关层的限流先不说，在微服务应用中，考虑到技术栈的组合，团队人员的开发水平，以及易维护性等因素，一个比较通用的做法是，利用AOP技术+自定义注解实现对特定的方法或接口进行限流，下面基于这个思路来分别介绍下几种常用的限流方案的实现。</p><h3 id="4-1-基于guava限流实现"><a href="#4-1-基于guava限流实现" class="headerlink" title="4.1 基于guava限流实现"></a>4.1 基于guava限流实现</h3><p>guava为谷歌开源的一个比较实用的组件，利用这个组件可以帮助开发人员完成常规的限流操作，接下来看具体的实现步骤。</p><h3 id="4-1-1-引入guava依赖"><a href="#4-1-1-引入guava依赖" class="headerlink" title="4.1.1 引入guava依赖"></a>4.1.1 引入guava依赖</h3><p>版本可以选择更高的或其他版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-1-2-自定义限流注解"><a href="#4-1-2-自定义限流注解" class="headerlink" title="4.1.2 自定义限流注解"></a>4.1.2 自定义限流注解</h3><p>自定义一个限流用的注解，后面在需要限流的方法或接口上面只需添加该注解即可；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 自定义限流注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/10/13 13:46</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RateInterface &#123;<br>    String <span class="hljs-title function_">limitType</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">limitCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5d</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-3-限流AOP类"><a href="#4-1-3-限流AOP类" class="headerlink" title="4.1.3 限流AOP类"></a>4.1.3 限流AOP类</h3><p>通过AOP前置通知的方式拦截添加了上述自定义限流注解的方法，解析注解中的属性值，并以该属性值作为guava提供的限流参数，该类为整个实现的核心所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 限流AOP类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/10/13 13:41</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-comment">//@Componentpublic</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaLimitAop</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(@RateConfigAnno * *(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">limit</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-comment">//1、获取当前的调用方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> getCurrentMethod(joinPoint);<br><br>        <span class="hljs-keyword">if</span> (Objects.isNull(currentMethod)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//2、从方法注解定义上获取限流的类型</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">limitType</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(RateInterface.class)<br>                .limitType();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">limitCount</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(RateInterface.class)<br>                .limitCount();<br><br>        <span class="hljs-comment">//使用guava的令牌桶算法获取一个令牌，获取不到先等待</span><br>        <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimitHelper.getRateLimiter(limitType,<br>                limitCount);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> rateLimiter.tryAcquire();<br><br>        <span class="hljs-keyword">if</span> (b) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取到令牌&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            jsonObject.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>            jsonObject.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;限流中&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                output(resp, jsonObject.toJSONString());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getCurrentMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        Method[] methods = joinPoint.getTarget().getClass().getMethods();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;<br>                target = method;<br><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">(HttpServletResponse response, String msg)</span><br>            <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            outputStream = response.getOutputStream();<br>            outputStream.write(msg.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            outputStream.flush();<br>            outputStream.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中限流的核心API即为RateLimiter这个对象，涉及到的RateLimitHelper类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 核心API类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> along</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2023/10/13 13:43</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimitHelper</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">RateLimitHelper</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, RateLimiter&gt; rateMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RateLimiter <span class="hljs-title function_">getRateLimiter</span><span class="hljs-params">(String limitType, <span class="hljs-type">double</span> limitCount)</span> &#123;<br>        <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> rateMap.get(limitType);<br>        <span class="hljs-keyword">if</span> (rateLimiter == <span class="hljs-literal">null</span>) &#123;<br>            rateLimiter = RateLimiter.create(limitCount);<br>            rateMap.put(limitType, rateLimiter);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rateLimiter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-4-测试接口"><a href="#4-1-4-测试接口" class="headerlink" title="4.1.4 测试接口"></a>4.1.4 测试接口</h3><p>下面添加一个测试接口，测试一下上面的代码是否生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-comment">//localhost:8081/save    </span><br>    <span class="hljs-meta">@GetMapping(&quot;/save&quot;)</span>@ RateConfigAnno(limitType = <span class="hljs-string">&quot;saveOrder&quot;</span>, limitCount = <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在接口中为了模拟出效果，我们将参数设置的非常小，即QPS为1，可以预想当每秒请求超过1时将会出现被限流的提示，启动工程并验证接口，每秒1次的请求，可以正常得到结果</p><h3 id="4-2-基于sentinel限流实现"><a href="#4-2-基于sentinel限流实现" class="headerlink" title="4.2 基于sentinel限流实现"></a>4.2 基于sentinel限流实现</h3><p>在不少同学的意识中，sentinel通常是需要结合springcloud-alibaba框架一起实用的，而且与框架集成之后，可以配合控制台一起使用达到更好的效果，实际上，sentinel官方也提供了相对原生的SDK可供使用，接下来就以这种方式进行整合。</p><h3 id="4-2-1-引入sentinel核心依赖包"><a href="#4-2-1-引入sentinel核心依赖包" class="headerlink" title="4.2.1 引入sentinel核心依赖包"></a>4.2.1 引入sentinel核心依赖包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-2-2-自定义限流注解"><a href="#4-2-2-自定义限流注解" class="headerlink" title="4.2.2 自定义限流注解"></a>4.2.2 自定义限流注解</h3><p>可以根据需要，添加更多的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span> <br><span class="hljs-keyword">public</span>@ <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SentinelLimitAnnotation</span> &#123;<br>    String <span class="hljs-title function_">resourceName</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">limitCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-自定义AOP类实现限流"><a href="#4-2-3-自定义AOP类实现限流" class="headerlink" title="4.2.3 自定义AOP类实现限流"></a>4.2.3 自定义AOP类实现限流</h3><p>该类的实现思路与上述使用guava类似，不同的是，这里使用的是sentinel原生的限流相关的API，对此不够属性的可以查阅官方的文档进行学习，这里就不展开来说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Entry;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.SphU;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Tracer;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelMethodLimitAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRule</span><span class="hljs-params">(String resourceName, <span class="hljs-type">int</span> limitCount)</span> &#123;<br>        List &lt; FlowRule &gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> &lt; &gt; ();<br>        <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>        <span class="hljs-comment">//设置受保护的资源       </span><br>        rule.setResource(resourceName);<br>        <span class="hljs-comment">//设置流控规则 QPS     </span><br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        <span class="hljs-comment">//设置受保护的资源阈值      </span><br>        rule.setCount(limitCount);<br>        rules.add(rule);<br>        <span class="hljs-comment">//加载配置好的规则  </span><br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br><span class="hljs-meta">@Pointcut(value = &quot;@annotation(com.congge.sentinel.SentinelLimitAnnotation)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-meta">@Around(&quot;rateLimit()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-comment">//1、获取当前的调用方法     </span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> getCurrentMethod(joinPoint);<br>        <span class="hljs-keyword">if</span> (Objects.isNull(currentMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、从方法注解定义上获取限流的类型      </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimitAnnotation.class).resourceName();<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(resourceName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;资源名称为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limitCount</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimitAnnotation.class).limitCount();<br>        initFlowRule(resourceName, limitCount);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            entry = SphU.entry(resourceName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = joinPoint.proceed();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>                throwable.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-comment">// 资源访问阻止，被限流或被降级    </span><br>            <span class="hljs-comment">// 在此处进行相应的处理操作       </span><br>            System.out.println(<span class="hljs-string">&quot;blocked&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;被限流了&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Tracer.traceEntry(e, entry);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>                entry.exit();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getCurrentMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        Method[] methods = joinPoint.getTarget().getClass().getMethods();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Method method: methods) &#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;<br>                target = method;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-4-自定义测试接口"><a href="#4-2-4-自定义测试接口" class="headerlink" title="4.2.4 自定义测试接口"></a>4.2.4 自定义测试接口</h3><p>为了模拟效果，这里将QPS的数量设置为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/limit&quot;)</span><br><span class="hljs-meta">@SentinelLimitAnnotation(limitCount = 1, resourceName = &quot;sentinelLimit&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sentinelLimit</span><span class="hljs-params">()</span> &#123; <br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sentinelLimit&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动工程之后，浏览器调用接口测试一下，每秒一个请求，可以正常通过</p><p>快速刷接口，超过每秒1次,自行查看效果</p><h3 id="4-3-基于redis-lua限流实现"><a href="#4-3-基于redis-lua限流实现" class="headerlink" title="4.3 基于redis+lua限流实现"></a>4.3 基于redis+lua限流实现</h3><p>redis是线程安全的，天然具有线程安全的特性，支持原子性操作，限流服务不仅需要承接超高QPS，还要保证限流逻辑的执行层面具备线程安全的特性，利用Redis这些特性做限流，既能保证线程安全，也能保证性能。基于redis的限流实现完整流程如下图：</p><p>结合上面的流程图，这里梳理出一个整体的实现思路：</p><ul><li>编写lua脚本，指定入参的限流规则，比如对特定的接口限流时，可以根据某个或几个参数进行判定，调用该接口的请求，在一定的时间窗口内监控请求次数；</li><li>既然是限流，最好能够通用，可将限流规则应用到任何接口上，那么最合适的方式就是通过自定义注解形式切入；</li><li>提供一个配置类，被spring的容器管理，redisTemplate中提供了DefaultRedisScript这个bean；</li><li>提供一个能动态解析接口参数的类，根据接口参数进行规则匹配后触发限流；</li></ul><h3 id="4-3-1-引入redis依赖"><a href="#4-3-1-引入redis依赖" class="headerlink" title="4.3.1 引入redis依赖"></a>4.3.1 引入redis依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-2-自定义注解"><a href="#4-3-2-自定义注解" class="headerlink" title="4.3.2 自定义注解"></a>4.3.2 自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RedisLimitAnnotation &#123;<br>    <span class="hljs-comment">/**     * key     */</span><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">/**    *    Key的前缀    */</span><br>    String <span class="hljs-title function_">prefix</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">/**     * 一定时间内最多访问次数     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/**     * 给定的时间范围 单位(秒)     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">period</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/**     * 限流的类型(用户自定义key或者请求ip)     */</span><br>    LimitType <span class="hljs-title function_">limitType</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LimitType.CUSTOMER;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-自定义redis配置类"><a href="#4-3-3-自定义redis配置类" class="headerlink" title="4.3.3 自定义redis配置类"></a>4.3.3 自定义redis配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><span class="hljs-keyword">import</span> org.springframework.scripting.support.ResourceScriptSource;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfiguration</span> &#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DefaultRedisScript &lt; Number &gt; redisluaScript() &#123;<br>        DefaultRedisScript &lt; Number &gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span> &lt;&gt; ();<br>        redisScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;limit.lua&quot;</span>)));<br>        redisScript.setResultType(Number.class);<br>        <span class="hljs-keyword">return</span> redisScript;<br>    &#125;<br><span class="hljs-meta">@Bean(&quot;redisTemplate&quot;)</span><br><span class="hljs-keyword">public</span> RedisTemplate &lt; String, Object &gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;<br>        RedisTemplate &lt; String, Object &gt; redisTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span> &lt;&gt; ();<br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jackson2JsonRedisSerializer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br>        <span class="hljs-comment">//设置value的序列化方式为JSON</span><br>        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);<br>        <span class="hljs-comment">//设置key的序列化方式为String    </span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);<br>        redisTemplate.afterPropertiesSet();<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-4-自定义限流AOP类"><a href="#4-3-4-自定义限流AOP类" class="headerlink" title="4.3.4 自定义限流AOP类"></a>4.3.4 自定义限流AOP类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.aspectj.lang.reflect.MethodSignature;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitRestAspect</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LimitRestAspect.class);<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedisTemplate &lt; String, Object &gt; redisTemplate;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> DefaultRedisScript &lt; Number &gt; redisluaScript;<br><span class="hljs-meta">@Pointcut(value = &quot;@annotation(com.congge.config.limit.RedisLimitAnnotation)&quot;)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">()</span> &#123;&#125;<br><span class="hljs-meta">@Around(&quot;rateLimit()&quot;)</span> <br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">interceptor</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br>            Class &lt;? &gt; targetClass = method.getDeclaringClass();<br>            <span class="hljs-type">RedisLimitAnnotation</span> <span class="hljs-variable">rateLimit</span> <span class="hljs-operator">=</span> method.getAnnotation(RedisLimitAnnotation.class);<br>            <span class="hljs-keyword">if</span> (rateLimit != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ipAddress</span> <span class="hljs-operator">=</span> getIpAddr(request);<br>                <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>                stringBuffer.append(ipAddress).append(<span class="hljs-string">&quot;-&quot;</span>).append(targetClass.getName()).append(<span class="hljs-string">&quot;- &quot;</span>).append(method.getName()).append(<span class="hljs-string">&quot;-&quot;</span>).append(rateLimit.key());<br>                List &lt; String &gt; keys = Collections.singletonList(stringBuffer.toString());<br>                <span class="hljs-comment">//调用lua脚本，获取返回结果，这里即为请求的次数      </span><br>                <span class="hljs-type">Number</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> redisTemplate.execute(redisluaScript, keys, rateLimit.count(), rateLimit.period());<br>                <span class="hljs-keyword">if</span> (number != <span class="hljs-literal">null</span> &amp;&amp; number.intValue() != <span class="hljs-number">0</span> &amp;&amp; number.intValue() &lt;= rateLimit.count()) &#123;<br>                    logger.info(<span class="hljs-string">&quot;限流时间段内访问了第：&#123;&#125; 次&quot;</span>, number.toString());<br>                    <span class="hljs-keyword">return</span> joinPoint.proceed();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> joinPoint.proceed();<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;访问频率过快，被限流了&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">/**      </span><br><span class="hljs-comment">   * 获取请求的IP方法  </span><br><span class="hljs-comment">       * <span class="hljs-doctag">@param</span> request     </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span>         */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getIpAddr</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ipAddress</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ipAddress = request.getHeader(<span class="hljs-string">&quot;x-forwarded-for&quot;</span>);<br>            <span class="hljs-keyword">if</span> (ipAddress == <span class="hljs-literal">null</span> || ipAddress.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>                ipAddress = request.getHeader(<span class="hljs-string">&quot;Proxy-Client-IP&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ipAddress == <span class="hljs-literal">null</span> || ipAddress.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>                ipAddress = request.getHeader(<span class="hljs-string">&quot;WL-Proxy-Client-IP&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ipAddress == <span class="hljs-literal">null</span> || ipAddress.length() == <span class="hljs-number">0</span> || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>                ipAddress = request.getRemoteAddr();<br>            &#125;<br>            <span class="hljs-comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割      </span><br>            <span class="hljs-keyword">if</span> (ipAddress != <span class="hljs-literal">null</span> &amp;&amp; ipAddress.length() &gt; <span class="hljs-number">15</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ipAddress.indexOf(<span class="hljs-string">&quot;,&quot;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                    ipAddress = ipAddress.substring(<span class="hljs-number">0</span>, ipAddress.indexOf(<span class="hljs-string">&quot;,&quot;</span>));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            ipAddress = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ipAddress;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类要做的事情和上面的两种限流措施类似，不过在这里核心的限流是通过读取lua脚步，通过参数传递给lua脚步实现的。</p><h3 id="4-3-5-自定义lua脚本"><a href="#4-3-5-自定义lua脚本" class="headerlink" title="4.3.5 自定义lua脚本"></a>4.3.5 自定义lua脚本</h3><p>在工程的resources目录下，添加如下的lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = <span class="hljs-string">&quot;rate.limit:&quot;</span>..KEYS[<span class="hljs-number">1</span>]<span class="hljs-keyword">local</span> limit = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> current = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, key) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;0&quot;</span>)<span class="hljs-keyword">if</span> current + <span class="hljs-number">1</span> &gt; limitthenreturn <span class="hljs-number">0</span><span class="hljs-keyword">else</span><span class="hljs-comment">--没有超阈值， 将当前访问数量 + 1， 并设置2秒过期（ 可根据自己的业务情况调整）redis.call(&quot;INCRBY&quot;, key, &quot;1&quot;)redis.call(&quot;expire&quot;, key, &quot;2&quot;)return current + 1end</span><br></code></pre></td></tr></table></figure><h3 id="4-3-6-添加测试接口"><a href="#4-3-6-添加测试接口" class="headerlink" title="4.3.6 添加测试接口"></a>4.3.6 添加测试接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisController</span> &#123; <br><br> <span class="hljs-meta">@GetMapping(&quot;/redis/limit&quot;)</span> <br> <span class="hljs-meta">@RedisLimitAnnotation(key = &quot;queryFromRedis&quot;,period = 1, count = 1)</span> <br> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryFromRedis</span><span class="hljs-params">()</span> &#123;  <br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;   <br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了模拟效果，将QPS设置为1 ，启动工程后（提前启动redis服务），调用一下接口</p><p>快速刷接口，超过每秒1次的请求,可自行查看效果</p><h1 id="五、自定义starter限流实现"><a href="#五、自定义starter限流实现" class="headerlink" title="五、自定义starter限流实现"></a>五、自定义starter限流实现</h1><p>上面通过案例介绍了几种常用的限流实现，不过细心的同学可以看到，这些限流的实现都是在具体的工程模块中嵌入的，事实上，在真实的微服务开发中，一个项目可能包含了众多的微服务模块，为了减少重复造轮子，避免每个微服务模块中单独实现，可以考虑将限流的逻辑实现封装成一个SDK，即作为一个springboot的starter的方式被其他微服务模块进行引用即可。这也是目前很多生产实践中比较通用的做法，接下来看看具体的实现吧。</p><h3 id="5-1-前置准备"><a href="#5-1-前置准备" class="headerlink" title="5.1 前置准备"></a>5.1 前置准备</h3><p>创建一个空的springboot工程，工程目录结构说明：</p><ul><li><code>annotation</code>：存放自定义的限流相关的注解；</li><li><code>aop</code>：存放不同的限流实现，比如基于guava的aop，基于sentinel的aop实现等；</li><li><code>spring.factories</code>：自定义待装配的aop实现类；</li></ul><h3 id="5-2-代码整合完成步骤"><a href="#5-2-代码整合完成步骤" class="headerlink" title="5.2 代码整合完成步骤"></a>5.2 代码整合完成步骤</h3><h3 id="5-2-1-导入基础的依赖"><a href="#5-2-1-导入基础的依赖" class="headerlink" title="5.2.1 导入基础的依赖"></a>5.2.1 导入基础的依赖</h3><p>这里包括如下几个必须的依赖，其他的依赖可以结合自身的情况合理选择；</p><ul><li>spring-boot-starter；</li><li>guava；</li><li>spring-boot-autoconfigure；</li><li>sentinel-core；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>   <br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>       <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br><span class="hljs-comment">&lt;!-- guava--&gt;</span>    <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>23.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>   <br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>     <br>   <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>     <br>       <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>     <br>       <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/**<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>   <br>         <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span>     <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-2-自定义注解"><a href="#5-2-2-自定义注解" class="headerlink" title="5.2.2 自定义注解"></a>5.2.2 自定义注解</h3><p>目前该SDK支持三种限流方式，即后续其他微服务工程中可以通过添加这3种注解即可实现限流，分别是基于guava的令牌桶，基于sentinel的限流，基于java自带的Semaphore限流，三个自定义注解类如下：</p><p>令牌桶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span>@ <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TokenBucketLimiter</span> &#123; <br>   <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Semaphore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ShLimiter &#123;  <br>  <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <br>  <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>sentinel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(value = RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SentinelLimiter &#123;  <br>  String <span class="hljs-title function_">resourceName</span><span class="hljs-params">()</span>;   <br>  <span class="hljs-type">int</span> <span class="hljs-title function_">limitCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-3-限流实现AOP类"><a href="#5-2-3-限流实现AOP类" class="headerlink" title="5.2.3 限流实现AOP类"></a>5.2.3 限流实现AOP类</h3><p>具体的限流在AOP中进行实现，思路和上一章节类似，即通过环绕通知的方式，先解析那些添加了限流注解的方法，然后解析里面的参数，进行限流的业务实现。</p><p>基于guava的aop实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson2.JSONObject;<br><span class="hljs-keyword">import</span> com.congge.annotation.TokenBucketLimiter;<br><span class="hljs-keyword">import</span> com.google.common.util.concurrent.RateLimiter;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.cglib.core.ReflectUtils;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><span class="hljs-keyword">import</span> javax.servlet.ServletOutputStream;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaLimiterAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map &lt; String, RateLimiter &gt; rateLimiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span> &lt;String, RateLimiter&gt; ();<br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.congge.annotation.TokenBucketLimiter)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aspect</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Around(value = &quot;aspect()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.debug(<span class="hljs-string">&quot;准备限流&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> point.getTarget();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> target.getClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>        Object[] arguments = point.getArgs();<br>        Class &lt;? &gt; targetClass = Class.forName(targetName);<br>        Class &lt;? &gt; [] argTypes = ReflectUtils.getClasses(arguments);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(methodName, argTypes);<br>        <span class="hljs-comment">// 获取目标method上的限流注解@Limiter     </span><br>        <span class="hljs-type">TokenBucketLimiter</span> <span class="hljs-variable">limiter</span> <span class="hljs-operator">=</span> method.getAnnotation(TokenBucketLimiter.class);<br>        <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != limiter) &#123;<br>            <span class="hljs-comment">// 以 class + method + parameters为key，避免重载、重写带来的混乱      </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> targetName + <span class="hljs-string">&quot;.&quot;</span> + methodName + Arrays.toString(argTypes);<br>            rateLimiter = rateLimiters.get(key);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == rateLimiter) &#123;<br>                <span class="hljs-comment">// 获取限定的流量     </span><br>                <span class="hljs-comment">// 为了防止并发    </span><br>                rateLimiters.putIfAbsent(key, RateLimiter.create(limiter.value()));<br>                rateLimiter = rateLimiters.get(key);<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> rateLimiter.tryAcquire();<br>            <span class="hljs-keyword">if</span> (b) &#123;<br>                log.debug(<span class="hljs-string">&quot;得到令牌，准备执行业务&quot;</span>);<br>                result = point.proceed();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span> <span class="hljs-operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();<br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>                jsonObject.put(<span class="hljs-string">&quot;success&quot;</span>, <span class="hljs-literal">false</span>);<br>                jsonObject.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;限流中&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    output(resp, jsonObject.toJSONString());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    log.error(<span class="hljs-string">&quot;error,e:&#123;&#125;&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = point.proceed();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;退出限流&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">output</span><span class="hljs-params">(HttpServletResponse response, String msg)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            outputStream = response.getOutputStream();<br>            outputStream.write(msg.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            outputStream.flush();<br>            outputStream.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于Semaphore的aop实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.congge.annotation.ShLimiter;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.cglib.core.ReflectUtils;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreLimiterAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map &lt;String, Semaphore&gt; semaphores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span> &lt;String, Semaphore&gt; ();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOG</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SemaphoreLimiterAop.class);<br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(com.congge.annotation.ShLimiter)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aspect</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Around(value = &quot;aspect()&quot;)</span><br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.debug(<span class="hljs-string">&quot;进入限流aop&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> point.getTarget();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">targetName</span> <span class="hljs-operator">=</span> target.getClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>        Object[] arguments = point.getArgs();<br>        Class &lt;? &gt; targetClass = Class.forName(targetName);<br>        Class &lt;? &gt; [] argTypes = ReflectUtils.getClasses(arguments);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(methodName, argTypes);<br>        <span class="hljs-comment">// 获取目标method上的限流注解</span><br>        <span class="hljs-meta">@Limiter</span><br>        <span class="hljs-type">ShLimiter</span> <span class="hljs-variable">limiter</span> <span class="hljs-operator">=</span> method.getAnnotation(ShLimiter.class);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != limiter) &#123;<br>            <span class="hljs-comment">// 以 class + method + parameters为key，避免重载、重写带来的混乱    </span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> targetName + <span class="hljs-string">&quot;.&quot;</span> + methodName + Arrays.toString(argTypes);<br>            <span class="hljs-comment">// 获取限定的流量    </span><br>            <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> semaphores.get(key);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == semaphore) &#123;<br>                semaphores.putIfAbsent(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(limiter.value()));<br>                semaphore = semaphores.get(key);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>                result = point.proceed();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != semaphore) &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = point.proceed();<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot;退出限流&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于sentinel的aop实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Entry;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.SphU;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Tracer;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br><span class="hljs-keyword">import</span> com.congge.annotation.SentinelLimiter;<br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SentinelLimiterAop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initFlowRule</span><span class="hljs-params">(String resourceName, <span class="hljs-type">int</span> limitCount)</span> &#123;<br>        List &lt; FlowRule &gt; rules = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span> &lt;&gt; ();<br>        <span class="hljs-type">FlowRule</span> <span class="hljs-variable">rule</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowRule</span>();<br>        <span class="hljs-comment">//设置受保护的资源      </span><br>        rule.setResource(resourceName);<br>        <span class="hljs-comment">//设置流控规则 QPS   </span><br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        <span class="hljs-comment">//设置受保护的资源阈值   </span><br>        rule.setCount(limitCount);<br>        rules.add(rule);<br>        <span class="hljs-comment">//加载配置好的规则       </span><br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(com.congge.annotation.SentinelLimiter)&quot;)</span> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rateLimit</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Around(&quot;rateLimit()&quot;)</span> <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-comment">//1、获取当前的调用方法  </span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> getCurrentMethod(joinPoint);<br>        <span class="hljs-keyword">if</span> (Objects.isNull(currentMethod)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//2、从方法注解定义上获取限流的类型    </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimiter.class).resourceName();<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(resourceName)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;资源名称为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">limitCount</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(SentinelLimiter.class).limitCount();<br>        initFlowRule(resourceName, limitCount);<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            entry = SphU.entry(resourceName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = joinPoint.proceed();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>                throwable.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-comment">// 资源访问阻止，被限流或被降级     </span><br>            <span class="hljs-comment">// 在此处进行相应的处理操作      </span><br>            System.out.println(<span class="hljs-string">&quot;blocked&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;被限流了&quot;</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Tracer.traceEntry(e, entry);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span>) &#123;<br>                entry.exit();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Method <span class="hljs-title function_">getCurrentMethod</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123;<br>        Method[] methods = joinPoint.getTarget().getClass().getMethods();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (Method method: methods) &#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;<br>                target = method;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-4-配置自动装配AOP实现"><a href="#5-2-4-配置自动装配AOP实现" class="headerlink" title="5.2.4 配置自动装配AOP实现"></a>5.2.4 配置自动装配AOP实现</h3><p>在resources目录下创建上述的<code>spring.factories</code>文件，内容如下，通过这种方式配置后，其他应用模块引入了当前的SDK的jar之后，就可以实现开箱即用了；</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\\com<span class="hljs-selector-class">.congge</span><span class="hljs-selector-class">.aop</span><span class="hljs-selector-class">.SemaphoreLimiterAop</span>,\\com<span class="hljs-selector-class">.congge</span><span class="hljs-selector-class">.aop</span><span class="hljs-selector-class">.GuavaLimiterAop</span>,\\com<span class="hljs-selector-class">.congge</span><span class="hljs-selector-class">.aop</span>.SemaphoreLimiterAop<br></code></pre></td></tr></table></figure><h3 id="5-2-5-将工程打成jar进行安装"><a href="#5-2-5-将工程打成jar进行安装" class="headerlink" title="5.2.5 将工程打成jar进行安装"></a>5.2.5 将工程打成jar进行安装</h3><p>这一步比较简单就跳过了</p><h3 id="5-2-6-在其他的工程中引入上述SDK"><a href="#5-2-6-在其他的工程中引入上述SDK" class="headerlink" title="5.2.6 在其他的工程中引入上述SDK"></a>5.2.6 在其他的工程中引入上述SDK</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cm.congge<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>biz-limit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-2-7-编写测试接口"><a href="#5-2-7-编写测试接口" class="headerlink" title="5.2.7 编写测试接口"></a>5.2.7 编写测试接口</h3><p>在其他工程中，编写一个测试接口，并使用上面的注解，这里以guava的限流注解为例进行说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.congge.annotation.TokenBucketLimiter;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SdkController</span> &#123;<br>    <br>    <span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br>    <span class="hljs-meta">@TokenBucketLimiter(1)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queryUser&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-8-功能测试"><a href="#5-2-8-功能测试" class="headerlink" title="5.2.8 功能测试"></a>5.2.8 功能测试</h3><p>启动当前的工程后，正常调用接口，每秒一次的请求，可以正常得到结果</p><p>快速刷接口，QPS超过1之后，将会触发限流</p><p>通过上面这种方式，也可以得到预期的效果，其他两种限流注解有兴趣的同学也可以继续测试验证，篇幅原因就不再赘述了。</p><blockquote><p>上述通过starter的方式实现了一种更优雅的限流集成方式，也是生产中比较推荐的一种方式，不过当前的案例还比较粗糙，需要使用的同学还需根据自己的情况完善里面的逻辑，进一步的封装以期得到更好的效果。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture接口</title>
    <link href="/2024/01/29/CompletableFuture/"/>
    <url>/2024/01/29/CompletableFuture/</url>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><p>学习CompletableFuture</p><ul><li>CompletableFuture的使用</li><li>CompletableFure异步和同步的性能测试</li><li>已经有了Future为什么仍需要在JDK1.8中引入CompletableFuture</li><li>CompletableFuture的应用场景</li><li>对CompletableFuture的使用优化</li></ul><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a><strong>场景说明</strong></h2><p>查询所有商店某个商品的价格并返回，并且查询商店某个商品的价格的API为同步 一个Shop类，提供一个名为getPrice的同步方法</p><ul><li>店铺类：Shop.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shop</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-comment">/**     * 根据产品名查找价格     * */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">(String product)</span> &#123;<br>            <span class="hljs-keyword">return</span> calculatePrice(product);<br>        &#125;<br>        <span class="hljs-comment">/**     * 计算价格     *     * </span><br><span class="hljs-comment">        <span class="hljs-doctag">@param</span> product     * </span><br><span class="hljs-comment">        <span class="hljs-doctag">@return</span>     * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculatePrice</span><span class="hljs-params">(String product)</span> &#123;<br>            delay();<br>            <span class="hljs-comment">//random.nextDouble()随机返回折扣     </span><br>            <span class="hljs-keyword">return</span> random.nextDouble() * product.charAt(<span class="hljs-number">0</span>) + product.charAt(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">/**     * 通过睡眠模拟其他耗时操作     * */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询商品的价格为同步方法，并通过sleep方法模拟其他操作。这个场景模拟了当需要调用第三方API，但第三方提供的是同步API，在无法修改第三方API时如何设计代码调用提高应用的性能和吞吐量，这时候可以使用CompletableFuture类</p><h2 id="CompletableFuture使用"><a href="#CompletableFuture使用" class="headerlink" title="CompletableFuture使用"></a><strong>CompletableFuture使用</strong></h2><p>Completable是Future接口的实现类，在JDK1.8中引入</p><ul><li><p><strong>CompletableFuture的创建：</strong></p><p>说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;Double&gt; futurePrice = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>使用CompletableFuture#completedFuture静态方法创建</p><p>参数的值为任务执行完的结果，一般该方法在实际应用中较少应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; completedFuture(U value) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span> &lt; U &gt; ((value == <span class="hljs-literal">null</span>) ? NIL : value);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用CompletableFuture#supplyAsync静态方法创建 supplyAsync有两个重载方法</p><p>两个重载方法之间的区别 =&gt; 后者可以传入自定义Executor，前者是默认的，使用的ForkJoinPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; supplyAsync(Supplier &lt; U &gt; supplier) &#123;<br>    <span class="hljs-keyword">return</span> asyncSupplyStage(asyncPool, supplier);<br>&#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; supplyAsync(Supplier &lt; U &gt; supplier, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用CompletableFuture#runAsync静态方法创建 runAsync有两个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Void &gt; runAsync(Runnable runnable) &#123;<br>    <span class="hljs-keyword">return</span> asyncRunStage(asyncPool, runnable);<br>&#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Void &gt; runAsync(Runnable runnable, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>supplyAsync和runAsync方法之间的区别 =&gt; 前者有返回值，后者无返回值Supplier是函数式接口，因此该方法需要传入该接口的实现类，追踪源码会发现在run方法中会调用该接口的方法。因此使用该方法创建CompletableFuture对象只需重写Supplier中的get方法，在get方法中定义任务即可。又因为函数式接口可以使用Lambda表达式，和new创建CompletableFuture对象相比代码会<strong>简洁</strong></p></li><li><p><strong>结果的获取：</strong> 对于结果的获取CompltableFuture类提供了四种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方式一</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//方式二</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br><span class="hljs-comment">//方式三</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getNow</span><span class="hljs-params">(T valueIfAbsent)</span>;<br><span class="hljs-comment">//方式四</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">join</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>说明：</p></li><li><p>get()和get(long timeout, TimeUnit unit) =&gt; 在Future中就已经提供了，后者提供超时处理，如果在指定时间内未获取结果将抛出超时异常</p></li><li><p>getNow =&gt; 立即获取结果不阻塞，结果计算已完成将返回结果或计算过程中的异常，如果未计算完成将返回设定的valueIfAbsent值</p></li><li><p>join =&gt; 方法里不会抛出异常</p><p>示例：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AcquireResultTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">//getNow方法测试   </span><br>        CompletableFuture &lt; String &gt; cp1 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>        &#125;);<br>        System.out.println(cp1.getNow(<span class="hljs-string">&quot;hello h2t&quot;</span>));<br>        <span class="hljs-comment">//join方法测试     </span><br>        CompletableFuture &lt; Integer &gt; cp2 = CompletableFuture.supplyAsync((() - &gt; <span class="hljs-number">1</span> / <span class="hljs-number">0</span>));<br>        System.out.println(cp2.join());<br>        <span class="hljs-comment">//get方法测试   </span><br>        CompletableFuture &lt; Integer &gt; cp3 = CompletableFuture.supplyAsync((() - &gt; <span class="hljs-number">1</span> / <span class="hljs-number">0</span>));<br>        System.out.println(cp3.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>第一个执行结果为hello h2t，因为要先睡上1分钟结果不能立即获取</li><li>join方法获取结果方法里不会抛异常，但是执行结果会抛异常，抛出的异常为CompletionException</li><li>get方法获取结果方法里将抛出异常，执行结果抛出的异常为ExecutionException</li><li><strong>异常处理：</strong> 使用静态方法创建的CompletableFuture对象无需显示处理异常，使用new创建的对象需要调用completeExceptionally方法设置捕获到的异常，举例说明：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CompletableFuture</span> <span class="hljs-variable">completableFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() - &gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//doSomething，调用complete方法将其他方法的执行结果记录在completableFuture对象中  </span><br>        completableFuture.complete(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">//异常处理     </span><br>        completableFuture.completeExceptionally(e);<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="同步方法Pick异步方法查询所有店铺某个商品价格"><a href="#同步方法Pick异步方法查询所有店铺某个商品价格" class="headerlink" title="同步方法Pick异步方法查询所有店铺某个商品价格"></a><strong>同步方法Pick异步方法查询所有店铺某个商品价格</strong></h2><p>店铺为一个列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; Shop &gt; shopList = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;BestPrice&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;LetsSaveBig&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;MyFavoriteShop&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shop</span>(<span class="hljs-string">&quot;BuyItAll&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>同步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; String &gt; findPriceSync(String product) &#123;<br>    <span class="hljs-keyword">return</span> shopList.stream().map(shop - &gt; String.format(<span class="hljs-string">&quot;%s price is %.2f&quot;</span>, shop.getName(), shop.getPrice(product))) <span class="hljs-comment">//格式转换      </span><br>        .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>异步方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; String &gt; findPriceAsync(String product) &#123;<br>    List &lt; CompletableFuture &lt; String &gt;&gt; completableFutureList = shopList.stream() <span class="hljs-comment">//转异步执行     </span><br>        .map(shop - &gt; CompletableFuture.supplyAsync(() - &gt; String.format(<span class="hljs-string">&quot;%s price is %.2f&quot;</span>, shop.getName(), shop.getPrice(product)))) <span class="hljs-comment">//格式转换       </span><br>        .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> completableFutureList.stream().map(CompletableFuture::join) <span class="hljs-comment">//获取结果不会抛出异常</span><br>        .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性能测试结果：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Find Price Sync Done <span class="hljs-keyword">in</span> 4141Find Price Async Done <span class="hljs-keyword">in</span> 1033<br></code></pre></td></tr></table></figure><p><strong>异步</strong> 执行效率<strong>提高四倍</strong></p><h3 id="为什么仍需要CompletableFuture"><a href="#为什么仍需要CompletableFuture" class="headerlink" title="为什么仍需要CompletableFuture"></a>为什么仍需要CompletableFuture</h3><p>在JDK1.8以前，通过调用线程池的submit方法可以让任务以异步的方式运行，该方法会返回一个Future对象，通过调用get方法获取异步执行的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List &lt; String &gt; findPriceFutureAsync(String product) &#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    List &lt; Future &lt; String &gt;&gt; futureList = shopList.stream().map(shop - &gt; es.submit(() - &gt; String.format(<span class="hljs-string">&quot;%s price is %.2f&quot;</span>, shop.getName(), shop.getPrice(product)))).collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> futureList.stream().map(f - &gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = f.get();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;).collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>既生瑜何生亮，为什么仍需要引入CompletableFuture？对于简单的业务场景使用Future完全没有，但是想将多个异步任务的计算结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值等等，使用Future提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以<strong>声明式</strong> 的方式优雅的处理这些需求。而且在Future编程中想要拿到Future的值然后拿这个值去做后续的计算任务，只能通过轮询的方式去判断任务是否完成这样非常占CPU并且代码也不优雅，用伪代码表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (future.isDone()) &#123;<br>    result = future.get();<br>    doSomrthingWithResult(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>但CompletableFuture提供了API帮助我们实现这样的需求</p><h3 id="其他API介绍"><a href="#其他API介绍" class="headerlink" title="其他API介绍"></a>其他API介绍</h3><h3 id="whenComplete计算结果的处理："><a href="#whenComplete计算结果的处理：" class="headerlink" title="whenComplete计算结果的处理："></a>whenComplete计算结果的处理：</h3><p>对前面计算结果进行处理，无法返回新值 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; T &gt; whenComplete(BiConsumer &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable &gt; action)<br>    <span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; T &gt; whenCompleteAsync(BiConsumer &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable &gt; action)<br>    <span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; T &gt; whenCompleteAsync(BiConsumer &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable &gt; action, Executor executor)<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>BiFunction&lt;? super T,? super U,? extends V&gt; fn参数 =&gt; 定义对结果的处理</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>以async结尾的方法将会在一个新的线程中执行组合操作</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WhenCompleteTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CompletableFuture &lt; String &gt; cf1 = CompletableFuture.supplyAsync(() - &gt; <span class="hljs-string">&quot;hello&quot;</span>);<br>        CompletableFuture &lt; String &gt; cf2 = cf1.whenComplete((v, e) - &gt; System.out.println(String.format(<span class="hljs-string">&quot;value:%s, exception:%s&quot;</span>, v, e)));<br>        System.out.println(cf2.join());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="thenApply转换："><a href="#thenApply转换：" class="headerlink" title="thenApply转换："></a>thenApply转换：</h3><p>将前面计算结果的的CompletableFuture传递给thenApply，返回thenApply处理后的结果。可以认为通过thenApply方法实现<code>CompletableFuture&lt;T&gt;</code>至<code>CompletableFuture&lt;U&gt;</code>的转换。白话一点就是将CompletableFuture的计算结果作为thenApply方法的参数，返回thenApply方法处理后的结果 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenApply(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>    &#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenApplyAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniApplyStage(asyncPool, fn);<br>    &#125;<br><span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenApplyAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; fn, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> uniApplyStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>Function&lt;? super T,? extends U&gt; fn参数 =&gt; 对前一个CompletableFuture 计算结果的转化操作</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>以async结尾的方法将会在一个新的线程中执行组合操作 示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenApplyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Integer &gt; result = CompletableFuture.supplyAsync(ThenApplyTest::randomInteger).thenApply((i) - &gt; i * <span class="hljs-number">8</span>);<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">randomInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里将前一个CompletableFuture计算出来的结果扩大八倍</p><h3 id="thenAccept结果处理："><a href="#thenAccept结果处理：" class="headerlink" title="thenAccept结果处理："></a>thenAccept结果处理：</h3><p>thenApply也可以归类为对结果的处理，thenAccept和thenApply的区别就是没有返回值 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; Void &gt; thenAccept(Consumer &lt;? <span class="hljs-built_in">super</span> T &gt; action) &#123;<br>        <span class="hljs-keyword">return</span> uniAcceptStage(<span class="hljs-literal">null</span>, action);<br>    &#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; Void &gt; thenAcceptAsync(Consumer &lt;? <span class="hljs-built_in">super</span> T &gt; action) &#123;<br>        <span class="hljs-keyword">return</span> uniAcceptStage(asyncPool, action);<br>    &#125;<br><span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> CompletableFuture &lt; Void &gt; thenAcceptAsync(Consumer &lt;? <span class="hljs-built_in">super</span> T &gt; action, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> uniAcceptStage(screenExecutor(executor), action);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>Consumer&lt;? super T&gt; action参数 =&gt; 对前一个CompletableFuture计算结果的操作</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>同理以async结尾的方法将会在一个新的线程中执行组合操作 示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenAcceptTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        CompletableFuture.supplyAsync(ThenAcceptTest::getList).thenAccept(strList - &gt; strList.stream().forEach(m - &gt; System.out.println(m)));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List &lt; String &gt; getList() &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将前一个CompletableFuture计算出来的结果打印出来</p><h3 id="thenCompose异步结果流水化："><a href="#thenCompose异步结果流水化：" class="headerlink" title="thenCompose异步结果流水化："></a>thenCompose异步结果流水化：</h3><p>thenCompose方法可以将两个异步操作进行流水操作 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenCompose(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletionStage</span> &lt; U &gt;&gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniComposeStage(<span class="hljs-literal">null</span>, fn);<br>    &#125;<br><span class="hljs-comment">//方法二</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenComposeAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletionStage</span> &lt; U &gt;&gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> uniComposeStage(asyncPool, fn);<br>    &#125;<br><span class="hljs-comment">//方法三</span><br><span class="hljs-keyword">public</span> &lt; U &gt; CompletableFuture &lt; U &gt; thenComposeAsync(Function &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CompletionStage</span> &lt; U &gt;&gt; fn, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> uniComposeStage(screenExecutor(executor), fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn</code>参数 =&gt; 当前CompletableFuture计算结果的执行</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>同理以async结尾的方法将会在一个新的线程中执行组合操作 示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenComposeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Integer &gt; result = CompletableFuture.supplyAsync(ThenComposeTest::getInteger).thenCompose(i - &gt; CompletableFuture.supplyAsync(() - &gt; i * <span class="hljs-number">10</span>));<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">expandValue</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-keyword">return</span> num * <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="thenCombine组合结果："><a href="#thenCombine组合结果：" class="headerlink" title="thenCombine组合结果："></a>thenCombine组合结果：</h3><p>thenCombine方法将两个无关的CompletableFuture组合起来，第二个Completable并不依赖第一个Completable的结果 提供了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法一</span><br><span class="hljs-keyword">public</span> &lt; U, V &gt; CompletableFuture &lt; V &gt; thenCombine(CompletionStage &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; other, BiFunction &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> biApplyStage(<span class="hljs-literal">null</span>, other, fn);<br>    &#125;<br><span class="hljs-comment">//方法二 </span><br><span class="hljs-keyword">public</span> &lt; U, V &gt; CompletableFuture &lt; V &gt; thenCombineAsync(CompletionStage &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; other, BiFunction &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span> &gt; fn) &#123;<br>        <span class="hljs-keyword">return</span> biApplyStage(asyncPool, other, fn);<br>    &#125;<br><span class="hljs-comment">//方法三 </span><br><span class="hljs-keyword">public</span> &lt; U, V &gt; CompletableFuture &lt; V &gt; thenCombineAsync(CompletionStage &lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">U</span> &gt; other, BiFunction &lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> U, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span> &gt; fn, Executor executor) &#123;<br>    <span class="hljs-keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>CompletionStage&lt;? extends U&gt; other参数 =&gt; 新的CompletableFuture的计算结果</li><li>BiFunction&lt;? super T,? super U,? extends V&gt; fn参数 =&gt; 定义了两个CompletableFuture对象<strong>完成计算后</strong> 如何合并结果，该参数是一个函数式接口，因此可以使用Lambda表达式</li><li>Executor executor参数 =&gt; 自定义线程池</li><li>同理以async结尾的方法将会在一个新的线程中执行组合操作</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThenCombineTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Integer &gt; result = CompletableFuture.supplyAsync(ThenCombineTest::randomInteger).thenCombine(CompletableFuture.supplyAsync(ThenCombineTest::randomInteger), (i, j) - &gt; i * j);<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">randomInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> random.nextInt(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将两个线程计算出来的值做一个乘法在返回</p><h3 id="allOf-amp-anyOf组合多个CompletableFuture："><a href="#allOf-amp-anyOf组合多个CompletableFuture：" class="headerlink" title="allOf&amp;anyOf组合多个CompletableFuture："></a>allOf&amp;anyOf组合多个CompletableFuture：</h3><p>方法介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//allOf</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Void &gt; allOf(CompletableFuture &lt;? &gt; ...cfs) &#123;<br>        <span class="hljs-keyword">return</span> andTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">//anyOf</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture &lt; Object &gt; anyOf(CompletableFuture &lt;? &gt; ...cfs) &#123;<br>    <span class="hljs-keyword">return</span> orTree(cfs, <span class="hljs-number">0</span>, cfs.length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>allOf =&gt; 所有的CompletableFuture都执行完后执行计算。</li><li>anyOf =&gt; 任意一个CompletableFuture执行完后就会执行计算</li></ul><p>示例：</p><ul><li>allOf方法测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllOfTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; Void &gt; future1 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>        CompletableFuture &lt; Void &gt; future2 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;);<br>        CompletableFuture &lt; Void &gt; result = CompletableFuture.allOf(future1, future2);<br>        System.out.println(result.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>allOf方法没有返回值，适合没有返回值并且需要前面所有任务执行完毕才能执行后续任务的应用场景</p><ul><li>anyOf方法测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnyOfTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        CompletableFuture &lt; String &gt; future1 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            randomSleep();<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        &#125;);<br>        CompletableFuture &lt; String &gt; future2 = CompletableFuture.supplyAsync(() - &gt; &#123;<br>            randomSleep();<br>            System.out.println(<span class="hljs-string">&quot;world&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;world&quot;</span>;<br>        &#125;);<br>        CompletableFuture &lt; Object &gt; result = CompletableFuture.anyOf(future1, future2);<br>        System.out.println(result.get());<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">randomSleep</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(random.nextInt(<span class="hljs-number">10</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个线程都会将结果打印出来，但是get方法只会返回最先完成任务的结果。该方法比较适合只要有一个返回值就可以继续执行其他任务的应用场景</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>很多方法都提供了异步实现【带async后缀】，但是需小心谨慎使用这些异步方法，因为异步意味着存在上下文切换，可能性能不一定比同步好。如果需要使用异步的方法，<strong>先做测试</strong> ，用测试数据说话！！！</p><h3 id="CompletableFuture的应用场景"><a href="#CompletableFuture的应用场景" class="headerlink" title="CompletableFuture的应用场景"></a>CompletableFuture的应用场景</h3><p>存在IO密集型的任务可以选择CompletableFuture，IO部分交由另外一个线程去执行。Logback、Log4j2异步日志记录的实现原理就是新起了一个线程去执行IO操作，这部分可以以CompletableFuture.runAsync(()-&gt;{ioOperation();})的方式去调用。如果是CPU密集型就不推荐使用了推荐使用并行流</p><h3 id="优化空间"><a href="#优化空间" class="headerlink" title="优化空间"></a>优化空间</h3><p>supplyAsync执行任务底层实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; supplyAsync(Supplier &lt; U &gt; supplier) &#123;<br>    <span class="hljs-keyword">return</span> asyncSupplyStage(asyncPool, supplier);<br>&#125;<br><span class="hljs-keyword">static</span> &lt; U &gt; CompletableFuture &lt; U &gt; asyncSupplyStage(Executor e, Supplier &lt; U &gt; f) &#123;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    CompletableFuture &lt; U &gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span> &lt; U &gt; ();<br>    e.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupply</span> &lt; U &gt; (d, f));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>底层调用的是线程池去执行任务，而CompletableFuture中默认线程池为ForkJoinPool</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">asyncPool</span> <span class="hljs-operator">=</span> useCommonPool ? ForkJoinPool.commonPool() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>();<br></code></pre></td></tr></table></figure><p>ForkJoinPool线程池的大小取决于CPU的核数。CPU密集型任务线程池大小配置为CPU核心数就可以了，但是IO密集型，线程池的大小由<strong>CPU数量 * CPU利用率 * (1 + 线程等待时间/线程CPU时间)</strong> 确定。而CompletableFuture的应用场景就是IO密集型任务，因此默认的ForkJoinPool一般无法达到最佳性能，我们需自己根据业务创建线程池。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发集合和线程池</title>
    <link href="/2024/01/23/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2024/01/23/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="并发集合和线程池"><a href="#并发集合和线程池" class="headerlink" title="并发集合和线程池"></a>并发集合和线程池</h1><h2 id="1-并发集合"><a href="#1-并发集合" class="headerlink" title="1. 并发集合"></a>1. 并发集合</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>**<code>JDK</code>**提供的这些容器⼤部分在<code>java.util.concurrent</code>包中。</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-5.png"></p><h3 id="1-2-ConcurrentHashMap"><a href="#1-2-ConcurrentHashMap" class="headerlink" title="1.2 ConcurrentHashMap"></a>1.2 ConcurrentHashMap</h3><blockquote><p><code>ConcurrentHashMap</code> 是一个高效的线程安全哈希表，使用分段锁实现并发访问控制，适用于高并发读写操作。</p></blockquote><h4 id="1-2-1-功能点"><a href="#1-2-1-功能点" class="headerlink" title="1.2.1 功能点"></a>1.2.1 功能点</h4><ul><li><strong>线程安全性：</strong> <code>ConcurrentHashMap</code> 是线程安全的，多个线程可以安全地并发读取和修改它的内容，而不需要额外的同步机制。</li><li><strong>分段锁：</strong> <code>ConcurrentHashMap</code> 内部使用了分段锁（Segment），它将整个数据结构分为多个片段，每个片段（Segment）上都有一个独立的锁。这样可以降低锁的粒度，提高并发度。</li><li><strong>并发级别：</strong> 在创建 <code>ConcurrentHashMap</code> 时，可以指定并发级别。并发级别表示同时可以进行修改操作的线程数。默认的并发级别是16。</li><li><strong>不支持 null 键和值：</strong> <code>ConcurrentHashMap</code> 不支持 null 作为键或值。如果你试图存储 null 值，它会抛出 <code>NullPointerException</code> 异常。</li><li><strong>初始化容量和负载因子：</strong> <code>ConcurrentHashMap</code> 允许你在构造函数中指定初始容量和负载因子。初始化容量是哈希表在创建时的容量大小，默认为 16。负载因子是哈希表在扩容时允许的最大填充比例，默认为 0.75。</li><li><strong>数据结构：</strong> <code>ConcurrentHashMap</code> 内部使用哈希表实现，每个 Segment 包含一个哈希桶数组，每个桶（Bucket）是一个链表或树结构，用于解决哈希冲突。</li><li><strong>扩容：</strong> 当哈希表中的元素数量达到容量的 3/4 时，哈希表会自动进行扩容操作，扩容后的容量是原来的两倍。</li><li><strong>迭代器弱一致性：</strong> <code>ConcurrentHashMap</code> 的迭代器提供了弱一致性的保证。这意味着它可能不会反映最新的映射表状态，因为它不会阻塞其他操作。但是，它不会抛出 <code>ConcurrentModificationException</code> 异常。</li><li><strong>性能：</strong> <code>ConcurrentHashMap</code> 提供了良好的并发性能，适用于高并发环境下的读写操作。</li></ul><h4 id="1-2-2-常用方法"><a href="#1-2-2-常用方法" class="headerlink" title="1.2.2 常用方法"></a>1.2.2 常用方法</h4><ul><li><code>put(K key, V value)</code>：将指定的值与此映射中的指定键相关联。</li><li><code>get(Object key)</code>：返回指定键所映射到的值。</li><li><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>：对映射中的每个键值对执行给定的操作。</li></ul><h4 id="1-2-3-适用场景"><a href="#1-2-3-适用场景" class="headerlink" title="1.2.3 适用场景"></a>1.2.3 适用场景</h4><ul><li>适用于多线程并发读写的场景，比如缓存、计数器等。</li><li>当需要高效并发地对键值对进行操作时，可以考虑使用 <code>ConcurrentHashMap</code>。</li></ul><p>1.2.4 源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 源码位置：jdk/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;<br>    <br>    <span class="hljs-comment">// 内部 Segment 数组</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;<br><br>    <span class="hljs-comment">// 构造函数，创建指定并发级别的 ConcurrentHashMap</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">int</span> concurrencyLevel)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="hljs-comment">// Use at least as many bins</span><br>            initialCapacity = concurrencyLevel;   <span class="hljs-comment">// as estimated threads</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> (<span class="hljs-type">long</span>)(<span class="hljs-number">1.0</span> + (<span class="hljs-type">long</span>)initialCapacity / loadFactor);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> (size &gt;= (<span class="hljs-type">long</span>)MAXIMUM_CAPACITY) ?<br>            MAXIMUM_CAPACITY : tableSizeFor((<span class="hljs-type">int</span>)size);<br>        <span class="hljs-built_in">this</span>.segments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>[concurrencyLevel];<br>        <span class="hljs-keyword">if</span> (initialCapacity / concurrencyLevel &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; segments.length; ++i)<br>            segments[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Segment</span>&lt;K,V&gt;(cap);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现机制：基于分段锁实现，并发访问不同段的数据时互不影响，提高了并发性能</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-ConcurrentLinkedQueue"><a href="#1-3-ConcurrentLinkedQueue" class="headerlink" title="1.3 ConcurrentLinkedQueue"></a>1.3 ConcurrentLinkedQueue</h3><blockquote><p><code>ConcurrentLinkedQueue</code> 是一个线程安全的无界队列，基于链表实现。</p></blockquote><h4 id="1-3-1-功能点"><a href="#1-3-1-功能点" class="headerlink" title="1.3.1 功能点"></a>1.3.1 功能点</h4><ul><li><strong>线程安全性：</strong> <code>ConcurrentLinkedQueue</code> 是线程安全的队列，支持多个线程同时执行插入和删除操作，而无需显式的同步。</li><li><strong>基于链表实现：</strong> 内部使用链表数据结构实现队列。这种实现使得插入和删除操作的时间复杂度为 O(1)，并且不会因为扩容而阻塞或者造成性能损失。</li><li><strong>无界队列：</strong> <code>ConcurrentLinkedQueue</code> 是一个无界队列，它的容量可以动态增长，直到耗尽系统内存。</li><li><strong>无阻塞式操作：</strong> 由于其基于链表实现，<code>ConcurrentLinkedQueue</code> 的插入和删除操作都是无阻塞的，即使在高并发情况下也不会发生阻塞。</li><li><strong>不支持 null 元素：</strong> <code>ConcurrentLinkedQueue</code> 不允许插入 null 元素。如果尝试插入 null 元素，将会抛出 <code>NullPointerException</code> 异常。</li><li><strong>迭代器弱一致性：</strong> <code>ConcurrentLinkedQueue</code> 的迭代器提供了弱一致性的保证。迭代器可能不会反映最新的队列状态，因为它不会阻塞其他操作。但是，它不会抛出 <code>ConcurrentModificationException</code> 异常。</li><li><strong>FIFO（先进先出）顺序：</strong> <code>ConcurrentLinkedQueue</code> 保持了元素插入的顺序，即先插入的元素会被先删除。</li><li><strong>无阻塞式迭代：</strong> 尽管 <code>ConcurrentLinkedQueue</code> 是线程安全的，但迭代时不需要加锁，因此迭代操作是无阻塞的。</li></ul><h4 id="1-3-2-适用场景"><a href="#1-3-2-适用场景" class="headerlink" title="1.3.2 适用场景"></a>1.3.2 适用场景</h4><ul><li>适用于多线程环境下的并发操作。</li><li>当需要高效并发地进行元素入队和出队操作时，可以考虑使用 <code>ConcurrentLinkedQueue</code>。</li></ul><h4 id="1-3-3-源码解析"><a href="#1-3-3-源码解析" class="headerlink" title="1.3.3 源码解析"></a>1.3.3 源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 源码位置：jdk/src/java.base/share/classes/java/util/concurrent/ConcurrentLinkedQueue.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;, Serializable &#123;<br><br>    <span class="hljs-comment">// 链表头和尾节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br><br>    <span class="hljs-comment">// 构造函数，创建一个空的 ConcurrentLinkedQueue</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentLinkedQueue</span><span class="hljs-params">()</span> &#123;<br>        head = tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现机制：使用原子操作和 volatile 关键字实现线程安全的插入和删除操作</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>底层由单向链表组成，每个节点结构如下</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-6.png"></p></li><li><p>构造函数中，创建了⼀个空节点作为链表中的第⼀个Node节点。</p></li></ul><h4 id="1-3-4-常用方法"><a href="#1-3-4-常用方法" class="headerlink" title="1.3.4 常用方法"></a>1.3.4 常用方法</h4><ul><li><p>add(E e)：将元素添加到队列尾部，如果队列已满，则抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;E&gt;(Objects.requireNonNull(e));<br><br>        <span class="hljs-keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<br>            Node&lt;E&gt; q = p.next;<br>            <span class="hljs-comment">/** case1: p是最后一个节点 */</span><br>            <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (NEXT.compareAndSet(p, <span class="hljs-literal">null</span>, newNode)) &#123;<br>                    <span class="hljs-comment">// 每2次，更新tail</span><br>                    <span class="hljs-keyword">if</span> (p != t)<br>                        TAIL.weakCompareAndSet(<span class="hljs-built_in">this</span>, t, newNode);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/** case2: 遇到哨兵节点（即next指向自己），从head开始遍历，但如果tail被修改，则使用tail(因为可能被修改正确了) */</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == q)<br>                p = (t != (t = tail)) ? t : head;<br>            <span class="hljs-comment">/** case3: 取tail节点-t,还是tail的next节点-q */</span><br>            <span class="hljs-keyword">else</span><br>                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>关于t != (t = tail)的判断，⾸先，“!=”并不是原⼦操作，它是可以被中断的。也就是说，在执⾏“!=”时，会先取得t的值，再执⾏t=tail，并取得新的t值。然后⽐较这两个值是否相等。</p><p>对tail的更新是会产⽣滞后的，也就是每次更新都会跳跃两个元素。这么做的⽬的，就是为了减少cas操作的次数,可以有效减少性能消耗。</p></blockquote></li><li><p>offer(E e)：将元素添加到队列尾部，如果队列已满，则返回 false。</p></li><li><p>poll()：获取并移除队首元素，如果队列为空，则返回 null。</p></li><li><p>peek()：获取但不移除队首元素，如果队列为空，则返回 null。</p></li></ul><h3 id="1-4-CopyOnWriteArrayList"><a href="#1-4-CopyOnWriteArrayList" class="headerlink" title="1.4 CopyOnWriteArrayList"></a>1.4 CopyOnWriteArrayList</h3><blockquote><p>CopyOnWriteArrayList 是一个线程安全的动态数组实现，采用写时复制的机制，适用于读多写少的场景。</p></blockquote><h4 id="1-4-1-功能点"><a href="#1-4-1-功能点" class="headerlink" title="1.4.1 功能点"></a>1.4.1 功能点</h4><ul><li><p><strong>线程安全性：</strong> <code>CopyOnWriteArrayList</code> 是线程安全的动态数组实现。它通过对底层数组进行写时复制（Copy-On-Write）来实现线程安全性，即在修改操作时会创建一个新的数组副本，从而避免了对原数组的并发修改。</p></li><li><p><strong>写时复制机制：</strong> 写时复制机制确保了在迭代过程中，不会出现并发修改异常（ConcurrentModificationException）。当有写操作（如添加、删除、修改元素）发生时，会先复制一份当前数组，然后在副本上进行修改，最后再将修改后的副本替换原数组。</p></li><li><p><strong>读操作性能：</strong> 由于读操作不需要加锁，因此 <code>CopyOnWriteArrayList</code> 在读操作上具有较好的性能，适用于读多写少的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Object[] getArray() &#123;<br><span class="hljs-keyword">return</span> array;<br>&#125;<br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-keyword">return</span> elementAt(getArray(), index);<br>&#125;<br><span class="hljs-keyword">static</span> &lt;E&gt; E <span class="hljs-title function_">elementAt</span><span class="hljs-params">(Object[] a, <span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-keyword">return</span> (E) a[index];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>读操作⽐较简单，就是从数组中获取对应下标为index的元素，⽽由于读操作并不需要加锁，所以，<br>get⽅法就是⼀个普通的不加锁的⽅法。</p></blockquote></li><li><p><strong>写操作性能：</strong> 写操作需要复制整个数组，因此在写操作上的性能相对较差。但由于写操作很少会影响到读操作，因此适用于读多写少的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            Object[] es = getArray();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> es.length;<br>            <span class="hljs-comment">// 产生一个原数组长度加1的副本数组</span><br>            es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<br>            es[len] = e; <span class="hljs-comment">// 在副本数组中进行修改操作</span><br>            setArray(es); <span class="hljs-comment">// 将副本数组替换旧数组</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 由于array是volatile的，所以多线程之间保持可见性</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">(Object[] a)</span> &#123;<br>array = a;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>执⾏写操作的时候，针对的是副本数组；⽽读操作，⼀直是针对着原数组；所以，写操作是不会阻塞读操作的。</p></blockquote></li><li><p><strong>内存消耗：</strong> 由于每次写操作都需要复制整个数组，因此 <code>CopyOnWriteArrayList</code> 的内存消耗比较高。对于存储大量数据的场景，可能会消耗大量的内存。</p></li><li><p><strong>迭代器弱一致性：</strong> <code>CopyOnWriteArrayList</code> 的迭代器提供了弱一致性的保证，即迭代器可能不会反映最新的列表状态。这是由于迭代器在创建时会持有一个指向原数组的引用，并且不会阻止其他线程对列表进行修改。</p></li><li><p><strong>支持并发迭代：</strong> <code>CopyOnWriteArrayList</code> 支持并发迭代，即允许在迭代过程中进行并发的修改操作，而不会抛出并发修改异常。</p></li></ul><h4 id="1-4-2-源码解析"><a href="#1-4-2-源码解析" class="headerlink" title="1.4.2 源码解析"></a>1.4.2 源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 源码位置：jdk/src/java.base/share/classes/java/util/concurrent/CopyOnWriteArrayList.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;<br><br>    <span class="hljs-comment">// 内部数组，用于存储元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br><br>    <span class="hljs-comment">// 构造函数，创建一个空的 CopyOnWriteArrayList</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CopyOnWriteArrayList</span><span class="hljs-params">()</span> &#123;<br>        setArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 实现机制：在修改时先复制一份新的数组，然后进行修改操作，最后将新数组替换旧数组</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-3-常用方法"><a href="#1-4-3-常用方法" class="headerlink" title="1.4.3 常用方法"></a>1.4.3 常用方法</h4><ul><li>add(E e)：将元素添加到列表末尾。</li><li>get(int index)：返回列表中指定位置的元素。</li></ul><h4 id="1-4-4-适用场景"><a href="#1-4-4-适用场景" class="headerlink" title="1.4.4 适用场景"></a>1.4.4 适用场景</h4><ul><li>适用于读多写少的场景，例如观察者模式中的事件通知列表。</li><li>当需要对列表进行读取频繁、写入操作较少且不需要实时反映写入结果时，可以考虑使用 CopyOnWriteArrayList。</li></ul><h3 id="1-5-BlockingQueue"><a href="#1-5-BlockingQueue" class="headerlink" title="1.5 BlockingQueue"></a>1.5 BlockingQueue</h3><blockquote><p>BlockingQueue 是一个阻塞队列接口，提供了阻塞式的添加和移除元素的操作。</p></blockquote><h4 id="1-5-1-功能点"><a href="#1-5-1-功能点" class="headerlink" title="1.5.1 功能点"></a>1.5.1 功能点</h4><ul><li><strong>阻塞操作：</strong> <code>BlockingQueue</code> 是一个接口，它支持在队列为空时阻塞等待元素的到来，或者在队列已满时阻塞等待空间的释放。</li><li><strong>线程安全性：</strong> <code>BlockingQueue</code> 实现了线程安全的队列操作，可以安全地在多个线程之间进行元素的插入和删除。</li><li><strong>多种实现：</strong> Java 提供了多种 <code>BlockingQueue</code> 的实现，例如 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>PriorityBlockingQueue</code> 等，每种实现都有不同的特点和适用场景。</li><li><strong>有界和无界队列：</strong> <code>BlockingQueue</code> 可以是有界队列或无界队列。有界队列在初始化时需要指定容量，而无界队列则可以动态地增长，直到耗尽系统内存。</li><li><strong>等待策略：</strong> <code>BlockingQueue</code> 支持多种等待策略，例如等待超时、等待中断、阻塞等待等，开发人员可以根据具体需求选择合适的等待策略。</li><li><strong>生产者-消费者模式：</strong> <code>BlockingQueue</code> 常用于实现生产者-消费者模式，生产者将任务放入队列，消费者从队列中取出任务并执行，通过阻塞等待实现了生产者和消费者之间的解耦。</li><li><strong>可选方法：</strong> 除了基本的插入和删除操作外，<code>BlockingQueue</code> 还提供了一些可选的方法，如<code>put()</code>、<code>take()</code>、<code>offer()</code>、<code>poll()</code> 等，用于在特定条件下进行阻塞或非阻塞的操作。</li><li><strong>异常和特殊返回值：</strong> 在某些情况下，<code>BlockingQueue</code> 的插入和删除操作可能会抛出异常或返回特殊值来表示操作失败，开发人员需要根据具体情况处理这些异常或特殊返回值。</li></ul><h4 id="1-5-2-常用方法"><a href="#1-5-2-常用方法" class="headerlink" title="1.5.2 常用方法"></a>1.5.2 常用方法</h4><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-7.png"></p><blockquote><p>由于使⽤offer⽅法时，如果队列已经满了，那么则⽆法插⼊成功，会⽴即返回false；同样的，当我们调⽤poll⽅法的时候，如果队列中是空的，则也会⽴即返回false；⽽⽐起⽴即返回的情况，我们更关注于put和take这种插⼊或移除失败，在当前阻塞的情况是如何实现的。</p></blockquote><h4 id="1-5-3-常用实现类"><a href="#1-5-3-常用实现类" class="headerlink" title="1.5.3 常用实现类"></a>1.5.3 常用实现类</h4><ul><li>ArrayBlockingQueue：基于数组的有界阻塞队列。</li><li>LinkedBlockingQueue：基于链表的可选有界阻塞队列。</li><li>PriorityBlockingQueue：带优先级的无界阻塞队列。</li></ul><h4 id="1-5-4-源码解析"><a href="#1-5-4-源码解析" class="headerlink" title="1.5.4 源码解析"></a>1.5.4 源码解析</h4><p><code>ArrayBlockingQueue</code> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 源码位置：jdk/src/java.base/share/classes/java/util/concurrent/ArrayBlockingQueue.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BlockingQueue</span>&lt;E&gt;, java.io.Serializable &#123;<br><br>    <span class="hljs-comment">// 存储元素的数组</span><br>    <span class="hljs-keyword">final</span> Object[] items;<br>    <span class="hljs-comment">// 插入和删除元素的索引位置</span><br>    <span class="hljs-type">int</span> putIndex;<br>    <span class="hljs-type">int</span> takeIndex;<br>    <span class="hljs-comment">// 当前队列中元素的数量</span><br>    <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-comment">// 构造函数，创建指定容量的 ArrayBlockingQueue</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>(capacity, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认采用非公平锁</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数，创建指定容量和是否公平的 ArrayBlockingQueue</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>        <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>        <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>        notEmpty = lock.newCondition();<br>        notFull =  lock.newCondition();<br>    &#125;<br><br>    <span class="hljs-comment">// 实现机制：使用重入锁和条件变量实现阻塞式插入和删除操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造函数，默认采⽤⾮公平锁</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-8.png"></p><blockquote><p>由操作函数⼊参capacity来指定底层存储元素数组⻓度的⼤⼩。<br>并且初始化了需要加锁使⽤的ReentrantLock实例，默认采⽤的是⾮公平锁。<br>notEmpty⽤于执⾏take时进⾏await()等待操作，put时进⾏signal()唤醒操作。<br>notFull⽤于执⾏take时进⾏signal()唤醒操作，put时进⾏await()等待操作。</p></blockquote></li><li><p>put⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      Objects.requireNonNull(e);<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>      lock.lockInterruptibly(); <span class="hljs-comment">// 添加可被中断锁</span><br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">while</span> (count == items.length)<br>              notFull.await(); <span class="hljs-comment">// 队列满了，则阻塞等待，同时释放持有的锁</span><br>          <span class="hljs-comment">// 入队操作</span><br>          enqueue(e);<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(E e)</span> &#123;<br>      <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>      items[putIndex] = e;<br>      <span class="hljs-comment">// 如果插入到了数组末尾，则重置putIndex，从0开始继续插入</span><br>      <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>      count++;<br>      notEmpty.signal(); <span class="hljs-comment">// 通知线程接触阻塞</span><br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在执⾏put⽅法逻辑之前，⾸先尝试获得可中断锁——即：lock.lockInterruptibly()，当执⾏interrupt操作时，该锁可以被中断。<br>如果数组中元素的个数（count）等于数组的⻓度了，也就说明队列满了，那么就在该线程上执⾏等待操作——notFull.await()；<br>如果队列没有满，则调⽤enqueue(e)⽅法执⾏⼊列操作。<br>⼊列操作⾸先会将待插⼊值x放⼊数组下标为putIndex的位置上，然后再将putIndex加1，来指向下⼀次插⼊的下标位置。此处需要注意的是，如果加1后的putIndex等于了数组的⻓度，那么说明已经越界了（因为putIndex是从0开始的），那么此时将putIndex置为0，即：待插⼊的指针指向了数组的头部。做循环式插⼊。<br>最后，执⾏count++来计算元素总个数，并且调⽤notEmpty.signal()⽅法来解除阻塞（即：当队列为空的时候，执⾏take⽅法会被notEmpty.await()阻塞）</p></blockquote></li><li><p>take⽅法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>      lock.lockInterruptibly();<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>              notEmpty.await(); <span class="hljs-comment">// 队列为空，则阻塞等待，同时释放持有的锁</span><br>          <span class="hljs-keyword">return</span> dequeue(); <span class="hljs-comment">// 执行出对操作</span><br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-built_in">this</span>.items;<br>      <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>      <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) items[takeIndex]; <span class="hljs-comment">// 获得对应下标的元素</span><br>      items[takeIndex] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 将对应元素置为null，方便GC</span><br>      <span class="hljs-comment">// 如果出对操作到了数组末尾，则重置putIndex，从0开始继续插入</span><br>      <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>      count--; <span class="hljs-comment">// 数组中总元素个数-1</span><br>      <span class="hljs-keyword">if</span> (itrs != <span class="hljs-literal">null</span>)<br>          itrs.elementDequeued();<br>      notFull.signal(); <span class="hljs-comment">// 唤醒待插入元素的线程</span><br>      <span class="hljs-keyword">return</span> e;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>take⽅法跟上⾯我们看的put⽅法类似，区别是出队的指针是takeIndex。如果队列中为空，那么当调⽤take⽅法执⾏出队操作时，就会执⾏notEmpty.await()⽅法执⾏等待操作，并释放锁资源。当调⽤put⽅法向队列中放⼊元素之后 ，会调⽤notEmpty.signal⽅法对等待的线程执⾏唤醒<br>操作。那么线程继续执⾏出队操作，执⾏完毕后，会调⽤notFull.signal⽅法来唤醒在notFull上⾯await的线程。</p></blockquote></li></ul><h4 id="1-5-5-适用场景"><a href="#1-5-5-适用场景" class="headerlink" title="1.5.5 适用场景"></a>1.5.5 适用场景</h4><ul><li>适用于控制生产者和消费者之间速率的场景。</li><li>当需要在队列为空或队列已满时进行阻塞等待的情况下，可以使用 BlockingQueue。</li></ul><h3 id="1-6-ConcurrentSkipListMap"><a href="#1-6-ConcurrentSkipListMap" class="headerlink" title="1.6 ConcurrentSkipListMap"></a>1.6 ConcurrentSkipListMap</h3><blockquote><p>ConcurrentSkipListMap 是一个基于跳表实现的并发安全的有序映射表。</p></blockquote><h4 id="1-6-1-功能点"><a href="#1-6-1-功能点" class="headerlink" title="1.6.1 功能点"></a>1.6.1 功能点</h4><ul><li><strong>跳表（SkipList）：</strong> <code>ConcurrentSkipListMap</code> 是基于跳表（SkipList）数据结构实现的并发安全的有序映射表。跳表是一种可以在平均情况下实现对数时间复杂度的数据结构，类似于平衡树，但实现更简单。</li><li><strong>并发安全性：</strong> <code>ConcurrentSkipListMap</code> 是线程安全的，支持多个线程并发读写操作，无需额外的同步措施。</li><li><strong>有序映射表：</strong> <code>ConcurrentSkipListMap</code> 是一个有序的映射表，它将键值对按照键的自然顺序或者自定义顺序进行排序存储。默认情况下，使用键的自然顺序进行排序。</li><li><strong>快速查找：</strong> <code>ConcurrentSkipListMap</code> 支持快速的查找操作，平均时间复杂度为 O(log n)，其中 n 是映射表中键值对的数量。</li><li><strong>分层结构：</strong> 跳表采用了分层结构，每一层都是一个有序的链表，其中第一层包含所有元素，后续层包含一部分元素。通过不同层级的索引，可以快速定位到目标元素，从而实现快速查找。</li><li><strong>高并发访问：</strong> <code>ConcurrentSkipListMap</code> 内部使用 CAS（Compare and Swap）操作和锁来保证并发访问的线程安全性，同时保证了较高的并发性能。</li><li><strong>可扩展性：</strong> <code>ConcurrentSkipListMap</code> 具有良好的可扩展性，可以根据需要动态调整内部数据结构，以适应不同规模的数据存储需求。</li><li><strong>迭代器支持：</strong> <code>ConcurrentSkipListMap</code> 提供了迭代器支持，可以按照键的顺序进行迭代，迭代器提供了弱一致性的保证。</li></ul><h4 id="1-6-2-源码解析"><a href="#1-6-2-源码解析" class="headerlink" title="1.6.2 源码解析"></a>1.6.2 源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 源码位置：jdk/src/java.base/share/classes/java/util/concurrent/ConcurrentSkipListMap.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConcurrentNavigableMap</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br><br>    <span class="hljs-comment">// 跳表的头节点和尾节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;K,V&gt; tail;<br><br>    <span class="hljs-comment">// 构造函数，创建一个空的 ConcurrentSkipListMap</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentSkipListMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.comparator = <span class="hljs-literal">null</span>;<br>        initialize();<br>    &#125;<br><br>    <span class="hljs-comment">// 实现机制：基于跳表实现，每个节点维护多个层级的索引，通过更新索引来保证并发安全性和有序性</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-6-3-常用方法"><a href="#1-6-3-常用方法" class="headerlink" title="1.6.3 常用方法"></a>1.6.3 常用方法</h4><ul><li>put(K key, V value)：将指定的键值对添加到映射表中。</li><li>get(Object key)：返回指定键所映射到的值。</li><li>forEach(BiConsumer&lt;? super K,? super V&gt; action)：对映射表中的每个键值对执行给定的操作。</li></ul><h4 id="1-6-4-适用场景"><a href="#1-6-4-适用场景" class="headerlink" title="1.6.4 适用场景"></a>1.6.4 适用场景</h4><ul><li>适用于需要并发安全且有序的键值对存储的场景。</li><li>当需要对映射表进行高效并发操作且要求有序性时，可以考虑使用 ConcurrentSkipListMap。</li></ul><h2 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h2><blockquote><p>线程池是一种并发编程的机制，用于管理和复用线程，以提高程序的性能和资源利用率。</p></blockquote><p><strong>组件</strong></p><ul><li><p>线程池管理器：负责创建、管理和销毁线程池。</p></li><li><p>工作队列：用于存储待执行的任务。当线程池中的线程已达到上限，新任务会被放入工作队列中等待执行。</p></li><li><p>线程池的核心线程池大小：用于处理任务的最小线程数。</p></li><li><p>线程池的最大线程池大小：线程池允许的最大线程数。</p></li><li><p>线程池的存活时间：当线程池中的线程数量超过核心线程池大小时，多余的空闲线程在经过一定时间后会被销毁。</p></li><li><p>拒绝策略：用于处理当工作队列已满且线程池中的线程达到最大线程数时，新任务无法提交的情况。</p></li></ul><p><strong>工作流程</strong></p><ul><li><p>当有任务提交到线程池时，线程池会根据当前状态及配置决定是否创建新的线程。</p></li><li><p>如果当前线程池中的线程数量未达到核心线程池大小，则会创建新线程来处理任务。</p></li><li><p>如果线程池中的线程数量已经达到核心线程池大小，则会将任务放入工作队列中等待执行。</p></li><li><p>当工作队列已满且线程池中的线程数量未达到最大线程池大小时，会创建新的线程来处理任务。</p></li><li><p>当线程池中的线程数量达到最大线程池大小且工作队列已满时，根据配置的拒绝策略来处理新提交的任务。</p></li></ul><p><strong>优点</strong></p><ul><li>降低资源消耗：通过重用线程，减少了线程的创建和销毁所带来的开销。</li><li>提高响应速度：线程池中的线程可以立即处理任务，无需等待线程创建。</li><li>提高系统稳定性：通过控制线程数量，可以防止系统因过度创建线程而崩溃。</li></ul><h3 id="2-1-ThreadPoolExecutor"><a href="#2-1-ThreadPoolExecutor" class="headerlink" title="2.1 ThreadPoolExecutor"></a>2.1 ThreadPoolExecutor</h3><blockquote><p>管理线程池的一个重要类，它提供了一种高效地管理多线程任务的方式。</p></blockquote><h4 id="2-1-1-功能点"><a href="#2-1-1-功能点" class="headerlink" title="2.1.1 功能点"></a>2.1.1 功能点</h4><ul><li><p>线程池类型：ThreadPoolExecutor 是 ExecutorService 接口的实现，用于管理线程池。它支持核心线程数、最大线程数、线程存活时间、工作队列等参数的配置。</p></li><li><p>核心组件：ThreadPoolExecutor 主要由核心线程池、工作队列、线程工厂、拒绝策略等组件构成。</p></li><li><p>工作队列类型：工作队列可以是 BlockingQueue 接口的任何实现，如 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue 等，用于存储等待执行的任务。</p></li><li><p>线程池状态：ThreadPoolExecutor 有几种状态，包括 RUNNING、SHUTDOWN、STOP、TIDYING 和 TERMINATED。</p></li><li><p>拒绝策略：当任务无法被提交给线程池执行时，会触发拒绝策略。常见的拒绝策略有 AbortPolicy、CallerRunsPolicy、DiscardPolicy 和 DiscardOldestPolicy。</p></li></ul><h4 id="2-1-2-常用方法"><a href="#2-1-2-常用方法" class="headerlink" title="2.1.2 常用方法"></a>2.1.2 常用方法</h4><ul><li><p>execute(Runnable command)：提交一个任务给线程池执行。</p></li><li><p>submit(Callable<T> task)：提交一个带返回值的任务给线程池执行。</p></li><li><p>shutdown()：优雅地关闭线程池，等待所有任务执行完成。</p></li><li><p>shutdownNow()：立即关闭线程池，尝试终止所有正在执行的任务。</p></li><li><p>awaitTermination(long timeout, TimeUnit unit)：等待线程池中所有任务执行完成，在给定的超时时间内等待。</p></li></ul><h4 id="2-1-3-使用场景"><a href="#2-1-3-使用场景" class="headerlink" title="2.1.3 使用场景"></a>2.1.3 使用场景</h4><ul><li><p>批量处理任务：当需要处理大量任务时，使用线程池可以有效地管理线程资源，提高任务处理效率。</p></li><li><p>并发任务处理：需要并发处理多个任务，但是又不希望创建过多的线程，可以使用线程池来控制并发度。</p></li><li><p>异步任务执行：需要执行异步任务，例如后台数据处理、网络请求等，可以通过线程池来管理任务的执行。</p></li><li><p>限流：通过控制线程池的大小，可以限制并发执行的任务数量，从而保护系统资源不被耗尽。</p></li></ul><h4 id="2-1-4-注意点"><a href="#2-1-4-注意点" class="headerlink" title="2.1.4 注意点"></a>2.1.4 注意点</h4><ul><li><p>线程池大小选择：线程池大小应根据系统资源、任务性质、任务执行时间等因素进行合理选择，避免过度消耗资源或任务排队等待。</p></li><li><p>任务处理异常：在任务执行过程中，务必处理异常，避免异常导致线程退出，影响线程池的正常运行。</p></li><li><p>避免死锁：当任务中涉及到同步操作时，需注意避免死锁的发生，合理设计任务执行顺序和资源的申请释放。</p></li><li><p>性能调优：对于不同的应用场景，可能需要调整线程池的参数，例如核心线程数、最大线程数、工作队列大小等，以提高性能。</p></li><li><p>资源释放：在不需要使用线程池时，及时调用 shutdown() 方法关闭线程池，释放资源，避免资源泄漏。</p></li></ul><h4 id="2-1-5-拒绝策略"><a href="#2-1-5-拒绝策略" class="headerlink" title="2.1.5 拒绝策略"></a>2.1.5 拒绝策略</h4><ul><li><p>AbortPolicy（默认）：当线程池无法处理新任务时，会抛出 RejectedExecutionException 异常，表示拒绝接受新任务。</p></li><li><p>CallerRunsPolicy：当线程池无法处理新任务时，会由提交任务的线程来执行该任务。这意味着提交任务的线程会被阻塞，直到任务被执行。</p></li><li><p>DiscardPolicy：当线程池无法处理新任务时，会丢弃新任务，不会给出任何反馈。新任务被丢弃后，不会抛出异常也不会执行。</p></li><li><p>DiscardOldestPolicy：当线程池无法处理新任务时，会丢弃队列中最老的任务，然后尝试将新任务加入队列。这种策略能够保证队列中至少有一个位置用于接受新任务。</p></li></ul><h4 id="2-1-6-源码解析"><a href="#2-1-6-源码解析" class="headerlink" title="2.1.6 源码解析"></a>2.1.6 源码解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">// 核心线程池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// 最大线程池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;<br>    <span class="hljs-comment">// 最大线程池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;<br>    <span class="hljs-comment">// 线程存活时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> keepAliveTime;<br>    <span class="hljs-comment">// 工作队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> BlockingQueue&lt;Runnable&gt; workQueue;<br>    <span class="hljs-comment">// 线程工厂</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ThreadFactory threadFactory;<br>    <span class="hljs-comment">// 拒绝策略</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br>    <span class="hljs-comment">// 线程池状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                              TimeUnit unit,</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                              ThreadFactory threadFactory,</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br><br>    <span class="hljs-comment">// 线程池执行任务入口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            c = ctl.get();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))<br>                reject(command);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>            reject(command);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加工作线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>        retry:<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>            <span class="hljs-comment">// 检查线程池状态是否允许添加工作线程</span><br><br>            <span class="hljs-comment">// 创建新线程并启动</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法和内部类的实现</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ThreadPoolExecutor 类主要包含了核心线程池大小、最大线程池大小、线程存活时间、工作队列、线程工厂、拒绝策略等属性，以及相关的构造函数和方法。在 execute() 方法中，任务被提交给线程池执行，如果线程池已经达到核心线程数，则会根据具体情况决定是否创建新线程来执行任务或将任务加入工作队列。在 addWorker() 方法中，实现了工作线程的添加逻辑。</p></blockquote><h3 id="2-2-ForkJoinPool"><a href="#2-2-ForkJoinPool" class="headerlink" title="2.2 ForkJoinPool"></a>2.2 ForkJoinPool</h3><blockquote><p><code>ForkJoinPool</code> 是 Java 中用于支持任务并行化的线程池，它提供了一种特殊的任务分割和合并机制，适用于处理大规模数据的并行计算任务。</p></blockquote><h4 id="2-2-1-功能点"><a href="#2-2-1-功能点" class="headerlink" title="2.2.1 功能点"></a>2.2.1 功能点</h4><ul><li><strong>工作窃取算法</strong>：<code>ForkJoinPool</code> 使用工作窃取（Work-Stealing）算法来提高任务执行效率。每个线程都有自己的工作队列，当一个线程执行完自己队列中的任务后，会去其他线程的队列中窃取任务执行，以实现负载均衡。</li><li><strong>任务分割和合并</strong>：<code>ForkJoinPool</code> 支持将大任务分割成小任务并行执行，并在合适的时候将结果合并，以充分利用多核处理器的性能优势。</li><li><strong>递归分治</strong>：<code>ForkJoinPool</code> 适用于递归分治算法，例如归并排序、快速排序等。</li></ul><h4 id="2-2-2-类和接口"><a href="#2-2-2-类和接口" class="headerlink" title="2.2.2 类和接口"></a>2.2.2 类和接口</h4><ul><li><code>ForkJoinPool</code>：线程池的实现类，用于管理并执行 <code>ForkJoinTask</code>。</li><li><code>ForkJoinTask</code>：表示可以并行执行的任务的抽象类，包括两个重要的子类 <code>RecursiveAction</code> 和 <code>RecursiveTask</code>，分别用于表示没有返回值的任务和有返回值的任务。</li><li><code>RecursiveAction</code>：表示没有返回值的任务的抽象类，需要继承并实现 <code>compute()</code> 方法来定义具体任务的执行逻辑。</li><li><code>RecursiveTask</code>：表示有返回值的任务的抽象类，需要继承并实现 <code>compute()</code> 方法来定义具体任务的执行逻辑，并通过 <code>fork()</code> 方法将任务分割成子任务并行执行，最后通过 <code>join()</code> 方法合并子任务的结果。</li></ul><h4 id="2-2-3-使用场景"><a href="#2-2-3-使用场景" class="headerlink" title="2.2.3 使用场景"></a>2.2.3 使用场景</h4><ul><li><strong>递归任务并行化</strong>：适用于需要递归分治的算法，如归并排序、快速排序等。</li><li><strong>大规模数据处理</strong>：适用于处理大规模数据的并行计算任务，如图像处理、数据分析等。</li><li><strong>计算密集型任务</strong>：适用于需要充分利用多核处理器性能的计算密集型任务。</li></ul><h4 id="2-2-4-代码示例"><a href="#2-2-4-代码示例" class="headerlink" title="2.2.4 代码示例"></a>2.2.4 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.threadpools;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.concurrent.RecursiveAction;<br><span class="hljs-keyword">import</span> java.util.concurrent.RecursiveTask;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> ForkJoin示例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个 ForkJoinPool 对象</span><br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><br>        <span class="hljs-comment">// 创建一个 RecursiveTask 对象，用于计算斐波那契数列的第 10 项</span><br>        <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">fibonacciTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 提交任务并获取结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> forkJoinPool.invoke(fibonacciTask);<br>        System.out.println(<span class="hljs-string">&quot;Fibonacci(10) = &quot;</span> + result);<br><br>        <span class="hljs-comment">// 创建一个 RecursiveAction 对象，用于打印数组元素</span><br>        <span class="hljs-type">PrintArrayAction</span> <span class="hljs-variable">printArrayAction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintArrayAction</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br><br>        <span class="hljs-comment">// 提交任务</span><br>        forkJoinPool.invoke(printArrayAction);<br>    &#125;<br><br>    <span class="hljs-comment">// RecursiveTask 实现斐波那契数列的计算任务</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n;<br><br>        FibonacciTask(<span class="hljs-type">int</span> n) &#123;<br>            <span class="hljs-built_in">this</span>.n = n;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> n;<br>            &#125;<br>            <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">1</span>);<br>            task1.fork(); <span class="hljs-comment">// 异步执行</span><br>            <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">return</span> task2.compute() + task1.join(); <span class="hljs-comment">// 同步等待 task1 完成并获取其结果</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// RecursiveAction 实现打印数组元素的任务</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintArrayAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveAction</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] array;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> start;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> end;<br><br>        PrintArrayAction(<span class="hljs-type">int</span>[] array) &#123;<br>            <span class="hljs-built_in">this</span>(array, <span class="hljs-number">0</span>, array.length);<br>        &#125;<br><br>        PrintArrayAction(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>            <span class="hljs-built_in">this</span>.array = array;<br>            <span class="hljs-built_in">this</span>.start = start;<br>            <span class="hljs-built_in">this</span>.end = end;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (end - start &lt;= <span class="hljs-number">1</span>) &#123;<br>                System.out.println(array[start]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>                invokeAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintArrayAction</span>(array, start, mid), <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintArrayAction</span>(array, mid, end));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【解读】</p><blockquote><p>FibonacciTask 实现了计算斐波那契数列的任务，通过递归的方式进行分治计算。</p><p>PrintArrayAction 实现了打印数组元素的任务，通过递归地将数组拆分为更小的子数组来并行执行任务。</p><p>工作窃取算法：每个线程都有自己的任务队列，当一个线程执行完自己的任务后，会从其他线程的任务队列中窃取任务来执行。这样做可以减少线程因等待其他线程完成任务而导致的空闲时间，提高了整体的并发效率。</p></blockquote><h4 id="2-2-5-工作窃取算法"><a href="#2-2-5-工作窃取算法" class="headerlink" title="2.2.5 工作窃取算法"></a>2.2.5 工作窃取算法</h4><blockquote><ul><li>工作窃取算法是一种用于提高并行任务执行效率的调度算法，常被用于Fork-Join框架中。它的核心思想是充分利用多核处理器的并行计算能力，减少线程之间的竞争，从而提高整体的并发性能。</li><li>在工作窃取算法中，线程池中的每个工作线程都有自己的任务队列（通常是双端队列），用于存放待执行的任务。当一个线程完成了自己任务队列中的任务时，它会尝试从其他线程的任务队列中“窃取”任务来执行。这样做的目的是使得所有的线程尽可能保持忙碌状态，充分利用处理器资源，提高并发性能。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> &#123;<br>    <span class="hljs-comment">// 工作线程数组</span><br>    <span class="hljs-keyword">final</span> WorkQueue[] workQueues;<br><br>    <span class="hljs-comment">// 工作线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> top, base; <span class="hljs-comment">// 栈顶指针和栈底指针</span><br>        ForkJoinTask&lt;?&gt;[] array; <span class="hljs-comment">// 任务数组，通常是循环数组</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 工作窃取算法的核心方法之一：尝试从其他线程的任务队列中窃取任务并执行</span><br>    <span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; scan(WorkQueue workQueue) &#123;<br>        WorkQueue[] ws; <br>        <span class="hljs-type">int</span> m;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((ws = workQueues) != <span class="hljs-literal">null</span> &amp;&amp; (m = ws.length - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 随机选择一个其他线程的任务队列</span><br>                WorkQueue q;<br>                ForkJoinTask&lt;?&gt;[] a;<br>                <span class="hljs-type">int</span> b, i, s;<br>                <span class="hljs-keyword">if</span> ((q = ws[i = ThreadLocalRandom.nextSecondarySeed() &amp; m]) != <span class="hljs-literal">null</span> &amp;&amp;<br>                    (a = q.array) != <span class="hljs-literal">null</span> &amp;&amp;<br>                    (s = a.length - <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 尝试从队尾开始窃取任务</span><br>                    <span class="hljs-keyword">if</span> ((b = q.base) - q.top &lt; <span class="hljs-number">0</span> &amp;&amp;<br>                        (t = (ForkJoinTask&lt;?&gt;)U.getObject(a, (<span class="hljs-type">long</span>)((s &amp; (b - <span class="hljs-number">1</span>)) &lt;&lt; ASHIFT) + ABASE)) != <span class="hljs-literal">null</span> &amp;&amp;<br>                        U.compareAndSwapObject(a, (<span class="hljs-type">long</span>)((s &amp; (b - <span class="hljs-number">1</span>)) &lt;&lt; ASHIFT) + ABASE, t, <span class="hljs-literal">null</span>)) &#123;<br>                        q.base = b + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新栈底指针</span><br>                        workQueue.currentSteal = t;<br>                        <span class="hljs-keyword">return</span> t;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【解读】</p><ul><li><code>ForkJoinPool</code> 中的 <code>workQueues</code> 数组存放着所有工作线程的任务队列。</li><li>每个 <code>WorkQueue</code> 都是一个任务队列，其中包含了栈顶指针 <code>top</code> 和栈底指针 <code>base</code>，以及一个任务数组 <code>array</code>。</li><li>在 <code>scan()</code> 方法中，每个工作线程会反复尝试从其他线程的任务队列中窃取任务并执行。</li><li>通过随机选择一个其他线程的任务队列，并从队尾开始尝试窃取任务，从而减少线程之间的竞争。</li><li>窃取任务的过程是通过 CAS 操作来保证线程安全的，并更新相应的栈底指针。</li></ul><h2 id="3-Future"><a href="#3-Future" class="headerlink" title="3. Future"></a>3. Future</h2><blockquote><p><code>Future</code>接口表示异步计算的结果。它允许你提交一个任务，然后在后台执行，并在任务完成后获取结果。</p></blockquote><h3 id="3-1-FutureTask"><a href="#3-1-FutureTask" class="headerlink" title="3.1 FutureTask"></a>3.1 FutureTask</h3><blockquote><p>Java 并发框架中的一部分，从 Java 5 开始引入。它代表一个可以异步执行的任务，并提供了一种获取计算结果的方式。</p></blockquote><h4 id="3-1-1-功能点"><a href="#3-1-1-功能点" class="headerlink" title="3.1.1 功能点"></a>3.1.1 功能点</h4><ul><li><p>异步计算：FutureTask 允许你异步执行一个任务。它封装了计算过程，并提供了方法来检查计算是否已完成，必要时取消它，并在计算完成后获取结果。</p></li><li><p>结果获取：你可以使用 get() 方法获取计算的结果。如果计算尚未完成，get() 方法会阻塞直到结果可用。你还可以为 get() 指定超时时间。</p></li><li><p>取消任务：FutureTask 支持通过 cancel() 方法取消计算。这个方法接受一个参数表示是否中断正在执行的任务。</p></li></ul><h4 id="3-1-2-源码解析"><a href="#3-1-2-源码解析" class="headerlink" title="3.1.2 源码解析"></a>3.1.2 源码解析</h4><ul><li><p>FutureTask 的核心是其内部包含一个 RunnableFuture，它继承了 Runnable 和 Future 接口。在 FutureTask 的构造函数中，可以传入一个 Callable 或 Runnable 对象作为计算任务。FutureTask 的 run() 方法实际上会调用传入的 Callable 或 Runnable 对象的 call() 或 run() 方法，并将结果保存起来。</p></li><li><p>源码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.Future;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 内部任务对象，可以是 Callable 或 Runnable</span><br>    <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>    <span class="hljs-comment">// 计算结果</span><br>    <span class="hljs-keyword">private</span> V result;<br>    <span class="hljs-comment">// 任务是否已经完成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 构造函数，传入计算任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>        <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.callable = callable;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Runnable 接口的 run 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!done) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 调用 Callable 对象的 call 方法执行任务</span><br>                result = callable.call();<br>                done = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 任务完成</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// 处理异常</span><br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Future 接口的 get 方法</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-comment">// 如果任务尚未完成，则等待任务完成</span><br>        <span class="hljs-keyword">while</span> (!done) &#123;<br>            <span class="hljs-comment">// 等待任务完成</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回计算结果</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Future 接口的 get 方法，可以指定超时时间</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-comment">// 如果任务尚未完成，则等待任务完成，直到超时</span><br>        <span class="hljs-keyword">while</span> (!done) &#123;<br>            <span class="hljs-comment">// 等待任务完成，直到超时</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回计算结果</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Future 接口的 cancel 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>        <span class="hljs-comment">// 取消任务，返回任务是否被取消</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实现 Future 接口的 isDone 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> done; <span class="hljs-comment">// 返回任务是否已完成</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实现 RunnableFuture 接口的 run 方法，调用任务的 run 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        run(); <span class="hljs-comment">// 调用任务的 run 方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-使用场景"><a href="#3-1-3-使用场景" class="headerlink" title="3.1.3 使用场景"></a>3.1.3 使用场景</h4><ul><li><p>并发执行：当需要异步执行一个耗时的计算任务，并且需要获取计算结果时，可以使用 FutureTask。</p></li><li><p>任务组合：FutureTask 可以作为组合其他任务的方式，用于构建更复杂的并发任务结构。</p></li><li><p>任务调度：可以将 FutureTask 与线程池结合使用，实现任务的异步执行和管理。</p></li></ul><h4 id="3-1-4-注意事项"><a href="#3-1-4-注意事项" class="headerlink" title="3.1.4 注意事项"></a>3.1.4 注意事项</h4><ul><li><p>线程安全性：FutureTask 是线程安全的，多个线程可以同时操作一个 FutureTask 实例。</p></li><li><p>阻塞：get() 方法会阻塞当前线程，直到计算完成或超时。因此，在使用时需要注意可能的阻塞情况，避免影响程序的响应性能。</p></li><li><p>取消操作：取消任务时要注意处理任务已经开始执行的情况，以免出现资源泄漏或不一致的状态。</p></li></ul><h4 id="3-1-5-代码案例"><a href="#3-1-5-代码案例" class="headerlink" title="3.1.5 代码案例"></a>3.1.5 代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.threadpools;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> FutureTask示例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTaskExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个 Callable 对象，表示异步执行的计算任务</span><br>        Callable&lt;Integer&gt; callable = () -&gt; &#123;<br>            <span class="hljs-comment">// 模拟一个耗时的计算任务</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>        &#125;;<br><br>        <span class="hljs-comment">// 创建 FutureTask 对象，传入 Callable 对象</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br><br>        <span class="hljs-comment">// 启动一个线程执行 FutureTask</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取计算结果，get() 方法会阻塞直到计算完成</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>            System.out.println(<span class="hljs-string">&quot;计算结果：&quot;</span> + result);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;计算过程中发生异常&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;计算超时&quot;</span>);<br>            e.printStackTrace();<br>            <span class="hljs-comment">// 取消任务的执行</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> futureTask.cancel(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">if</span> (cancelled) &#123;<br>                System.out.println(<span class="hljs-string">&quot;任务已取消&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;任务无法取消，可能已经完成或已被取消&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 检查任务是否已完成</span><br>            <span class="hljs-keyword">if</span> (futureTask.isDone()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;任务已完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;任务尚未完成&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-CompletableFuture"><a href="#3-2-CompletableFuture" class="headerlink" title="3.2 CompletableFuture"></a>3.2 CompletableFuture</h3><p>详情查看CompletableFuture接口文章</p>]]></content>
    
    
    <categories>
      
      <category>&lt;并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合 线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发基础</title>
    <link href="/2024/01/20/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/01/20/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="1-Java内存模型"><a href="#1-Java内存模型" class="headerlink" title="1. Java内存模型"></a>1. Java内存模型</h2><ul><li>Java内存模型，即：JMM。当程序执⾏并⾏操作时，如果对数据的访问和操作不加以控制，那么必然会对程序的正确性造成破坏。因此，我们需要在深⼊了解并⾏机制的前提下，再定义⼀种规则，来保证多个线程间可以有效地、正确地协同⼯作，即JMM。</li><li>JMM的关键技术点都是围绕着多线程的原⼦性、可⻅性和有序性来创建的。</li></ul><h3 id="1-1-原⼦性（Atomicity）"><a href="#1-1-原⼦性（Atomicity）" class="headerlink" title="1.1 原⼦性（Atomicity）"></a>1.1 原⼦性（Atomicity）</h3><blockquote><p>指⼀个操作是不可中断的。即使是在多个线程⼀起执⾏的时候，⼀个操作⼀旦开始，就不会被其他<br>线程所⼲扰。</p></blockquote><p>⽐如⼀个int a，线程A对其赋值1，线程B对其赋值2，⽆论什么情况，a的值要么是1，要么是2；不会被线程A或线程B⼲扰。但是，如果是在32位操作系统中，操作64位的long类型数据的时候，就⽆法保证原⼦性了。因为赋值操作需要执⾏2次32位的操作，⽽在多线程的情况下，可能会出现“意想不到”的最终结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> long 操作的原子性实验</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonAtomicLongOperation</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">lowBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 低32位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">highBits</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 高32位</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">increaseThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>                increase();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">decreaseThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>                decrease();<br>            &#125;<br>        &#125;);<br><br>        increaseThread.start();<br>        decreaseThread.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            increaseThread.join();<br>            decreaseThread.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-comment">// 输出结果</span><br>        System.out.println(<span class="hljs-string">&quot;Low Bits: &quot;</span> + lowBits);<br>        System.out.println(<span class="hljs-string">&quot;High Bits: &quot;</span> + highBits);<br><br>        <span class="hljs-comment">// 组装成long型输出</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">long</span>) highBits &lt;&lt; <span class="hljs-number">32</span>) | (lowBits &amp; <span class="hljs-number">0xFFFFFFFFL</span>);<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>    &#125;<br><br>    <span class="hljs-comment">// 增加操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increase</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldLowBits</span> <span class="hljs-operator">=</span> lowBits;<br>        lowBits++;<br>        <span class="hljs-keyword">if</span> (oldLowBits == Integer.MAX_VALUE) &#123;<br>            highBits++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 减少操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrease</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldLowBits</span> <span class="hljs-operator">=</span> lowBits;<br>        lowBits--;<br>        <span class="hljs-keyword">if</span> (oldLowBits == Integer.MIN_VALUE) &#123;<br>            highBits--;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>【解释】</p><p>这段代码模拟了在多线程环境下对32位长整型数据进行增加和减少的操作，可以看到最终结果是不确定的，并且结果并不总是正确的。这就是因为对lowBits和highBits的操作不是原子性的，当多个线程同时对其进行操作时，会出现竞态条件，导致结果不确定。</p><h3 id="1-2-可⻅性（Visibility）"><a href="#1-2-可⻅性（Visibility）" class="headerlink" title="1.2 可⻅性（Visibility）"></a>1.2 可⻅性（Visibility）</h3><blockquote><p>指当⼀个线程修改了某⼀个共享变量的值，其他线程是否能够⽴即知道这个修改。</p></blockquote><p>如果在CPU_A和CPU_B上各运⾏了⼀个线程，它们共享变量t，由于编译器优化或者硬件优化的缘故， 在CPU_A上的线程将变量t进⾏了优化，将其缓存在cache中或者寄存器⾥。这种情况下，如果在CPU_B上的某个线程修改了变量t的实际值，那么CPU_A上的线程可能并⽆法意识到这个改动，依然会读取cache中或者寄存器⾥的数据。</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-1.png"></p><h3 id="1-3-有序性（Ordering）"><a href="#1-3-有序性（Ordering）" class="headerlink" title="1.3 有序性（Ordering）"></a>1.3 有序性（Ordering）</h3><blockquote><p>指的是对于多线程中的操作或事件，我们可以确定它们在时间上的顺序。在并发编程中，由于线程间的执行是并行的，并且可能涉及到指令重排等优化，因此有时候我们不能简单地假设代码的执行顺序与代码的编写顺序是一致的。有序性保证了程序的正确性和可预测性。</p></blockquote><ul><li><p><strong>程序顺序规则（Program Order Rule）</strong></p><p>程序中的每个操作都有一个全局的顺序。这意味着在一个线程中，操作按照代码编写的顺序执行，但是在多线程环境下，不同线程的操作可能会交错执行，因此需要通过同步机制来保证线程之间的操作顺序。</p></li><li><p><strong>内存顺序（Memory Ordering）</strong></p><p>内存顺序是指对共享内存的读写操作的顺序。在多线程环境下，由于线程之间的缓存一致性协议，可能会导致不同线程看到不同的操作顺序。内存顺序的保证可以通过内存屏障（Memory Barriers）等机制来实现。</p></li><li><p><strong>数据依赖性（Data Dependency）</strong></p><p>如果操作 B 依赖于操作 A 的结果，那么操作 A 在操作 B 之前执行是有序的。编译器和处理器可能会利用数据依赖性来进行指令重排优化，但是在多线程环境下，这种优化可能会导致问题，因此需要使用同步机制来保证有序性。</p></li></ul><h4 id="1-3-1-有序性方法"><a href="#1-3-1-有序性方法" class="headerlink" title="1.3.1 有序性方法"></a>1.3.1 有序性方法</h4><ul><li>使用同步机制，如锁、volatile、synchronized等，来保证多线程之间的操作顺序。</li><li>使用原子操作来确保单个操作的原子性，从而避免了指令重排等问题。</li><li>使用适当的内存屏障来控制内存访问的顺序。</li></ul><h4 id="1-3-2-Happen-Before规则"><a href="#1-3-2-Happen-Before规则" class="headerlink" title="1.3.2 Happen-Before规则"></a>1.3.2 Happen-Before规则</h4><ul><li>程序顺序原则：⼀个线程内保证语义的串⾏性。</li><li>volatile规则：volatile变量的写，先发⽣于读，这保证了volatile变量的可⻅性。</li><li>锁规则：解锁（unlock）必然发⽣在随后的加锁（lock）前。</li><li>传递性：A先于B，B先于C，那么A必然先于C。</li><li>线程的start()⽅法先于它的每⼀个动作。</li><li>线程的所有操作先于线程的终结Thread.join()。</li><li>线程的中断interrupt()先于被中断线程的代码。</li><li>对象的构造函数执、结束先于finalize()⽅法。</li></ul><h2 id="2-多线程基本操作"><a href="#2-多线程基本操作" class="headerlink" title="2. 多线程基本操作"></a>2. 多线程基本操作</h2><h3 id="2-1-线程状态"><a href="#2-1-线程状态" class="headerlink" title="2.1 线程状态"></a>2.1 线程状态</h3><h4 id="2-1-1-状态图"><a href="#2-1-1-状态图" class="headerlink" title="2.1.1 状态图"></a>2.1.1 状态图</h4><p>Thread里State枚举中定义</p><blockquote><ul><li><p>NEW：表示刚刚创建的线程，这种线程还没开始执⾏。</p></li><li><p>RUNNABLE：当调⽤start()⽅法时，处于该状态，表示线程所需的⼀切资源都已经准备好了。</p></li><li><p>BLOCKED：如果线程在执⾏过程中遇到了锁，就会进⼊该状态。</p></li><li><p>WAITING：处于⽆时间限制的等待状态。</p></li><li><p>TIMED: 处于有限的等待状态。</p></li><li><p>TERMINATED：当线程执⾏完毕，就进⼊结束状态。</p><p>【注意】从NEW状态出发后，线程不能再回到NEW状态，同理，处于TERMINATED的线程也不能再回到RUNNABLE状态。</p></li></ul></blockquote><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-2.png"></p><h3 id="2-2-stop（被废弃）"><a href="#2-2-stop（被废弃）" class="headerlink" title="2.2 stop（被废弃）"></a>2.2 stop（被废弃）</h3><p>JDK提供了stop⽅法⽤来关闭线程，但是该⽅法由于太过于暴⼒了，强⾏把执⾏到⼀半的线程终⽌，所以可能会引起⼀些数据不⼀致的问题。所以stop⽅法被标记为废弃⽅法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> stop终止线程示例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThreadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标志位，控制线程的运行状态</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (running) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread interrupted&quot;</span>);<br>                    <span class="hljs-comment">// 如果在睡眠期间线程被中断，则通过break语句退出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Thread stopped.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 停止线程的方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopThread</span><span class="hljs-params">()</span> &#123;<br>            running = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程休眠5秒后终止子线程</span><br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        thread.stopThread(); <span class="hljs-comment">// 终止线程</span><br><br>        <span class="hljs-comment">// 等待子线程结束</span><br>        thread.join();<br>        System.out.println(<span class="hljs-string">&quot;Main thread exiting.&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>【解释】</p><p>MyThread类继承了Thread类，并使用一个标志位running来控制线程的运行状态。线程的run()方法在循环中不断检查这个标志位，只有当标志位为true时才会继续执行，当标志位变为false时，线程退出循环，结束执行。</p><p>在main方法中，创建了一个MyThread对象，并启动该线程。然后主线程休眠5秒后调用stopThread()方法终止子线程，通过标志位的改变使子线程退出了循环。最后，主线程通过join()方法等待子线程执行结束，然后输出”Main thread exiting.”。</p><h3 id="2-3-interrupt-amp-isInterrupt-amp-interrupted"><a href="#2-3-interrupt-amp-isInterrupt-amp-interrupted" class="headerlink" title="2.3 interrupt&amp;isInterrupt&amp;interrupted"></a>2.3 interrupt&amp;isInterrupt&amp;interrupted</h3><blockquote><ul><li><p><strong>interrupt()方法</strong></p><p>Thread类中的interrupt()方法用于中断线程。当调用该方法时，会给目标线程发送一个中断信号，使得目标线程中断。需要注意的是，该方法并不会立即中断线程，而是设置线程的中断状态为true，线程可以通过检查中断状态来判断是否被中断。</p></li><li><p><strong>isInterrupted()方法</strong></p><p>Thread类中的isInterrupted()方法用于检查线程的中断状态。如果线程的中断状态为true，则返回true，否则返回false。这个方法是一个实例方法，可以通过线程对象调用。</p></li><li><p><strong>static interrupted()方法</strong></p><p>Thread类中的interrupted()方法用于检查当前线程的中断状态，并清除中断状态。如果当前线程的中断状态为true，则返回true，并将当前线程的中断状态清除；如果当前线程的中断状态为false，则返回false。这个方法是一个静态方法，可以直接通过Thread类调用。</p></li><li><p><strong>InterruptedException异常</strong></p><p>在Java的很多阻塞方法中（如Thread.sleep()、Object.wait()、BlockingQueue.take()等），如果线程在阻塞期间被中断，会抛出InterruptedException异常。这样的设计可以使得线程在被中断时能够有机会处理中断请求。</p></li></ul></blockquote><ul><li><p>线程中断并不会使线程⽴即退出，⽽是给线程发送⼀个通知，告知⽬标线程，有⼈希望你退出啦！⾄于⽬标线程接到通知后如何处理，则完全<code>由⽬标线程⾃⾏决定</code>。</p></li><li><p>“<code>完全由⽬标线程⾃⾏决定</code>”这⼀点⾮常重要，如果中断后，线程⽴即⽆条件退出，那么⼜会遇到跟stop()⽅法⼀样的⽼问题了。</p></li><li><p>代码示例</p><p><strong>interrupt()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 线程执行一段耗时操作</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Working &quot;</span> + i);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">// 当线程被中断时执行的操作</span><br>                System.out.println(<span class="hljs-string">&quot;Thread interrupted!&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        myThread.start(); <span class="hljs-comment">// 启动线程</span><br><br>        <span class="hljs-comment">// 主线程休眠3秒后中断myThread线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            myThread.interrupt(); <span class="hljs-comment">// 中断线程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>isInterrupted()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 判断线程是否被中断</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-comment">// 线程执行一段耗时操作</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Working&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-comment">// 当线程被中断时执行的操作</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread interrupted!&quot;</span>);<br>                    <span class="hljs-comment">// 重新设置中断状态</span><br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        myThread.start(); <span class="hljs-comment">// 启动线程</span><br><br>        <span class="hljs-comment">// 主线程休眠3秒后中断myThread线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            myThread.interrupt(); <span class="hljs-comment">// 中断线程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>interrupted()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 判断线程是否被中断</span><br>            <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>                <span class="hljs-comment">// 线程执行一段耗时操作</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Working&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-comment">// 当线程被中断时执行的操作</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread interrupted!&quot;</span>);<br>                    <span class="hljs-comment">// 重新设置中断状态</span><br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        myThread.start(); <span class="hljs-comment">// 启动线程</span><br><br>        <span class="hljs-comment">// 主线程休眠3秒后中断myThread线程</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>            myThread.interrupt(); <span class="hljs-comment">// 中断线程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-wait-amp-notify"><a href="#2-4-wait-amp-notify" class="headerlink" title="2.4 wait&amp;notify"></a>2.4 wait&amp;notify</h3><blockquote><ul><li><p><strong>wait()方法</strong></p><p>当一个线程调用对象的wait()方法时，它会释放对象的锁，并且进入等待状态，直到其他线程调用该对象的notify()或notifyAll()方法唤醒它。在等待期间，线程会阻塞，直到被唤醒或者等待超时。wait()方法通常用于线程间的同步和协作，比如等待某个条件满足后再继续执行。</p></li><li><p><strong>notify()方法</strong></p><p>用于唤醒正在等待该对象的锁的某个线程。如果有多个线程在等待同一个对象的锁，那么只会随机唤醒其中的一个线程。notify()方法通常与wait()方法配合使用，用于实现线程间的通信和协作。调用notify()方法后，并不会立即释放锁，而是等待当前同步代码块执行完毕才会释放锁。</p></li><li><p><strong>notifyAll()方法</strong></p><p>用于唤醒所有正在等待该对象的锁的线程。调用notifyAll()方法会唤醒所有等待该对象锁的线程，使它们有机会竞争锁。与notify()方法不同的是，notifyAll()会唤醒所有等待线程，而不是只唤醒一个。</p></li></ul></blockquote><ul><li><p>这两个⽅法是Object类提供的⽅法，也就是说，任何对象都可以调⽤这两个⽅法。⽤于⽀持多线程之间的协作操作。</p></li><li><p>线程A调⽤了<code>obj.wait()</code>⽅法，那么线程A就会停⽌继续执⾏，⽽转为等待状态。那么等待到何时才能结束呢？即：线程A会⼀直等到其他线程调⽤了<code>obj.notify()</code>⽅法为⽌。</p></li><li><p>如果⼀个线程调⽤了<code>object.wait()</code>，那么它就会进⼊object对象的等待队列。这个等待队列中，可能会有多个线程，因为系统运⾏多个线程同时等待某⼀个对象。当<code>object.notify()</code>被调⽤时，它就会从这个等待队列中，随机选择⼀个线程，并将其唤醒。这种选择是不公平的，是完全随机的。</p></li><li><p><code>notify()</code>和<code>notifyAll()</code>唤醒等待的线程的区别</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-4.png"></p></li><li><p>Object的<code>wait()</code>⽅法并不是可以随便调⽤的。它必须包含在对应的synchronized语句中，⽆论是<code>wait()</code>或<code>notify()</code>都需要⾸先获得⽬标对象的⼀个监视器。</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/concurrent-3.png"></p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 等待唤醒</span><br><span class="hljs-comment"> * 一个生产者线程和两个消费者线程共享一个对象作为锁，生产者线程生产完成后等待，消费者线程消费完后唤醒生产者线程继续生产。</span><br><span class="hljs-comment"> * 其中一个消费者线程使用notify()方法唤醒，另一个使用notifyAll()方法唤醒。程序输出将会显示各个线程的执行过程，以及wait()、notify()和notifyAll()方法的作用。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/11</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyExample</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 定义一个共享的对象作为锁</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;生产者开始生产...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 模拟生产过程，持续1秒</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;生产者等待消费者消费...&quot;</span>);<br>                    lock.wait(); <span class="hljs-comment">// 生产者等待消费者消费，释放锁</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;生产者继续生产...&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者开始消费...&quot;</span>);<br>                <span class="hljs-comment">// 模拟消费过程，持续2秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;消费者消费完成，唤醒生产者...&quot;</span>);<br>                lock.notify(); <span class="hljs-comment">// 唤醒生产者</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">consumerAll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                System.out.println(<span class="hljs-string">&quot;消费者All开始消费...&quot;</span>);<br>                <span class="hljs-comment">// 模拟消费过程，持续2秒</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;消费者All消费完成，唤醒生产者...&quot;</span>);<br>                lock.notifyAll(); <span class="hljs-comment">// 唤醒所有等待的生产者</span><br>            &#125;<br>        &#125;);<br><br>        producer.start(); <span class="hljs-comment">// 启动生产者线程</span><br>        consumer.start(); <span class="hljs-comment">// 启动消费者线程</span><br>        consumerAll.start(); <span class="hljs-comment">// 启动消费者All线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-5-join-amp-yield"><a href="#2-5-join-amp-yield" class="headerlink" title="2.5 join&amp;yield"></a>2.5 join&amp;yield</h3><h4 id="2-5-1-join-方法"><a href="#2-5-1-join-方法" class="headerlink" title="2.5.1 join()方法"></a>2.5.1 join()方法</h4><blockquote><p>Thread 类中的一个方法，它的作用是让一个线程等待另一个线程结束后再继续执行。</p></blockquote><ul><li><p>当一个线程调用另一个线程的 <code>join()</code> 方法时，当前线程将被挂起，直到目标线程执行完成或超时。</p></li><li><p>如果目标线程已经执行完成，则 <code>join()</code> 方法会立即返回。</p></li><li><p>如果设置了超时时间，则 <code>join(long millis)</code> 方法会在超时时间到达后返回。</p></li><li><p>源码解读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    join(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 判断是否超时</span><br>    <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果millis为0，则无限等待</span><br>    <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            wait(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>            <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            wait(delay);<br>            now = System.currentTimeMillis() - base;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 线程join</span><br><span class="hljs-comment"> * 主线程启动了两个子线程 thread1 和 thread2，然后通过 join() 方法等待它们执行完成。</span><br><span class="hljs-comment"> * 因此，主线程会一直等待，直到 thread1 和 thread2 都执行完毕后才会继续执行。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread 1 starts.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Thread 1 ends.&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Thread 2 starts.&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">4000</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Thread 2 ends.&quot;</span>);<br>        &#125;);<br><br>        thread1.start(); <span class="hljs-comment">// 启动线程1</span><br>        thread2.start(); <span class="hljs-comment">// 启动线程2</span><br><br>        thread1.join(); <span class="hljs-comment">// 等待线程1执行完成</span><br>        thread2.join(); <span class="hljs-comment">// 等待线程2执行完成</span><br><br>        System.out.println(<span class="hljs-string">&quot;Main thread exiting.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-5-2-yield-方法"><a href="#2-5-2-yield-方法" class="headerlink" title="2.5.2 yield()方法"></a>2.5.2 yield()方法</h4><blockquote><p>Thread类中的一个方法，它的作用是提示线程调度器当前线程愿意放弃当前 CPU 执行权，让其他线程执行。</p></blockquote><ul><li><p><code>yield()</code> 方法暂停当前正在执行的线程对象，并让其他线程有机会继续执行，但是它不会释放锁或资源。</p></li><li><p>调用 <code>yield()</code> 方法后，当前线程会进入就绪状态，然后调度器会从就绪队列中选择一个线程执行。</p></li><li><p>如果没有其他线程处于就绪状态，则当前线程会继续执行。</p></li><li><p>源码解读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 源码在Java中只有一个声明，而其具体实现在JVM中的本地方法库中。</span><br></code></pre></td></tr></table></figure></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 线程yield</span><br><span class="hljs-comment"> * 线程1调用了 yield() 方法，每次执行到该方法时，会暂停当前线程的执行，给其他线程执行的机会。因此，线程1和线程2会交替执行。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">YieldExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 1: &quot;</span> + i);<br>                Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 线程1调用yield()方法</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2: &quot;</span> + i);<br>            &#125;<br>        &#125;);<br><br>        thread1.start(); <span class="hljs-comment">// 启动线程1</span><br>        thread2.start(); <span class="hljs-comment">// 启动线程2</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-volatile"><a href="#3-volatile" class="headerlink" title="3. volatile"></a>3. volatile</h2><blockquote><p><code>volatile</code> 是Java中的关键字，用于修饰变量，其作用是确保多个线程之间对该变量的读取和修改操作都能够保持可见性、有序性和一致性。</p></blockquote><ul><li><p><strong>可见性（Visibility）</strong>：当一个变量被 <code>volatile</code> 修饰时，任何一个线程对该变量的修改都会立即更新到主内存，同时其他线程对该变量的读取操作会从主内存中获取最新的值，而不是从线程的本地缓存中获取。</p></li><li><p><strong>有序性（Ordering）</strong>：<code>volatile</code> 关键字保证了变量的读写操作具有一定的顺序性，即一个线程对 <code>volatile</code> 变量的修改操作发生在其后的读取操作之前。</p></li><li><p><strong>禁止指令重排（Prevent Instruction Reordering）</strong>：<code>volatile</code> 变量的读写操作会禁止指令重排，保证了多线程环境下程序的执行顺序符合程序员的预期。</p></li><li><p><code>volatile</code> 关键字只能保证对单个变量的操作具有原子性，并不能保证复合操作的原子性。如果需要保证复合操作的原子性，可以考虑使用 <code>synchronized</code> 关键字或者 <code>java.util.concurrent.atomic</code> 包中提供的原子类。</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> Volatile 保证变量的可见性</span><br><span class="hljs-comment"> * 一个线程负责写操作，另一个线程负责读操作。</span><br><span class="hljs-comment"> * 通过 volatile 关键字修饰的 flag 变量确保了写操作的可见性和有序性，使得读操作能够及时获取到写操作的结果，从而实现了多线程之间的协同操作。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 声明一个volatile变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 写操作，修改flag的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!flag) &#123;<br>            <span class="hljs-comment">// 读操作，等待flag变为true</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;Flag is true.&quot;</span>); <span class="hljs-comment">// 读取操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VolatileExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileExample</span>();<br><br>        <span class="hljs-comment">// 创建一个线程执行写操作</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">writeThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(example::write);<br><br>        <span class="hljs-comment">// 创建一个线程执行读操作</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">readThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(example::read);<br><br>        <span class="hljs-comment">// 启动线程</span><br>        writeThread.start();<br>        readThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-ThreadGroup"><a href="#4-ThreadGroup" class="headerlink" title="4. ThreadGroup"></a>4. ThreadGroup</h2><blockquote><p>Java 中的一个类，用于对线程进行分组管理。它提供了一种将多个线程组织在一起的方式，使得对线程的管理更加方便。</p></blockquote><ul><li><strong>线程的逻辑分组</strong>：<code>ThreadGroup</code> 允许将多个线程组织成一个逻辑组，便于对这些线程进行统一管理。</li><li><strong>线程的批量操作</strong>：通过 <code>ThreadGroup</code>，可以对组内的所有线程进行批量的控制，比如一次性启动、停止、中断等操作。</li><li><strong>异常处理</strong>：<code>ThreadGroup</code> 可以提供一个统一的异常处理机制，当线程组内的某个线程抛出未捕获的异常时，可以通过设置线程组的异常处理器来处理这些异常。</li><li><strong>线程的垃圾回收</strong>：当 <code>ThreadGroup</code> 中的所有线程都结束运行后，<code>ThreadGroup</code> 会被视为垃圾而被垃圾回收，从而释放资源。</li></ul><p><code>ThreadGroup</code> 类提供了一系列的方法来进行线程管理和操作，包括创建、启动、停止、中断线程等。常用方法：</p><ul><li><code>ThreadGroup(String name)</code>：创建一个指定名称的线程组。</li><li><code>void add(Thread t)</code>：将指定线程添加到线程组中。</li><li><code>void interrupt()</code>：中断线程组中的所有线程。</li><li><code>void list()</code>：打印线程组及其子组中的所有线程信息。</li><li><code>int activeCount()</code>：获取线程组中活动线程的估计数目。</li><li><code>int activeGroupCount()</code>：获取线程组中活动子组的估计数目。</li><li><code>boolean isDaemon()</code>：判断线程组是否为守护线程组。</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 线程组</span><br><span class="hljs-comment"> * 创建一个名为 &quot;MyThreadGroup&quot; 的线程组，并向其中添加了两个线程。然后通过 myGroup.interrupt() 中断了线程组中的所有线程。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroupExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">myGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;MyThreadGroup&quot;</span>);<br><br>        <span class="hljs-comment">// 创建并添加线程到线程组中</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myGroup, () -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 1 is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread 1 interrupted!&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread1.start();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myGroup, () -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread 2 is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread 2 interrupted!&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread2.start();<br><br>        <span class="hljs-comment">// 中断线程组中的所有线程</span><br>        myGroup.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-Daemon"><a href="#5-Daemon" class="headerlink" title="5. Daemon"></a>5. Daemon</h2><blockquote><p>守护线程（Daemon Thread）是一种特殊类型的线程，它的作用是为其他线程提供服务。当所有的非守护线程结束时，守护线程也会随之结束。守护线程通常被用作后台任务的处理和服务提供。</p><p>守护线程与普通线程的区别在于，当Java虚拟机（JVM）中只剩下守护线程时，JVM就会退出。而普通线程则不会影响JVM的退出。</p></blockquote><p>守护线程的特点和使用方法</p><ul><li><strong>创建守护线程</strong>：通过将线程对象的 <code>setDaemon(true)</code> 方法设置为 <code>true</code> 来创建守护线程。必须在启动线程之前调用这个方法，否则会抛出 <code>IllegalThreadStateException</code> 异常。</li><li><strong>守护线程的启动</strong>：守护线程通过 <code>start()</code> 方法启动，与普通线程一样。</li><li><strong>守护线程的生命周期</strong>：守护线程的生命周期取决于是否有其他非守护线程在运行。当所有非守护线程结束时，JVM会自动退出，并且守护线程也会随之结束。</li><li><strong>守护线程的作用</strong>：守护线程通常用于执行后台任务、监控其他线程或资源、定时任务等。</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> 守护线程</span><br><span class="hljs-comment"> * 创建了一个守护线程，它会每秒输出一条信息。主线程休眠5秒后结束，因为此时守护线程是唯一在运行的线程，所以JVM会退出，守护线程也会随之结束。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaemonThreadExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">daemonThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Daemon thread is running...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        daemonThread.setDaemon(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 设置为守护线程</span><br>        daemonThread.start(); <span class="hljs-comment">// 启动守护线程</span><br><br>        <span class="hljs-comment">// 主线程休眠5秒后结束</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Main thread exiting.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-synchronized"><a href="#6-synchronized" class="headerlink" title="6. synchronized"></a>6. synchronized</h2><blockquote><p><code>synchronized</code> 是 Java 中用于实现同步的关键字，它可以用于方法和代码块级别。使用 <code>synchronized</code> 可以保证在多线程环境中对共享资源的安全访问，避免出现竞态条件（Race Condition）和数据不一致等问题。</p></blockquote><h4 id="6-1-synchronized的使用"><a href="#6-1-synchronized的使用" class="headerlink" title="6.1 synchronized的使用"></a>6.1 synchronized的使用</h4><ul><li><p><strong>同步方法（Synchronized Methods）</strong></p><p>使用 <code>synchronized</code> 关键字修饰方法，确保同一时刻只有一个线程能够访问该方法。当一个线程访问了被 <code>synchronized</code> 修饰的方法时，其他线程必须等待该线程执行完毕才能访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>同步代码块（Synchronized Blocks）</strong></p><p>使用 <code>synchronized</code> 关键字修饰代码块，指定锁对象，确保同一时刻只有一个线程能够访问代码块中的内容。其他线程必须等待获取相同锁对象才能执行代码块中的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    <span class="hljs-comment">// 同步代码块</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>静态同步方法（Static Synchronized Methods）</strong></p><p>与普通的同步方法类似，但是作用于静态方法。锁对象是当前类的 <code>Class</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticSynchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 静态同步方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>重入锁（Reentrant Locking）</strong></p><p><code>synchronized</code> 关键字是可重入的，即一个线程可以多次获取同一个锁而不会死锁。如果一个线程已经获得了某个对象的锁，那么它可以继续获得该对象的其他 <code>synchronized</code> 方法或代码块的锁，而无需重新获取锁。</p></li></ul><h4 id="6-2-synchronized的作用"><a href="#6-2-synchronized的作用" class="headerlink" title="6.2 synchronized的作用"></a>6.2 synchronized的作用</h4><p>确保线程之间的互斥访问，避免了多线程环境下可能出现的数据不一致或竞争条件的问题。</p><h4 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> Synchronized示例</span><br><span class="hljs-comment"> * increment() 方法和 performTask() 方法分别展示了同步方法和同步代码块的用法，确保了对共享资源 count 的安全访问。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/12</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 共享资源</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++; <span class="hljs-comment">// 同步方法，确保原子性</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 同步代码块，锁定当前对象</span><br>            count++; <span class="hljs-comment">// 对共享资源的操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 静态同步方法，锁定类的Class对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-锁的优化策略"><a href="#7-锁的优化策略" class="headerlink" title="7. 锁的优化策略"></a>7. 锁的优化策略</h2><ul><li><p><strong>细粒度锁（Fine-Grained Locking）</strong></p><p>将锁粒度细化到最小的范围，以减少锁竞争的可能性。比如，在对共享数据进行操作时，尽量只锁定需要同步的部分，而不是锁定整个对象或方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCount1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>            count1++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCount2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>            count2++;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>count1</code> 和 <code>count2</code> 分别使用了不同的锁 <code>lock1</code> 和 <code>lock2</code>，以减少线程竞争。</p></li><li><p><strong>锁分离（Lock Splitting）</strong></p><p>将一个锁拆分成多个锁，以提高并发性。这样不同的线程可以同时获取不同部分的锁，从而减少竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (readLock) &#123;<br>            <span class="hljs-comment">// 读取共享数据</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (writeLock) &#123;<br>            <span class="hljs-comment">// 写入共享数据</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>读操作和写操作使用了不同的锁，以减少读写操作之间的竞争。</p></li><li><p><strong>读写锁（Read-Write Lock）</strong></p><p>在读多写少的场景下，使用读写锁可以提高并发性能。读写锁允许多个线程同时读取共享数据，但是只允许一个线程写入共享数据，从而避免了读-写冲突。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readData</span><span class="hljs-params">()</span> &#123;<br>        lock.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 读取共享数据</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.readLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeData</span><span class="hljs-params">()</span> &#123;<br>        lock.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 写入共享数据</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.writeLock().unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>readData()</code> 方法使用了读锁，允许多个线程同时读取共享数据，而 <code>writeData()</code> 方法使用了写锁，只允许一个线程写入共享数据。</p></li><li><p><strong>锁消除（Lock Elimination）</strong></p><p>当编译器能够确定某些锁是不可能出现竞争的时候，可以将这些锁消除掉，从而减少锁竞争的影响。</p></li><li><p><strong>锁粗化（Lock Coarsening）</strong></p><p>当连续的加锁和解锁操作在同一个线程内出现时，可以将这些锁合并成一个更大的范围，减少加锁和解锁的次数。</p></li><li><p><strong>自旋锁（Spin Lock）</strong></p><p>在短时间内等待锁的情况下，线程可以采用自旋的方式不断尝试获取锁，而不是进入阻塞状态。这可以减少线程阻塞带来的线程上下文切换开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!lock.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>            <span class="hljs-comment">// 自旋等待</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        lock.set(<span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>lock()</code> 方法会不断自旋直到成功获取锁，而 <code>unlock()</code> 方法则释放锁。</p></li><li><p><strong>适应性自旋（Adaptive Spinning）</strong></p><p>根据锁的竞争情况动态调整自旋等待的时间，避免过长的自旋导致性能损失。</p></li><li><p><strong>锁升级和降级（Lock Promotion and Demotion）</strong></p><p>在复杂的锁机制中，根据需要进行锁的升级和降级，以提高并发性能。</p></li></ul><h2 id="8-无锁"><a href="#8-无锁" class="headerlink" title="8. 无锁"></a>8. 无锁</h2><blockquote><p>“无锁”（Lock-Free）编程是一种多线程编程技术，它旨在实现并发数据结构，而不需要使用显式的锁来进行同步。无锁编程的主要目标是提高并发性能和减少线程之间的竞争，从而提高系统的扩展性和可伸缩性。</p><p>在无锁编程中，通常会使用原子操作和 CAS（Compare and Swap）等机制来实现线程之间的同步和数据的一致性。使用无锁编程技术可以避免锁带来的性能开销和潜在的死锁问题，特别适用于高并发、低延迟的场景。</p></blockquote><h3 id="8-1-CAS"><a href="#8-1-CAS" class="headerlink" title="8.1 CAS"></a>8.1 CAS</h3><blockquote><p>CAS 是一种基于原子操作的技术，通过比较并交换的方式来更新共享变量的值。</p></blockquote><p>Java 的 <code>Unsafe</code> 类提供了 CAS 相关的方法，比如 <code>compareAndSwapInt()</code>、<code>compareAndSwapLong()</code> 等。</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> UnsafeCAS示例 Unsafe</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/16</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CASExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset(CASExample.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> current;<br>        <span class="hljs-keyword">do</span> &#123;<br>            current = unsafe.getIntVolatile(<span class="hljs-built_in">this</span>, valueOffset);<br>        &#125; <span class="hljs-keyword">while</span> (!unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, current, current + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CASExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CASExample</span>();<br><br>        <span class="hljs-comment">// 创建多个线程并发执行增加操作</span><br>        Thread[] threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                    example.increment();<br>                &#125;<br>            &#125;);<br>            threads[i].start();<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程执行完成</span><br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.join();<br>        &#125;<br><br>        <span class="hljs-comment">// 输出最终计数结果</span><br>        System.out.println(<span class="hljs-string">&quot;Final value: &quot;</span> + example.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-Atomic类"><a href="#8-2-Atomic类" class="headerlink" title="8.2 Atomic类"></a>8.2 <strong>Atomic</strong>类</h3><blockquote><p>Java.util.concurrent.atomic 包提供了一系列原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等。这些类使用了底层的硬件级别的原子操作来保证线程安全，常用方法包括 <code>get()</code>、<code>set()</code>、<code>getAndIncrement()</code>、<code>compareAndSet()</code> 等。</p></blockquote><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> AtomicInteger示例</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/15</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicIntegerExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count.incrementAndGet(); <span class="hljs-comment">// 原子增加操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count.get(); <span class="hljs-comment">// 原子获取操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AtomicIntegerExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerExample</span>();<br><br>        <span class="hljs-comment">// 创建多个线程并发执行增加操作</span><br>        Thread[] threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;<br>            threads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                    example.increment();<br>                &#125;<br>            &#125;);<br>            threads[i].start();<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程执行完成</span><br>        <span class="hljs-keyword">for</span> (Thread thread : threads) &#123;<br>            thread.join();<br>        &#125;<br><br>        <span class="hljs-comment">// 输出最终计数结果</span><br>        System.out.println(<span class="hljs-string">&quot;Final count: &quot;</span> + example.getCount());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9. ThreadLocal"></a>9. ThreadLocal</h2><blockquote><p>线程本地变量工具类，它允许我们创建线程局部变量，使得每个线程都有自己独立的变量副本，互不干扰。<code>ThreadLocal</code> 主要用于解决多线程环境下的线程安全问题，以及避免使用全局变量造成的共享资源竞争。</p></blockquote><ul><li><p><strong>线程局部变量</strong>：<code>ThreadLocal</code> 提供了一种线程局部变量的机制，每个线程都可以访问自己的局部变量，而不会影响其他线程的变量值。</p></li><li><p><strong>线程安全</strong>：由于每个线程都有自己的变量副本，因此不同线程之间的变量操作是相互独立的，不会发生线程安全问题。</p></li><li><p><strong>隔离性</strong>：<code>ThreadLocal</code> 可以为每个线程提供独立的变量副本，从而实现了线程之间的数据隔离。</p></li><li><p><strong>减少锁竞争</strong>：通过 <code>ThreadLocal</code> 将共享变量转换为线程局部变量，可以减少锁竞争，提高程序的并发性能。</p></li><li><p><strong>源码解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 使用ThreadLocal.ThreadLocalMap存储线程本地变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalMap</span> &#123;<br>        <span class="hljs-comment">// Entry是ThreadLocalMap的内部类，用于存储键值对</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>            Object value; <span class="hljs-comment">// 值</span><br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-built_in">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 数组大小为2的幂次方</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><br>        <span class="hljs-comment">// 阈值，超过该值会进行扩容</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> threshold;<br><br>        <span class="hljs-comment">// 数组大小</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>        <span class="hljs-comment">// 存放Entry的数组</span><br>        <span class="hljs-keyword">private</span> Entry[] table;<br><br>        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;<br>            <span class="hljs-comment">// 初始化数组大小为16</span><br>            table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[INITIAL_CAPACITY];<br>            <span class="hljs-comment">// 计算hash值，并找到对应的索引位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 创建Entry对象，并放入数组对应位置</span><br>            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(firstKey, firstValue);<br>            size = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 设置阈值为数组大小的2/3</span><br>            threshold = INITIAL_CAPACITY * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取Entry对象</span><br>        <span class="hljs-keyword">private</span> Entry <span class="hljs-title function_">getEntry</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key)</span> &#123;<br>            <span class="hljs-comment">// 计算hash值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 获取数组对应位置的Entry对象</span><br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i];<br>            <span class="hljs-comment">// 判断Entry是否为null，并且判断Entry的key是否和参数key相等</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == key) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加Entry对象</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;<br>            <span class="hljs-comment">// 计算hash值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 遍历数组，寻找第一个为null的位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> table[i]; e != <span class="hljs-literal">null</span>; e = table[i = nextIndex(i, table.length)]) &#123;<br>                ThreadLocal&lt;?&gt; k = e.get();<br>                <span class="hljs-comment">// 如果找到相同的key，则更新值，并返回</span><br>                <span class="hljs-keyword">if</span> (k == key) &#123;<br>                    e.value = value;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-comment">// 如果找到key为null的Entry，则将当前Entry存入该位置</span><br>                <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                    replaceStaleEntry(key, value, i);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 创建新的Entry，并存入数组对应位置</span><br>            table[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>            <span class="hljs-comment">// 判断是否需要进行扩容</span><br>            <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) &#123;<br>                rehash();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 用于生成唯一的哈希码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextHashCode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-comment">// 每个ThreadLocal对象都有自己独立的哈希码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">threadLocalHashCode</span> <span class="hljs-operator">=</span> nextHashCode.getAndAdd(<span class="hljs-number">0x61c88647</span>);<br>    <span class="hljs-comment">// 初始化哈希码的种子</span><br><br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前线程的ThreadLocalMap</span><br>    ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>        <span class="hljs-keyword">return</span> t.threadLocals;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置当前线程的ThreadLocalMap</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>        t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T) e.value;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> setInitialValue();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            createMap(t, value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            map.set(<span class="hljs-built_in">this</span>, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            createMap(t, value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.keer.server.concurrent.basic;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Desc</span> ThreadLocal示例</span><br><span class="hljs-comment"> * 创建了一个初始值为0的 ThreadLocal 变量 threadLocalValue。</span><br><span class="hljs-comment"> * 然后创建了5个线程，并在每个线程中递增 threadLocalValue 的值，并输出当前线程的变量值。</span><br><span class="hljs-comment"> * 由于每个线程都有自己独立的变量副本，因此输出结果会显示每个线程的变量值相互独立，互不影响。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> wangtianlong</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/1/18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocalValue = ThreadLocal.withInitial(() -&gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建并启动多个线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">// 获取当前线程的局部变量值，并递增</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocalValue.get();<br>                value++;<br>                threadLocalValue.set(value);<br><br>                <span class="hljs-comment">// 输出当前线程的局部变量值</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + threadLocalValue.get());<br>            &#125;);<br>            thread.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>&lt;并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁 线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile指令详解</title>
    <link href="/2023/12/28/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/12/28/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h1><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM**"></a>FROM**</h3><ul><li>说明：指定该镜像的基础镜像</li><li>格式如：<code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code></li><li>示例：<code>FROM centos:7</code></li><li>注意：<code>FROM</code>一般出现在文件头，且每个镜像都需要有一个<code>FROM</code>来指定基础镜像。</li></ul><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a><strong>MAINTAINER</strong></h3><ul><li>说明：指定作者信息</li><li>格式如：<code>MAINTAINER &lt;name&gt;</code></li><li>示例：<code>MAINTAINER along</code></li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a><strong>RUN</strong></h3><ul><li>说明：在构建镜像时执行脚本</li><li>格式如：<code>RUN &lt;command&gt;</code>、<code>RUN [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>RUN ls -l</code>（以详细信息方式列表当前目录下的文件，跟在shell终端运行一样）</li></ul><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><strong>CMD</strong></h3><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>CMD &lt;command&gt; &lt;par1&gt; &lt;par2&gt; ...</code>、<code>CMD [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code></li><li>示例：<code>CMD [&quot;ls&quot;, &quot;-l&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>CMD</code>，如果有多条只执行最后一条；在运行容器时如果用户指定了运行命令则Dockerfile中的CMD将被覆盖。</li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a><strong>ENTRYPOINT</strong></h3><ul><li>说明：在运行容器时执行脚本</li><li>格式如：<code>ENTRYPOINT [&quot;exec&quot;, &quot;par1&quot;, &quot;par2&quot;]</code>、<code>ENTRYPOINT command par1 par2</code></li><li>示例：<code>ENTRYPOINT [&quot;catalina.sh&quot;, &quot;run&quot;]</code></li><li>注意：一个Dockerfile中只有一条<code>ENTRYPOINT</code>，如果有多条只执行最后一条；不可以被容器运行时的命令所覆盖。</li></ul><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a><strong>EXPOSE</strong></h3><ul><li>说明：让Docker暴露容器的端口号，供其他容器使用，在宿主机以外的网络中是无法使用的</li><li>格式如：<code>EXPOSE &lt;port&gt; ...</code></li><li>示例：<code>EXPOSE 8080</code></li><li>注意： <ul><li>在Docker中有两种暴露端口的概念，一种叫<code>EXPOSE</code>隐式暴露，只供Docker服务内部使用；另一种叫<code>PUBLISH</code>显式暴露，供外部网络使用，<code>PUBLISH</code>只是一个概念在Dockerfile中没有这个指令。</li><li><code>EXPOSE</code> 只在Dockerfile中出现，所暴露的端口只是被其他容器使用</li><li><code>PUBLISH</code> 没有该指令而是通过<code>docker run</code>命令的参数<code>p</code>、<code>P</code>或在<code>docker-compose</code>中的<code>ports</code>来体现</li><li><code>P</code>：大写是属于自动映射，将Dockerfile中<code>EXPOSE</code>所暴露的所有端口分别映射到宿主机的随机端口，每次启动或重启容器时端口都可能有所不同</li><li><code>p</code>：小写是属于固定映射，格式如：<code>p 宿主端口:容器端口</code>，宿主端口和容器端口可以是纯数字也可以是一个范围，如：<code>p 8060-8080:8060-8080</code>，意为将宿主机的<code>8060</code>（含）到<code>8080</code>（含）的端口映射到容器的<code>8060</code>（含）到<code>8080</code>（含）端口，需要注意的是在使用范围时，宿主端口个数应该与容器端口个数匹配；但上面这个例子可以写成：<code>p 7060-7080:8060-8080</code>，这样宿主的端口就在<code>7060-7080</code>范围内</li></ul></li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a><strong>ENV</strong></h3><ul><li>说明：指定环境变量，在Dockerfile文件中的后续代码中使用，在容器运行时也可以使用</li><li>格式如：<code>ENV &lt;key&gt; &lt;value&gt;</code></li><li>示例：<code>ENV tomcat_home /web/tomcat/</code></li></ul><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a><strong>ADD</strong></h3><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>ADD &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>ADD web.jar /web.jar</code></li><li>注意：复制指定的<code>&lt;src&gt;</code>到容器中的<code>&lt;dest&gt;</code>，<code>&lt;src&gt;</code>可以是Dockerfile所在目录的一个相对路径，也可以是一个URL，也可以是一个<code>tar</code>文件（<code>tar</code>文件将自动解压成文件目录）</li></ul><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a><strong>COPY</strong></h3><ul><li>说明：添加文件（夹）到容器</li><li>格式如：<code>COPY &lt;src&gt; &lt;dest&gt;</code></li><li>示例：<code>COPY web.jar /web.jar</code></li><li>注意：与<code>ADD</code>功能相似，只是不能指定URL，使用本地文件（夹）为源文件时，推荐使用<code>COPY</code></li></ul><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a><strong>VOLUME</strong></h3><ul><li><p>说明：创建挂载点</p></li><li><p>格式如：<code>VOLUME [path]</code></p></li><li><p>示例：<code>VOLUME [&quot;/datas&quot;]</code></p></li><li><p>注意： </p><ul><li><p><code>VOLUME</code>在原理和概念上与<code>EXPOSE</code>差不多，都是属于供容器与容器间使用</p></li><li><p>通过<code>VOLUME</code>挂载的卷可以供其他容器使用</p></li><li><p>举例说明： </p><ul><li><p>创建一个Dockerfile来构建一个镜像，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM centos  VOLUME [<span class="hljs-string">&quot;/web/images&quot;</span>, <span class="hljs-string">&quot;/web/files&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t <span class="hljs-string">&quot;zsl131/test01&quot;</span> .<br></code></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name test-root<br></code></pre></td></tr></table></figure></li><li><p>可以使用命令：<code>docker inspect test-root</code>来查看容器详细信息，在<code>Mounts</code>部份可以看到两个挂载点：<code>/web/images</code>和<code>/web/files</code></p></li><li><p>启动另一个容器来共用这两个挂载卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --name test-1 --volumes-from test-root centos<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>使用<code>--volumes-from</code>来指定挂载点，这时容器<code>test-root</code>和<code>test-1</code>里面都分别有挂载卷<code>/web/images</code>和<code>/web/files</code>，可以启动任意多个容器使用<code>--volumes-from</code>来共用这些挂载卷，这些容器可以来自不同的镜像。当任何一个容器中的挂载卷中的文件发生变化时其他容器挂载卷中的内容也随之改变。</p><p>容器<code>test-root</code>即使已经停止也可以在启动其他容器时使用<code>--volumes-from test-root</code>来挂载这些卷，只要<code>test-root</code>不被删除，不过如果<code>test-root</code>真被删除还可以使用<code>--volumes-from test-1</code>，因为容器<code>test-1</code>中还存在我们所需要的挂载卷，换句话说这些挂载卷永远存在直到所有使用这些挂载卷的容器都被删除。</p></li><li><p><code>VOLUME</code>与<code>docker run</code>参数<code>v</code>是有区别的。<code>docker run -v /host/web/images:/web/images -v /host/web/files:/web/files:rw</code>是将容器内的<code>/web/images</code>挂载到宿主机的<code>/host/web/images</code>目录上；将容器内的<code>/web/files</code>挂载到宿主机的<code>/host/web/files</code>目录上，<code>rw</code>表示可读写。</p></li></ul></li></ul></li></ul><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a><strong>WORKDIR</strong></h3><ul><li>说明：设置工作目录</li><li>格式如：<code>WORKDIR /path</code></li><li>示例：<code>WORKDIR /web</code></li><li>注意：可以使用绝对路径，也可以使用相对路径，设置之后的所有操作都将在这个目录下完成</li></ul><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><p>在上面的描述中可以看到有两组指令在功能上都差不多，但也是有区别的：</p><ul><li>RUN/CMD/ENTRYPOINT 执行脚本的指令 <ul><li>三个指令都是执行脚本</li><li><code>RUN</code>是在创建镜像是执行，即使用<code>docker build</code>命令时执行，在一个Dockerfile里面可以有多个<code>RUN</code></li><li><code>CMD</code>和<code>ENTRYPOINT</code>是在运行容器时执行，即使用<code>docker run</code>命令时执行，这两个指令在Dockerfile中都只有最行一条被执行</li><li><code>CMD</code>在使用<code>docker run</code>时可以加参数将Dockerfile中的<code>CMD</code>覆盖</li><li><code>ENTRYPOINT</code>在Dockerfile中出现后就一定会在<code>docker run</code>时被执行，不必担心会被其他参数所覆盖。</li></ul></li><li>ADD/COPY 拷贝文件（夹）到容器 <ul><li><code>ADD</code>拷贝文件（夹）时可以指定本地文件、远程URL地址，如果拷贝的是<code>tar</code>文件时将会被自动解压成文件夹</li><li><code>COPY</code>拷贝文件（夹）时不可以指定远程URL地址，拷贝<code>tar</code>文件也不会被自动解压成文件夹，在拷贝本地文件时建议使用<code>COPY</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>&lt;Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker 服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8s &amp; Docker</title>
    <link href="/2023/12/25/K8s%20&amp;%20Docker/"/>
    <url>/2023/12/25/K8s%20&amp;%20Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="K8s-amp-Docker"><a href="#K8s-amp-Docker" class="headerlink" title="K8s &amp; Docker"></a>K8s &amp; Docker</h1><h2 id="kubectl-概述"><a href="#kubectl-概述" class="headerlink" title="kubectl 概述"></a><strong>kubectl 概述</strong></h2><blockquote><p>kubectl 是用于运行 Kubernetes 集群命令的管理工具</p></blockquote><h2 id="kubectl-与-Docker-命令关系"><a href="#kubectl-与-Docker-命令关系" class="headerlink" title="kubectl 与 Docker 命令关系"></a><strong>kubectl 与 Docker 命令关系</strong></h2><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a><strong>docker run</strong></h3><blockquote><p>运行nginx</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d --restart=always -e DOMAIN=cluster --name nginx-app -p 80:80 nginx<br>a9e<br></code></pre></td></tr></table></figure><blockquote><p><strong>docker ps</strong></p></blockquote><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>STATUS</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>a9ec34d98787</td><td>nginx</td><td>“nginx -g ‘daemon of</td><td>2 seconds ago</td><td>Up 2 seconds</td><td>0.0.0.0:80-&gt;80/tcp,443/tcp</td><td>nginx-app</td></tr></tbody></table><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># start the pod running nginx</span><br>$ kubectl run --image=nginx nginx-app --port=80 --<span class="hljs-built_in">env</span>=<span class="hljs-string">&quot;DOMAIN=cluster&quot;</span> deployment <span class="hljs-string">&quot;nginx-app&quot;</span> created<br></code></pre></td></tr></table></figure><p>kubectl run 在 Kubernetes 集群&gt; = v1.2 上将创建名是 “nginx-app”的 Deployment。如果 运行的是低的版本，则会创建一个 replication controllers，如果要了解低版本方式，请使 用–generator=run/v1，将会创建 replication controllers。查看 kubectl run 更多详情。现 在，我们可以使用上面创建的 Deployment 来暴露一个新的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#expose a port through with a service</span><br>$ kubectl expose deployment nginx-app --port=80 --name=nginx-http service <span class="hljs-string">&quot;nginx-http&quot;</span> exposed<br></code></pre></td></tr></table></figure><p>使用 kubectl 创建一个 Deployment，他能保证任何情况下有 N 个运行 nginx 的 pods（其 中 N 是默认定义声明的副本数，默认为 1 个）。它同时会创建一个 Services，使用选择器 匹配 Deployment’s selector。</p><p>默认情况下镜像在后台运行，类似于 docker run -d …在前台运行，使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl run [-i] [--<span class="hljs-built_in">tty</span>] --attach &lt;name&gt; --image=&lt;image&gt;<br>要删除 Deployment （及其 pod）<br>kubectl delete deployment &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a><strong>docker ps</strong></h3><blockquote><p>列出当前运行的内容</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker ps<br></code></pre></td></tr></table></figure><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>STATUS</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>a9ec34d98787</td><td>nginx</td><td>“nginx -g ‘daemon of</td><td>About an hour ago</td><td>Up About an hour</td><td>0.0.0.0:80-&gt;80/tcp,443/tcp</td><td>nginx-app</td></tr></tbody></table><ul><li><strong>使用kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get po<br></code></pre></td></tr></table></figure><table><thead><tr><th>NAME</th><th>READY</th><th>STATUS</th><th>RESTARTS</th><th>AGE</th></tr></thead><tbody><tr><td>nginx-app</td><td>1/1</td><td>Running</td><td>0</td><td>1h</td></tr></tbody></table><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><blockquote><p>连接已经运行在容器中的进程</p></blockquote><ul><li><strong>使用docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker attach CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl attach -it NAME<br></code></pre></td></tr></table></figure><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a><strong>docker exec</strong></h3><blockquote><p>何在容器中执行命令</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> CONTAINER ID <span class="hljs-built_in">cat</span> /etc/hostname CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl <span class="hljs-built_in">exec</span> NAME -- <span class="hljs-built_in">cat</span> /etc/hostname NAME<br></code></pre></td></tr></table></figure><blockquote><p>交互式命令</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -ti CONTAINER ID /bin/sh<br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl <span class="hljs-built_in">exec</span> -ti NAME -- /bin/sh<br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><h3 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a><strong>docker logs</strong></h3><blockquote><p>查看进程打印 stdout / stderr</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -f CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl logs -f NAME<br></code></pre></td></tr></table></figure><blockquote><p>pods和containers之间的微小差异</p></blockquote><p>默认情况下，如果进程退出，pods是不会终止，相反，它会重新启动该进程。这与 docker run 配置–restart=always 选项有一个主要区别。要查看以前在 Kubernetes 中运行的输出，请运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl logs --previous NAME<br></code></pre></td></tr></table></figure><h3 id="docker-stop-和-docker-rm"><a href="#docker-stop-和-docker-rm" class="headerlink" title="docker stop 和 docker rm"></a><strong>docker stop 和 docker rm</strong></h3><blockquote><p>停止和删除正在运行的进程</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker stop CONTAINER ID<br>$ docker <span class="hljs-built_in">rm</span> CONTAINER ID<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get deployment NAME<br>$ kubectl get po -l run=NAME<br>$ kubectl delete deployment NAME<br>$ kubectl get po -l run=NAME<br></code></pre></td></tr></table></figure><p>注意，不要直接删除 pod，使用 kubectl 请删除拥有该 pod 的 Deployment。如果直接删除 pod，则 Deployment将会重新创建该pod。</p><h3 id="docker-version"><a href="#docker-version" class="headerlink" title="docker version"></a><strong>docker version</strong></h3><blockquote><p>获取客户端和服务器的版本号</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker version<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl version<br></code></pre></td></tr></table></figure><h3 id="docker-info"><a href="#docker-info" class="headerlink" title="docker info"></a><strong>docker info</strong></h3><blockquote><p>获取有关配置和环境信息</p></blockquote><ul><li><strong>使用 docker</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker info<br></code></pre></td></tr></table></figure><ul><li><strong>使用 kubectl</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl cluster-info<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h2><h3 id="1、查看集群状态"><a href="#1、查看集群状态" class="headerlink" title="1、查看集群状态"></a><strong>1、查看集群状态</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看客户端及服务端程序版本信息<br>kubectl version --short=<span class="hljs-literal">true</span><br>查看集群信息<br>kubectl cluster-info<br></code></pre></td></tr></table></figure><h3 id="2、创建资源对象"><a href="#2、创建资源对象" class="headerlink" title="2、创建资源对象"></a><strong>2、创建资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl run name --image=(镜像名) --replicas=(备份数) --port=(容器要暴露的端口) -labels=(设定自定义标签)<br>陈述式对象配置管理方式<br>kubectl create -f **.yaml<br>声明式对象配置管理方式（也适用于更新等）<br>kubectl apply -f **.yaml<br></code></pre></td></tr></table></figure><h3 id="3、查看资源对象"><a href="#3、查看资源对象" class="headerlink" title="3、查看资源对象"></a><strong>3、查看资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get namespace 查看命名空间<br>kubectl get pods,services -o wide (-o 输出格式 wide 表示 plain-text)<br>kubectl get pod -l <span class="hljs-string">&quot;key=value,key=value&quot;</span> -n kube-system (-l 标签选择器(多个的话是与逻辑)，-n 指定命名空间，不指定默认 default)<br>kubectl get pod -l <span class="hljs-string">&quot;key1 in (val1,val2),!key2&quot;</span> -L key (-l 基于集合的标签选择器, -L 查询结果显示标签) 注意：为了避免和 shell 解释器解析!,必须要为此类表达式使用单引号<br>kubectl get pod -w(-w 监视资源变动信息)<br></code></pre></td></tr></table></figure><h3 id="4、打印容器中日志信息"><a href="#4、打印容器中日志信息" class="headerlink" title="4、打印容器中日志信息"></a><strong>4、打印容器中日志信息</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs name -f -c container_name -n kube-system (-f 持续监控，-c 如果 pod 中只有一个容器不用加)<br></code></pre></td></tr></table></figure><h3 id="5、在容器中执行命令"><a href="#5、在容器中执行命令" class="headerlink" title="5、在容器中执行命令"></a>5、在容器中执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> name -c container_name -n kube-system -- 具体命令<br>进入容器的交互式 shell<br>kubectl <span class="hljs-built_in">exec</span> -it pod_name /bin/sh<br></code></pre></td></tr></table></figure><h3 id="6、删除资源对象"><a href="#6、删除资源对象" class="headerlink" title="6、删除资源对象"></a><strong>6、删除资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">删除指定资源对象<br>kubectl delete [pods/services/deployments/...] name<br>删 除kube-system 下指定标签的资源对象<br>kubectl delete [pods/services/deployments/...] -l key=value -n kube-system<br>删除 kube-system 下所有资源对象<br>kubectl delete [pods/services/deployments/...] --all -n kube-system<br>强制删除 Terminating 的资源对象<br>kubectl delete [pods/services/deployments/...] source_name --force --grace-period=0 -n kube-system<br>kubectl delete -f xx.yaml<br>kubectl apply -f xx.yaml --prune -l &lt;labels&gt;(一般不用这种方式删除)<br>kubectl delete rs rs_name --cascade=fale(默认删除控制器会同时删除其管控的所有 Pod对象，加上 cascade=<span class="hljs-literal">false</span> 就只删除 rs)<br></code></pre></td></tr></table></figure><h3 id="7、更新资源对象"><a href="#7、更新资源对象" class="headerlink" title="7、更新资源对象"></a><strong>7、更新资源对象</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl replace -f xx.yaml --force(--force 如果需要基于此前的配置文件进行替换，需要加上 force)<br></code></pre></td></tr></table></figure><h3 id="8、将服务暴露出去-创建-Service"><a href="#8、将服务暴露出去-创建-Service" class="headerlink" title="8、将服务暴露出去(创建 Service)"></a><strong>8、将服务暴露出去(创建 Service)</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl expose deployments/deployment_name --<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;NodePort&quot;</span> --port=(要暴露的容器端口) --name=(Service 对象名字)<br></code></pre></td></tr></table></figure><h3 id="9、扩容和缩容"><a href="#9、扩容和缩容" class="headerlink" title="9、扩容和缩容"></a><strong>9、扩容和缩容</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl scale deployment/deployment_name --replicas=N<br>kubectl scale deployment/deployment_name --replicas=N --current-replicas=M <br>只有当前副本数等于 M 时才会执行扩容或者缩容<br></code></pre></td></tr></table></figure><h3 id="10、查看-API-版本"><a href="#10、查看-API-版本" class="headerlink" title="10、查看 API 版本"></a><strong>10、查看 API 版本</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl api-versions<br></code></pre></td></tr></table></figure><h3 id="11、在本地主机上为-API-Server-启动一个代理网关"><a href="#11、在本地主机上为-API-Server-启动一个代理网关" class="headerlink" title="11、在本地主机上为 API Server 启动一个代理网关"></a><strong>11、在本地主机上为 API Server 启动一个代理网关</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl proxy --port=8080<br>之后就可以通过 curl 来对此套字节发起访问请求<br>curl localhost:8080/api/v1/namespaces/ | jq .items[].metadata.name<br>(jq 可以对 json 进行过滤)<br></code></pre></td></tr></table></figure><h3 id="12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释"><a href="#12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释" class="headerlink" title="12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释"></a><strong>12、当定义资源配置文件时，不知道怎么定义的时候，可以查看某类型资源的配置字段解释</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(二级对象可用类似于 pods.spec 这种方式查看)<br>kubectl explain pods/deployments/...<br></code></pre></td></tr></table></figure><h3 id="13、查看某资源对象的配置文件"><a href="#13、查看某资源对象的配置文件" class="headerlink" title="13、查看某资源对象的配置文件"></a><strong>13、查看某资源对象的配置文件</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(--<span class="hljs-built_in">export</span> 表示省略由系统生成的信息) 后面加 &gt; file.yaml 就可以快速生成一个配置文件了<br>kubectl get source_type source_name -o yaml --<span class="hljs-built_in">export</span><br></code></pre></td></tr></table></figure><h3 id="14、标签管理相关命令"><a href="#14、标签管理相关命令" class="headerlink" title="14、标签管理相关命令"></a><strong>14、标签管理相关命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">添 加 标 签 , 如 果 是 修 改 的 话 需 要 后 面 添 加 -overwrite<br>kubectl label pods/pod_name key=value<br>给 工 作 节 点 添 加 标 签 ， 后 续 可 以 使 用<br>kubectl label nodes node_name key=value<br>来指定 pod 被调度到指定的工作节点上运行<br>nodeSelector<br></code></pre></td></tr></table></figure><h3 id="15、注解管理相关命令"><a href="#15、注解管理相关命令" class="headerlink" title="15、注解管理相关命令"></a><strong>15、注解管理相关命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl annotate pods pod_name key=value<br></code></pre></td></tr></table></figure><h3 id="16、patch-修改-Deployment-控制器进行控制器升级"><a href="#16、patch-修改-Deployment-控制器进行控制器升级" class="headerlink" title="16、patch 修改 Deployment 控制器进行控制器升级"></a><strong>16、patch 修改 Deployment 控制器进行控制器升级</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">(-p以补丁形式更新补丁形式默认是 json)<br>kubectl patch deployment deployment-demo -p <span class="hljs-string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;minReadySeconds&quot;: 5&#125;&#125;&#x27;</span><br>修改depolyment 中的镜像文件<br>kubectl <span class="hljs-built_in">set</span> image deployments deployment-demo myapp=ikubernetes/myapp:v2 <br>打印滚动更新过程中的状态信息<br>kubectl rollout status deployment deployment-demo<br>监控 deployment 的更新过程<br>kubectl get deployments deployment-demo --watch<br>暂停更新<br>kubectl kubectl rollout pause deployments deployment-demo<br>继续更新<br>kubectl rollout resume deployments deployment-demo<br>查看历史版本(能查到具体的历史需要在 apply 的时候加上--record 参数)<br>kubectl rollout <span class="hljs-built_in">history</span> deployments deployment-demo<br>回滚到指定版本，不加--to-version 则回滚到上一个版本<br>kubectl rollout undo deployments deployment-demo --to-revision=2 <br></code></pre></td></tr></table></figure><h3 id="17、查看所有-pod-列表-n-后跟-namespace-查看指定的命名空间"><a href="#17、查看所有-pod-列表-n-后跟-namespace-查看指定的命名空间" class="headerlink" title="17、查看所有 pod 列表, -n 后跟 namespace, 查看指定的命名空间"></a><strong>17、查看所有 pod 列表, -n 后跟 namespace, 查看指定的命名空间</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pod<br>kubectl get pod -n kubekubectl get pod -o wide<br></code></pre></td></tr></table></figure><h3 id="18、查看-RC-和-service-列表，-o-wide-查看详细信息"><a href="#18、查看-RC-和-service-列表，-o-wide-查看详细信息" class="headerlink" title="18、查看 RC 和 service 列表， -o wide 查看详细信息"></a><strong>18、查看 RC 和 service 列表， -o wide 查看详细信息</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get rc,svc<br>kubectl get pod,svc -o wide<br>kubectl get pod &lt;pod-name&gt; -o yaml<br></code></pre></td></tr></table></figure><h3 id="19、显示-Node-的详细信息"><a href="#19、显示-Node-的详细信息" class="headerlink" title="19、显示 Node 的详细信息"></a><strong>19、显示 Node 的详细信息</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe node 192.168.0.212<br></code></pre></td></tr></table></figure><h3 id="20、显示-Pod-的详细信息-特别是查看-pod-无法创建的时候的日志"><a href="#20、显示-Pod-的详细信息-特别是查看-pod-无法创建的时候的日志" class="headerlink" title="20、显示 Pod 的详细信息, 特别是查看 pod 无法创建的时候的日志"></a><strong>20、显示 Pod 的详细信息, 特别是查看 pod 无法创建的时候的日志</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe pod &lt;pod-name&gt;<br>eg: kubectl describe pod redis-master-tqds9<br></code></pre></td></tr></table></figure><h3 id="21、根据-yaml-创建资源-apply-可以重复执行，create不行"><a href="#21、根据-yaml-创建资源-apply-可以重复执行，create不行" class="headerlink" title="21、根据 yaml 创建资源, apply 可以重复执行，create不行"></a><strong>21、根据 yaml 创建资源, apply 可以重复执行，create不行</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create -f pod.yaml<br>kubectl apply -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="22、基于-pod-yaml-定义的名称删除-pod"><a href="#22、基于-pod-yaml-定义的名称删除-pod" class="headerlink" title="22、基于 pod.yaml 定义的名称删除 pod"></a><strong>22、基于 pod.yaml 定义的名称删除 pod</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete -f pod.yaml<br></code></pre></td></tr></table></figure><h3 id="23、删除所有包含某个-label-的-pod-和-service"><a href="#23、删除所有包含某个-label-的-pod-和-service" class="headerlink" title="23、删除所有包含某个 label 的 pod 和 service"></a><strong>23、删除所有包含某个 label 的 pod 和 service</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete pod,svc -l name=&lt;label-name&gt;<br></code></pre></td></tr></table></figure><h3 id="24、删除所有-Pod"><a href="#24、删除所有-Pod" class="headerlink" title="24、删除所有 Pod"></a><strong>24、删除所有 Pod</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete pod --all<br></code></pre></td></tr></table></figure><h3 id="25、查看-endpoint-列表"><a href="#25、查看-endpoint-列表" class="headerlink" title="25、查看 endpoint 列表"></a><strong>25、查看 endpoint 列表</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get endpoints<br></code></pre></td></tr></table></figure><h3 id="26、执行-pod-的-date-命令"><a href="#26、执行-pod-的-date-命令" class="headerlink" title="26、执行 pod 的 date 命令"></a><strong>26、执行 pod 的 date 命令</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -- <span class="hljs-built_in">date</span><br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -- bash<br>kubectl <span class="hljs-built_in">exec</span> &lt;pod-name&gt; -- ping 10.24.51.9<br></code></pre></td></tr></table></figure><h3 id="27、通过-bash-获得-pod-中某个容器的-TTY，相当于登录容器"><a href="#27、通过-bash-获得-pod-中某个容器的-TTY，相当于登录容器" class="headerlink" title="27、通过 bash 获得 pod 中某个容器的 TTY，相当于登录容器"></a><strong>27、通过 bash 获得 pod 中某个容器的 TTY，相当于登录容器</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -it &lt;pod-name&gt; -c &lt;container-name&gt; -- bash<br>eg: kubectl <span class="hljs-built_in">exec</span> -it redis-master-cln81 -- bash<br></code></pre></td></tr></table></figure><h3 id="28、查看容器的日志"><a href="#28、查看容器的日志" class="headerlink" title="28、查看容器的日志"></a><strong>28、查看容器的日志</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs &lt;pod-name&gt;<br>kubectl logs -f &lt;pod-name&gt; <span class="hljs-comment"># 实时查看日志</span><br>kubectl <span class="hljs-built_in">log</span> &lt;pod-name&gt; -c &lt;container_name&gt; <span class="hljs-comment"># 若 pod 只有一个容器，可以不加 -c</span><br></code></pre></td></tr></table></figure><h3 id="29、查看注释"><a href="#29、查看注释" class="headerlink" title="29、查看注释"></a><strong>29、查看注释</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl explain pod<br>kubectl explain pod.apiVersion<br></code></pre></td></tr></table></figure><h3 id="30、查看节点-labels"><a href="#30、查看节点-labels" class="headerlink" title="30、查看节点 labels"></a><strong>30、查看节点 labels</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get node --show-labels<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器日志</title>
    <link href="/2023/12/18/Docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/"/>
    <url>/2023/12/18/Docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="docker容器日志"><a href="#docker容器日志" class="headerlink" title="docker容器日志"></a>docker容器日志</h1><h1 id="docker-logs－查看docker容器日志"><a href="#docker-logs－查看docker容器日志" class="headerlink" title="docker logs－查看docker容器日志"></a>docker logs－查看docker容器日志</h1><p>通过docker logs命令可以查看容器的日志。</p><p><strong>命令格式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs [OPTIONS] CONTAINER<br>  Options:<br>        --details        显示更多的信息<br>    -f, --follow         跟踪实时日志<br>        --since string   显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）<br>        --<span class="hljs-built_in">tail</span> string    从日志末尾显示多少行日志， 默认是all<br>    -t, --timestamps     显示时间戳<br>        --<span class="hljs-keyword">until</span> string   显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）<br></code></pre></td></tr></table></figure><p><strong>例子：</strong></p><p>查看指定时间后的日志，只显示最后100行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -f -t --since=<span class="hljs-string">&quot;2023-10-08&quot;</span> --<span class="hljs-built_in">tail</span>=100 CONTAINER_ID<br></code></pre></td></tr></table></figure><p>查看最近30分钟的日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs --since 30m CONTAINER_ID<br></code></pre></td></tr></table></figure><p>查看某时间之后的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -t --since=<span class="hljs-string">&quot;2023-10-08T13:23:37&quot;</span> CONTAINER_ID<br></code></pre></td></tr></table></figure><p>查看某时间段日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker logs -t --since=<span class="hljs-string">&quot;2023-10-08T13:23:37&quot;</span> --<span class="hljs-keyword">until</span> <span class="hljs-string">&quot;2023-10-09T12:23:37&quot;</span> CONTAINER_ID<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker 服务器日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令总结</title>
    <link href="/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令总结"><a href="#Linux命令总结" class="headerlink" title="Linux命令总结"></a>Linux命令总结</h1><p>[TOC]</p><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><blockquote><ul><li>uname -m <ul><li>显示机器的处理器架构</li></ul></li><li>uname -r<ul><li> 显示正在使用的内核版本</li></ul></li><li>dmidecode -q<ul><li> 显示硬件系统部件</li></ul></li><li>(SMBIOS / DMI) hdparm -i /dev/hda<ul><li> 罗列一个磁盘的架构特性</li></ul></li><li>hdparm -tT /dev/sda<ul><li> 在磁盘上执行测试性读取操作系统信息</li></ul></li><li>arch<ul><li> 显示机器的处理器架构</li></ul></li><li>uname -m<ul><li> 显示机器的处理器架构</li></ul></li><li>uname -r<ul><li> 显示正在使用的内核版本</li></ul></li><li>dmidecode -q<ul><li> 显示硬件系统部件 - (SMBIOS / DMI)</li></ul></li><li>hdparm -i /dev/hda<ul><li> 罗列一个磁盘的架构特性</li></ul></li><li>hdparm -tT /dev/sda<ul><li> 在磁盘上执行测试性读取操作</li></ul></li><li>cat /proc/cpuinfo<ul><li> 显示CPU info的信息</li></ul></li><li>cat /proc/interrupts<ul><li> 显示中断</li></ul></li><li>cat /proc/meminfo<ul><li> 校验内存使用</li></ul></li><li>cat /proc/swaps<ul><li> 显示哪些swap被使用</li></ul></li><li>cat /proc/version<ul><li> 显示内核的版本</li></ul></li><li>cat /proc/net/dev<ul><li> 显示网络适配器及统计</li></ul></li><li>cat /proc/mounts<ul><li> 显示已加载的文件系统</li></ul></li><li>lspci -tv <ul><li>罗列 PCI 设备</li></ul></li><li>lsusb -tv<ul><li> 显示 USB 设备</li></ul></li><li>date 显示系统日期</li><li>cal 2007 显示2007年的日历表</li><li>date 041217002007.00 设置日期和时间 - 月日时分年.秒</li><li>clock -w 将时间修改保存到 BIOS</li></ul></blockquote><h2 id="2-关机"><a href="#2-关机" class="headerlink" title="2. 关机"></a>2. 关机</h2><blockquote><ul><li>shutdown -h now 关闭系统(1)</li><li>init 0 关闭系统(2)</li><li>telinit 0 关闭系统(3)</li><li>shutdown -h hours:minutes &amp; 按预定时间关闭系统</li><li>shutdown -c 取消按预定时间关闭系统</li><li>shutdown -r now 重启(1)</li><li>reboot 重启(2)</li><li>logout 注销</li></ul></blockquote><h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3. 文件和目录"></a>3. 文件和目录</h2><blockquote><ul><li>cd /home <ul><li>进入 ‘/ home’ 目录’</li></ul></li><li>cd .. <ul><li>返回上一级目录</li></ul></li><li>cd ../.. <ul><li>返回上两级目录</li></ul></li><li>cd <ul><li>进入个人的主目录</li></ul></li><li>cd ~user1<ul><li>进入个人的主目录</li></ul></li><li>cd -<ul><li>返回上次所在的目录</li></ul></li><li>pwd <ul><li>显示工作路径</li></ul></li><li>ls<ul><li>查看目录中的文件</li></ul></li><li>ls -F<ul><li>查看目录中的文件</li></ul></li><li>ls -l<ul><li>显示文件和目录的详细资料</li></ul></li><li>ls -a<ul><li>显示隐藏文件</li></ul></li><li>ls <em>[0-9]</em><ul><li>显示包含数字的文件名和目录名</li></ul></li><li>tree<ul><li>显示文件和目录由根目录开始的树形结构(1)</li></ul></li><li>lstree<ul><li>显示文件和目录由根目录开始的树形结构(2)</li></ul></li><li>mkdir dir1<ul><li>创建一个叫做 ‘dir1’ 的目录’</li></ul></li><li>mkdir dir1 dir2<ul><li>同时创建两个目录</li></ul></li><li>mkdir -p /tmp/dir1/dir2<ul><li>创建一个目录树</li></ul></li><li>rm -f file1<ul><li>删除一个叫做 ‘file1’ 的文件’</li></ul></li><li>rmdir dir1<ul><li>删除一个叫做 ‘dir1’ 的目录’</li></ul></li><li>rm -rf dir1<ul><li>删除一个叫做 ‘dir1’ 的目录并同时删除其内容</li></ul></li><li>rm -rf dir1 dir2<ul><li>同时删除两个目录及它们的内容</li></ul></li><li>mv dir1 new_dir<ul><li>重命名/移动 一个目录</li></ul></li><li>cp file1 file2<ul><li>复制一个文件</li></ul></li><li>cp dir/* .<ul><li>复制一个目录下的所有文件到当前工作目录</li></ul></li><li>cp -a /tmp/dir1 .<ul><li>复制一个目录到当前工作目录</li></ul></li><li>cp -a dir1 dir2 <ul><li>复制一个目录</li></ul></li><li>ln -s file1 lnk1 <ul><li>创建一个指向文件或目录的软链接</li></ul></li><li>ln file1 lnk1 <ul><li>创建一个指向文件或目录的物理链接</li></ul></li><li>touch -t 0712250000 file1 <ul><li>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</li></ul></li><li>file file1 outputs the mime type of the file as text</li><li>iconv -l <ul><li>列出已知的编码</li></ul></li><li>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</li><li>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</li></ul></blockquote><h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4. 文件搜索"></a>4. 文件搜索</h2><blockquote><ul><li>find / -name file1<ul><li>从 ‘/‘ 开始进入根文件系统搜索文件和目录</li></ul></li><li>find / -user user1<ul><li>搜索属于用户 ‘user1’ 的文件和目录</li></ul></li><li>find /home/user1 -name *.bin<ul><li>在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件</li></ul></li><li>find /usr/bin -type f -atime<ul><li>+100 搜索在过去100天内未被使用过的执行文件</li></ul></li><li>find /usr/bin -type f -mtime -10<ul><li>搜索在10天内被创建或者修改过的文件</li></ul></li><li>find / -name *.rpm -exec chmod 755 ‘{}’ ;<ul><li>搜索以 ‘.rpm’ 结尾的文件并定义其权限</li></ul></li><li>find / -xdev -name *.rpm<ul><li>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</li></ul></li><li>locate *.ps<ul><li>寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</li></ul></li><li>whereis halt<ul><li>显示一个二进制文件、源码或man的位置</li></ul></li><li>which halt<ul><li>显示一个二进制文件或可执行文件的完整路径</li></ul></li></ul></blockquote><h2 id="5-挂载一个文件系统"><a href="#5-挂载一个文件系统" class="headerlink" title="5. 挂载一个文件系统"></a>5. 挂载一个文件系统</h2><blockquote><ul><li>mount /dev/hda2 /mnt/hda2<ul><li>挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在</li></ul></li><li>umount /dev/hda2<ul><li>卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出</li></ul></li><li>fuser -km /mnt/hda2<ul><li>当设备繁忙时强制卸载</li></ul></li><li>umount -n /mnt/hda2<ul><li>运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</li></ul></li><li>mount /dev/fd0 /mnt/floppy<ul><li>挂载一个软盘</li></ul></li><li>mount /dev/cdrom /mnt/cdrom<ul><li>挂载一个cdrom或dvdrom</li></ul></li><li>mount /dev/hdc /mnt/cdrecorder<ul><li>挂载一个cdrw或dvdrom</li></ul></li><li>mount /dev/hdb /mnt/cdrecorder<ul><li>挂载一个cdrw或dvdrom</li></ul></li><li>mount -o loop file.iso /mnt/cdrom<ul><li>挂载一个文件或ISO镜像文件</li></ul></li><li>mount -t vfat /dev/hda5 /mnt/hda5<ul><li>挂载一个Windows FAT32文件系统</li></ul></li><li>mount /dev/sda1 /mnt/usbdisk<ul><li>挂载一个usb 捷盘或闪存设备</li></ul></li><li>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share<ul><li>挂载一个windows网络共享</li></ul></li></ul></blockquote><h2 id="6-磁盘空间"><a href="#6-磁盘空间" class="headerlink" title="6. 磁盘空间"></a>6. 磁盘空间</h2><blockquote><ul><li>df -h <ul><li>显示已经挂载的分区列表</li></ul></li><li>ls -lSr |more <ul><li>以尺寸大小排列文件和目录</li></ul></li><li>du -sh dir1 <ul><li>估算目录 ‘dir1’ 已经使用的磁盘空间’</li></ul></li><li>du -sk * | sort -rn <ul><li>以容量大小为依据依次显示文件和目录的大小</li></ul></li><li>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n <ul><li>以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</li></ul></li><li>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n <ul><li>以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</li></ul></li></ul></blockquote><h2 id="7-用户和群组"><a href="#7-用户和群组" class="headerlink" title="7. 用户和群组"></a>7. 用户和群组</h2><blockquote><ul><li>groupadd group_name <ul><li>创建一个新用户组</li></ul></li><li>groupdel group_name <ul><li>删除一个用户组</li></ul></li><li>groupmod -n new_group_name old_group_name <ul><li>重命名一个用户组</li></ul></li><li>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” <ul><li>用户组的用户</li></ul></li><li>useradd user1 <ul><li>创建一个新用户</li></ul></li><li>userdel -r user1 <ul><li>删除一个用户 ( ‘-r’ 排除主目录)</li></ul></li><li>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 <ul><li>修改用户属性</li></ul></li><li>passwd <ul><li>修改口令</li></ul></li><li>passwd user1 <ul><li>修改一个用户的口令 (只允许root执行)</li></ul></li><li>chage -E 2005-12-31 user1 <ul><li>设置用户口令的失效期限</li></ul></li><li>pwck <ul><li>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户</li></ul></li><li>grpck <ul><li>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组</li></ul></li><li>newgrp group_name <ul><li>登陆进一个新的群组以改变新创建文件的预设群组</li></ul></li></ul></blockquote><h2 id="8-文件的权限-使用-“-”-设置权限，使用-“-”-用于取消"><a href="#8-文件的权限-使用-“-”-设置权限，使用-“-”-用于取消" class="headerlink" title="8. 文件的权限 使用 “+” 设置权限，使用 “-” 用于取消"></a>8. 文件的权限 使用 “+” 设置权限，使用 “-” 用于取消</h2><blockquote><ul><li>ls -lh <ul><li>显示权限</li></ul></li><li>ls /tmp | pr -T5 -W$COLUMNS <ul><li>将终端划分成5栏显示</li></ul></li><li>chmod ugo+rwx directory1 <ul><li>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</li></ul></li><li>chmod go-rwx directory1 <ul><li>删除群组(g)与其他人(o)对目录的读写执行权限</li></ul></li><li>chown user1 file1 <ul><li>改变一个文件的所有人属性</li></ul></li><li>chown -R user1 directory1 <ul><li>改变一个目录的所有人属性并同时改变改目录下所有文件的属性</li></ul></li><li>chgrp group1 file1 <ul><li>改变文件的群组</li></ul></li><li>chown user1:group1 file1 <ul><li>改变一个文件的所有人和群组属性</li></ul></li><li>find / -perm -u+s <ul><li>罗列一个系统中所有使用了SUID控制的文件</li></ul></li><li>chmod u+s /bin/file1 <ul><li>设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</li></ul></li><li>chmod u-s /bin/file1 <ul><li>禁用一个二进制文件的 SUID位</li></ul></li><li>chmod g+s /home/public <ul><li>设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</li></ul></li><li>chmod g-s /home/public <ul><li>禁用一个目录的 SGID 位</li></ul></li><li>chmod o+t /home/public <ul><li>设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</li></ul></li><li>chmod o-t /home/public <ul><li>禁用一个目录的 STIKY 位</li></ul></li><li>chmod +x <ul><li>文件路径 为所有者、所属组和其他用户添加执行的权限</li></ul></li><li>chmod -x <ul><li>文件路径 为所有者、所属组和其他用户删除执行的权限</li></ul></li><li>chmod u+x <ul><li>文件路径 为所有者添加执行的权限</li></ul></li><li>chmod g+x <ul><li>文件路径 为所属组添加执行的权限</li></ul></li><li>chmod o+x <ul><li>文件路径 为其他用户添加执行的权限</li></ul></li><li>chmod ug+x <ul><li>文件路径 为所有者、所属组添加执行的权限</li></ul></li><li>chmod =wx <ul><li>文件路径 为所有者、所属组和其他用户添加写、执行的权限，取消读权限</li></ul></li><li>chmod ug=wx <ul><li>文件路径 为所有者、所属组添加写、执行的权限，取消读权限</li></ul></li></ul></blockquote><h2 id="9-文件的特殊属性-，使用-“-”-设置权限，使用-“-”-用于取消"><a href="#9-文件的特殊属性-，使用-“-”-设置权限，使用-“-”-用于取消" class="headerlink" title="9. 文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消"></a>9. 文件的特殊属性 ，使用 “+” 设置权限，使用 “-” 用于取消</h2><blockquote><ul><li>chattr +a file1 只允许以追加方式读写文件</li><li>chattr +c file1 允许这个文件能被内核自动压缩/解压</li><li>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件</li><li>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接</li><li>chattr +s file1 允许一个文件被安全地删除</li><li>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</li><li>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件</li><li>lsattr 显示特殊的属性</li></ul></blockquote><h2 id="10-打包和压缩文件"><a href="#10-打包和压缩文件" class="headerlink" title="10. 打包和压缩文件"></a>10. 打包和压缩文件</h2><blockquote><ul><li>bunzip2 file1.bz2<ul><li> 解压一个叫做 ‘file1.bz2’的文件</li></ul></li><li>bzip2 file1<ul><li> 压缩一个叫做 ‘file1’ 的文件</li></ul></li><li>gunzip file1.gz<ul><li> 解压一个叫做 ‘file1.gz’的文件</li></ul></li><li>gzip file1<ul><li> 压缩一个叫做 ‘file1’的文件</li></ul></li><li>gzip -9 file1<ul><li> 最大程度压缩</li></ul></li><li>rar a file1.rar test_file<ul><li> 创建一个叫做 ‘file1.rar’ 的包</li></ul></li><li>rar a file1.rar file1 file2 dir1<ul><li> 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</li></ul></li><li>rar x file1.rar<ul><li> 解压rar包</li></ul></li><li>unrar x file1.rar<ul><li> 解压rar包</li></ul></li><li>tar -cvf archive.tar file1<ul><li> 创建一个非压缩的 tarball</li></ul></li><li>tar -cvf archive.tar file1 file2 dir1<ul><li> 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</li></ul></li><li>tar -tf archive.tar<ul><li> 显示一个包中的内容</li></ul></li><li>tar -xvf archive.tar<ul><li> 释放一个包</li></ul></li><li>tar -xvf archive.tar -C /tmp<ul><li> 将压缩包释放到 /tmp目录下</li></ul></li><li>tar -cvfj archive.tar.bz2 dir1<ul><li> 创建一个bzip2格式的压缩包</li></ul></li><li>tar -xvfj archive.tar.bz2<ul><li> 解压一个bzip2格式的压缩包</li></ul></li><li>tar -cvfz archive.tar.gz dir1<ul><li> 创建一个gzip格式的压缩包</li></ul></li><li>tar -xvfz archive.tar.gz<ul><li> 解压一个gzip格式的压缩包</li></ul></li><li>zip file1.zip file1<ul><li> 创建一个zip格式的压缩包</li></ul></li><li>zip -r file1.zip file1 file2 dir1<ul><li> 将几个文件和目录同时压缩成一个zip格式的压缩包</li></ul></li><li>unzip file1.zip <ul><li>解压一个zip格式压缩包</li></ul></li></ul></blockquote><h2 id="11-RPM-包"><a href="#11-RPM-包" class="headerlink" title="11. RPM 包"></a>11. RPM 包</h2><blockquote><ul><li>rpm -ivh package.rpm<ul><li> 安装一个rpm包</li></ul></li><li>rpm -ivh –nodeeps package.rpm<ul><li> 安装一个rpm包而忽略依赖关系警告</li></ul></li><li>rpm -U package.rpm<ul><li> 更新一个rpm包但不改变其配置文件</li></ul></li><li>rpm -F package.rpm<ul><li> 更新一个确定已经安装的rpm包</li></ul></li><li>rpm -e package_name.rpm<ul><li> 删除一个rpm包</li></ul></li><li>rpm -qa <ul><li>显示系统中所有已经安装的rpm包</li></ul></li><li>rpm -qa | grep httpd<ul><li> 显示所有名称中包含 “httpd” 字样的rpm包</li></ul></li><li>rpm -qi package_name<ul><li> 获取一个已安装包的特殊信息</li></ul></li><li>rpm -qg “System Environment/Daemons”<ul><li> 显示一个组件的rpm包</li></ul></li><li>rpm -ql package_name<ul><li> 显示一个已经安装的rpm包提供的文件列表</li></ul></li><li>rpm -qc package_name<ul><li> 显示一个已经安装的rpm包提供的配置文件列表</li></ul></li><li>rpm -q package_name –whatrequires<ul><li> 显示与一个rpm包存在依赖关系的列表</li></ul></li><li>rpm -q package_name –whatprovides<ul><li> 显示一个rpm包所占的体积</li></ul></li><li>rpm -q package_name –scripts<ul><li> 显示在安装/删除期间所执行的脚本l</li></ul></li><li>rpm -q package_name –changelog<ul><li> 显示一个rpm包的修改历史</li></ul></li><li>rpm -qf /etc/httpd/conf/httpd.conf<ul><li> 确认所给的文件由哪个rpm包所提供</li></ul></li><li>rpm -qp package.rpm -l<ul><li> 显示由一个尚未安装的rpm包提供的文件列表</li></ul></li><li>rpm –import /media/cdrom/RPM-GPG-KEY<ul><li> 导入公钥数字证书</li></ul></li><li>rpm –checksig package.rpm<ul><li> 确认一个rpm包的完整性</li></ul></li><li>rpm -qa gpg-pubkey<ul><li> 确认已安装的所有rpm包的完整性</li></ul></li><li>rpm -V package_name<ul><li> 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</li></ul></li><li>rpm -Va<ul><li> 检查系统中所有已安装的rpm包- 小心使用</li></ul></li><li>rpm -Vp package.rpm<ul><li> 确认一个rpm包还未安装</li></ul></li><li>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em><ul><li> 从一个rpm包运行可执行文件</li></ul></li><li>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm<ul><li> 从一个rpm源码安装一个构建好的包</li></ul></li><li>rpmbuild –rebuild package_name.src.rpm<ul><li> 从一个rpm源码构建一个 rpm 包</li></ul></li></ul></blockquote><h2 id="12-YUM-软件包升级器"><a href="#12-YUM-软件包升级器" class="headerlink" title="12. YUM 软件包升级器"></a>12. YUM 软件包升级器</h2><blockquote><ul><li>yum install package_name<ul><li>下载并安装一个rpm包</li></ul></li><li>yum localinstall package_name.rpm <ul><li>将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</li></ul></li><li>yum update package_name.rpm<ul><li>更新当前系统中所有安装的rpm包</li></ul></li><li>yum update package_name<ul><li>更新一个rpm包</li></ul></li><li>yum remove package_name<ul><li>删除一个rpm包</li></ul></li><li>yum list<ul><li>列出当前系统中安装的所有包</li></ul></li><li>yum search package_name<ul><li>在rpm仓库中搜寻软件包</li></ul></li><li>yum clean packages<ul><li>清理rpm缓存删除下载的包</li></ul></li><li>yum clean headers<ul><li>删除所有头文件</li></ul></li><li>yum clean all<ul><li>删除所有缓存的包和头文件yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件</li></ul></li></ul></blockquote><h2 id="13-deb-包"><a href="#13-deb-包" class="headerlink" title="13. deb 包"></a>13. deb 包</h2><blockquote><ul><li>dpkg -i package.deb<ul><li>安装/更新一个 deb 包</li></ul></li><li>dpkg -r package_name<ul><li>从系统删除一个 deb 包</li></ul></li><li>dpkg -l <ul><li>显示系统中所有已经安装的 deb 包</li></ul></li><li>dpkg -l | grep httpd<ul><li>显示所有名称中包含 “httpd” 字样的deb包</li></ul></li><li>dpkg -s package_name<ul><li>获得已经安装在系统中一个特殊包的信息</li></ul></li><li>dpkg -L package_name<ul><li>显示系统中已经安装的一个deb包所提供的文件列表</li></ul></li><li>dpkg –contents package.deb<ul><li>显示尚未安装的一个包所提供的文件列表</li></ul></li><li>dpkg -S /bin/ping<ul><li>确认所给的文件由哪个deb包提供</li></ul></li><li>APT 软件工具 (Debian, Ubuntu 以及类似系统)</li><li>apt-get install package_name<ul><li>安装/更新一个 deb 包</li></ul></li><li>apt-cdrom install package_name<ul><li>从光盘安装/更新一个 deb 包</li></ul></li><li>apt-get update<ul><li>升级列表中的软件包</li></ul></li><li>apt-get upgrade<ul><li>升级所有已安装的软件</li></ul></li><li>apt-get remove package_name<ul><li>从系统删除一个deb包</li></ul></li><li>apt-get check<ul><li>确认依赖的软件仓库正确</li></ul></li><li>apt-get clean <ul><li>从下载的软件包中清理缓存</li></ul></li><li>apt-cache search searched-package <ul><li>返回包含所要搜索字符串的软件包名称</li></ul></li></ul></blockquote><h2 id="14-查看文件内容"><a href="#14-查看文件内容" class="headerlink" title="14. 查看文件内容"></a>14. 查看文件内容</h2><blockquote><ul><li>cat file1 <ul><li>从第一个字节开始正向查看文件的内容</li></ul></li><li>tac file1 <ul><li>从最后一行开始反向查看一个文件的内容</li></ul></li><li>more file1 <ul><li>查看一个长文件的内容</li></ul></li><li>less file1 <ul><li>类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</li></ul></li><li>head -2 file1 <ul><li>查看一个文件的前两行</li></ul></li><li>tail -2 file1 <ul><li>查看一个文件的最后两行</li></ul></li><li>tail -f /var/log/messages <ul><li>实时查看被添加到一个文件中的内容</li></ul></li></ul></blockquote><h2 id="15-文本处理"><a href="#15-文本处理" class="headerlink" title="15. 文本处理"></a>15. 文本处理</h2><blockquote><ul><li>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</li><li>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt <ul><li>合并一个文件的详细说明文本，并将简介写入一个新文件中</li></ul></li><li>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt <ul><li>合并一个文件的详细说明文本，并将简介写入一个已有的文件中</li></ul></li><li>grep Aug /var/log/messages <ul><li>在文件 ‘/var/log/messages’中查找关键词”Aug”</li></ul></li><li>grep ^Aug /var/log/messages <ul><li>在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇</li></ul></li><li>grep [0-9] /var/log/messages <ul><li>选择 ‘/var/log/messages’ 文件中所有包含数字的行</li></ul></li><li>grep Aug -R /var/log/* <ul><li>在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”</li></ul></li><li>sed ‘s/stringa1/stringa2/g’ example.txt <ul><li>将example.txt文件中的 “string1” 替换成 “string2”</li></ul></li><li>sed ‘/^$/d’ example.txt <ul><li>从example.txt文件中删除所有空白行</li></ul></li><li>sed ‘/ *#/d; /^$/d’ example.txt <ul><li>从example.txt文件中删除所有注释和空白行</li></ul></li><li>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ <ul><li>合并上下单元格内容</li></ul></li><li>sed -e ‘1d’ result.txt <ul><li>从文件example.txt 中排除第一行</li></ul></li><li>sed -n ‘/stringa1/p’ <ul><li>查看只包含词汇 “string1”的行</li></ul></li><li>sed -e ‘s/ *$//‘ example.txt <ul><li>删除每一行最后的空白字符</li></ul></li><li>sed -e ‘s/stringa1//g’ example.txt <ul><li>从文档中只删除词汇 “string1” 并保留剩余全部</li></ul></li><li>sed -n ‘1,5p;5q’ example.txt <ul><li>查看从第一行到第5行内容</li></ul></li><li>sed -n ‘5p;5q’ example.txt <ul><li>查看第5行</li></ul></li><li>sed -e ‘s/00*/0/g’ example.txt <ul><li>用单个零替换多个零</li></ul></li><li>cat -n file1 <ul><li>标示文件的行数</li></ul></li><li>cat example.txt | awk ‘NR%2==1’ <ul><li>删除example.txt文件中的所有偶数行</li></ul></li><li>echo a b c | awk ‘{print $1}’ <ul><li>查看一行第一栏</li></ul></li><li>echo a b c | awk ‘{print $1,$3}’ <ul><li>查看一行的第一和第三栏</li></ul></li><li>paste file1 file2 <ul><li>合并两个文件或两栏的内容</li></ul></li><li>paste -d ‘+’ file1 file2 <ul><li>合并两个文件或两栏的内容，中间用”+”区分</li></ul></li><li>sort file1 file2 <ul><li>排序两个文件的内容</li></ul></li><li>sort file1 file2 | uniq <ul><li>取出两个文件的并集(重复的行只保留一份)</li></ul></li><li>sort file1 file2 | uniq -u <ul><li>删除交集，留下其他的行</li></ul></li><li>sort file1 file2 | uniq -d <ul><li>取出两个文件的交集(只留下同时存在于两个文件中的文件)</li></ul></li><li>comm -1 file1 file2 <ul><li>比较两个文件的内容只删除 ‘file1’ 所包含的内容</li></ul></li><li>comm -2 file1 file2 <ul><li>比较两个文件的内容只删除 ‘file2’ 所包含的内容</li></ul></li><li>comm -3 file1 file2 <ul><li>比较两个文件的内容只删除两个文件共有的部分</li></ul></li></ul></blockquote><h2 id="16-字符设置和文件格式转换"><a href="#16-字符设置和文件格式转换" class="headerlink" title="16. 字符设置和文件格式转换"></a>16. 字符设置和文件格式转换</h2><blockquote><ul><li>dos2unix filedos.txt fileunix.txt <ul><li>将一个文本文件的格式从MSDOS转换成UNIX</li></ul></li><li>unix2dos fileunix.txt filedos.txt <ul><li>将一个文本文件的格式从UNIX转换成MSDOS</li></ul></li><li>recode ..HTML &lt; page.txt &gt; page.html <ul><li>将一个文本文件转换成html</li></ul></li><li>recode -l | more <ul><li>显示所有允许的转换格式</li></ul></li></ul></blockquote><h2 id="17-文件系统分析"><a href="#17-文件系统分析" class="headerlink" title="17. 文件系统分析"></a>17. 文件系统分析</h2><blockquote><ul><li>badblocks -v /dev/hda1 <ul><li>检查磁盘hda1上的坏磁块</li></ul></li><li>fsck /dev/hda1 <ul><li>修复/检查hda1磁盘上linux文件系统的完整性</li></ul></li><li>fsck.ext2 /dev/hda1 <ul><li>修复/检查hda1磁盘上ext2文件系统的完整性</li></ul></li><li>e2fsck /dev/hda1 <ul><li>修复/检查hda1磁盘上ext2文件系统的完整性</li></ul></li><li>e2fsck -j /dev/hda1 <ul><li>修复/检查hda1磁盘上ext3文件系统的完整性</li></ul></li><li>fsck.ext3 /dev/hda1 <ul><li>修复/检查hda1磁盘上ext3文件系统的完整性</li></ul></li><li>fsck.vfat /dev/hda1 <ul><li>修复/检查hda1磁盘上fat文件系统的完整性</li></ul></li><li>fsck.msdos /dev/hda1 <ul><li>修复/检查hda1磁盘上dos文件系统的完整性</li></ul></li><li>dosfsck /dev/hda1 <ul><li>修复/检查hda1磁盘上dos文件系统的完整性</li></ul></li></ul></blockquote><h2 id="18-初始化一个文件系统"><a href="#18-初始化一个文件系统" class="headerlink" title="18. 初始化一个文件系统"></a>18. 初始化一个文件系统</h2><blockquote><ul><li>mkfs /dev/hda1 <ul><li>在hda1分区创建一个文件系统</li></ul></li><li>mke2fs /dev/hda1 <ul><li>在hda1分区创建一个linux ext2的文件系统</li></ul></li><li>mke2fs -j /dev/hda1 <ul><li>在hda1分区创建一个linux ext3(日志型)的文件系统</li></ul></li><li>mkfs -t vfat 32 -F /dev/hda1 <ul><li>创建一个 FAT32 文件系统</li></ul></li><li>fdformat -n /dev/fd0 <ul><li>格式化一个软盘</li></ul></li><li>mkswap /dev/hda3 <ul><li>创建一个swap文件系统</li></ul></li></ul></blockquote><h2 id="19-SWAP-文件系统"><a href="#19-SWAP-文件系统" class="headerlink" title="19. SWAP 文件系统"></a>19. SWAP 文件系统</h2><blockquote><ul><li>mkswap /dev/hda3 <ul><li>创建一个swap文件系统</li></ul></li><li>swapon /dev/hda3 <ul><li>启用一个新的swap文件系统</li></ul></li><li>swapon /dev/hda2 /dev/hdb3 <ul><li>启用两个swap分区</li></ul></li></ul></blockquote><h2 id="20-备份"><a href="#20-备份" class="headerlink" title="20. 备份"></a>20. 备份</h2><blockquote><ul><li>dump -0aj -f /tmp/home0.bak /home <ul><li>制作一个 ‘/home’ 目录的完整备份</li></ul></li><li>dump -1aj -f /tmp/home0.bak /home <ul><li>制作一个 ‘/home’ 目录的交互式备份</li></ul></li><li>restore -if /tmp/home0.bak <ul><li>还原一个交互式备份</li></ul></li><li>rsync -rogpav –delete /home /tmp <ul><li>同步两边的目录</li></ul></li><li>rsync -rogpav -e ssh –delete /home ip_address:/tmp <ul><li>通过SSH通道rsync</li></ul></li><li>rsync -az -e ssh –delete ip_addr:/home/public /home/local <ul><li>通过ssh和压缩将一个远程目录同步到本地目录</li></ul></li><li>rsync -az -e ssh –delete /home/local ip_addr:/home/public <ul><li>通过ssh和压缩将本地目录同步到远程目录</li></ul></li><li>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ <ul><li>通过ssh在远程主机上执行一次备份本地磁盘的操作</li></ul></li><li>dd if=/dev/sda of=/tmp/file1 <ul><li>备份磁盘内容到一个文件</li></ul></li><li>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ <ul><li>目录的交互式备份操作</li></ul></li><li>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ <ul><li>通过ssh在远程目录中复制一个目录内容</li></ul></li><li>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ <ul><li>通过ssh在远程目录中复制一个本地目录</li></ul></li><li>tar cf - . | (cd /tmp/backup ; tar xf - ) <ul><li>本地将一个目录复制到另一个地方，保留原有权限及链接</li></ul></li><li>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents <ul><li>从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录</li></ul></li><li>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 <ul><li>查找所有以 ‘.log’ 结尾的文件并做成一个bzip包</li></ul></li><li>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 <ul><li>做一个将 MBR (Master Boot Record)内容复制到软盘的动作</li></ul></li><li>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 <ul><li>从已经保存到软盘的备份中恢复MBR内容</li></ul></li></ul></blockquote><h2 id="21-光盘"><a href="#21-光盘" class="headerlink" title="21. 光盘"></a>21. 光盘</h2><blockquote><ul><li>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force <ul><li>清空一个可复写的光盘内容</li></ul></li><li>mkisofs /dev/cdrom &gt; cd.iso <ul><li>在磁盘上创建一个光盘的iso镜像文件</li></ul></li><li>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz <ul><li>在磁盘上创建一个压缩了的光盘iso镜像文件</li></ul></li><li>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd <ul><li>创建一个目录的iso镜像文件</li></ul></li><li>cdrecord -v dev=/dev/cdrom cd.iso <ul><li>刻录一个ISO镜像文件</li></ul></li><li>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - <ul><li>刻录一个压缩了的ISO镜像文件</li></ul></li><li>mount -o loop cd.iso /mnt/iso <ul><li>挂载一个ISO镜像文件</li></ul></li><li>cd-paranoia -B <ul><li>从一个CD光盘转录音轨到 wav 文件中</li></ul></li><li>cd-paranoia – “-3” <ul><li>从一个CD光盘转录音轨到 wav 文件中（参数-3）</li></ul></li><li>cdrecord –scanbus <ul><li>扫描总线以识别scsi通道</li></ul></li><li>dd if=/dev/hdc | md5sum <ul><li>校验一个设备的md5sum编码，例如一张 CD</li></ul></li></ul></blockquote><h2 id="22-网络（以太网和-WIFI-无线）"><a href="#22-网络（以太网和-WIFI-无线）" class="headerlink" title="22. 网络（以太网和 WIFI 无线）"></a>22. 网络（以太网和 WIFI 无线）</h2><blockquote><ul><li>ifconfig eth0 <ul><li>显示一个以太网卡的配置</li></ul></li><li>ifup eth0 <ul><li>启用一个 ‘eth0’ 网络设备</li></ul></li><li>ifdown eth0 <ul><li>禁用一个 ‘eth0’ 网络设备</li></ul></li><li>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 <ul><li>控制IP地址</li></ul></li><li>ifconfig eth0 promisc <ul><li>设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)</li></ul></li><li>dhclient eth0 <ul><li>以dhcp模式启用 ‘eth0’</li></ul></li><li>route -n show routing table</li><li>route add -net 0/0 gw IP_Gateway configura default gateway</li><li>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’</li><li>route del 0/0 gw IP_gateway remove static route</li><li>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing</li><li>hostname show hostname of system</li><li>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(1)</li><li>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa(2)</li><li>ip link show show link status of all interfaces</li><li>mii-tool eth0 show link status of ‘eth0’</li><li>ethtool eth0 show statistics of network card ‘eth0’</li><li>netstat -tup show all active network connections and their PID</li><li>netstat -tupl show all network services listening on the system and their PID</li><li>tcpdump tcp port 80 show all HTTP traffic</li><li>iwlist scan show wireless networks</li><li>iwconfig eth1 show configuration of a wireless network card</li><li>hostname show hostname</li><li>host <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</li><li>nslookup <a href="http://www.example.com/">www.example.com</a> lookup hostname to resolve name to ip address and viceversa</li><li>whois <a href="http://www.example.com/">www.example.com</a> lookup on Whois database</li></ul></blockquote><h2 id="23-列出目录内容"><a href="#23-列出目录内容" class="headerlink" title="23. 列出目录内容"></a>23. 列出目录内容</h2><blockquote><ul><li>ls -a：显示所有文件（包括隐藏文件）；</li><li>ls -l：显示详细信息；</li><li>ls -R：递归显示子目录结构；</li><li>ls -ld：显示目录和链接信息；</li><li>ctrl+r：历史记录中所搜命令（输入命令中的任意一个字符）；</li><li>Linux中以.开头的文件是隐藏文件；</li><li>pwd:显示当前目录</li></ul></blockquote><h2 id="24-查看文件的类型"><a href="#24-查看文件的类型" class="headerlink" title="24. 查看文件的类型"></a>24. 查看文件的类型</h2><ul><li><blockquote><p>file:查看文件的类型</p></blockquote></li></ul><h2 id="25-复制文件目录"><a href="#25-复制文件目录" class="headerlink" title="25. 复制文件目录"></a>25. 复制文件目录</h2><p>1、<strong>cp</strong>：复制文件和目录 cp 源文件（文件夹）目标文件（文件夹）</p><blockquote><ul><li><p>常用参数：</p></li><li><p>-r:递归复制整个目录树；</p></li><li><p>-v：显示详细信息；</p></li><li><p>复制文件夹时要在 cp 命令后面加一个-r 参数：</p><p>如：cp -r 源文件夹 目标文件夹</p></li></ul></blockquote><p>2、<strong>touch+文件名</strong>：当文件不存在的时候，创建相应的文件；当文件存在的时候，修改文件的创建时间。</p><blockquote><ul><li><p>功能：生成一个空文件或修改文件的存取/修改的时间记录值。</p></li><li><p>touch *：将当前下的文件时间修改为系统的当前时间</p></li><li><p>touch –d 20040210 test：将 test 文件的日期改为 20040210</p></li><li><p>touch abc：若 abc 文件存在，则修改为系统的当前时间；若不存在，则生成一个为当前时间的空文件</p></li></ul></blockquote><p>3、<strong>mv 文件 目标目录</strong>：移动或重命名文件或目录（如果指定文件名，则可以重命名文件）。可以将文件及目录移到另一目录下，或更改文件及目录的名称。</p><blockquote><ul><li><p>格式为：mv [参数]&lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p></li><li><p>mva.txt ../：将 a.txt 文件移动上层目录</p></li><li><p>mv a.txt b.txt：将 a.txt 改名为 b.txt</p></li><li><p>mvdir2 ../：将 dir2 目录上移一层</p></li></ul></blockquote><p>4、<strong>rm</strong>：删除文件；</p><blockquote><p>常用参数：</p><ul><li>-i：交互式 </li><li>-r：递归的删除包括目录中的所有内容</li></ul></blockquote><p>5、<strong>mkdir +文件夹名称</strong>：创建文件夹；</p><p>6、<strong>rm -r +文件夹名称</strong>：删除文件夹（空文件夹和非空文件夹都可删除）</p><blockquote><ul><li>rmdir 文件夹名称：删除文件夹（只能删除空文件夹）</li></ul></blockquote><p>7、<strong>mkdir -p dir1/dir2</strong>：在当前目录下创建 dir1 目录，并在 dir1 目录下创建 dir2 目录， 也就是连续创建两个目录（dir1/和 dir1/dir2）</p><p>8、<strong>rmdir –p dir1/dir2</strong>：删除 dir1 下的 dir2 目录，若 dir1 目录为空也删除它</p><p>9、**rm ***：删除当前目录下的所有文件</p><p>10、**-f 参数**：强迫删除文件 rm –f *.txt：强迫删除所有以后缀名为 txt 文件</p><p>11、**-i 参数**：删除文件时询问</p><blockquote><ul><li><p>rm 　–i * ：删除当前目录下的所有文件会有如下提示：</p></li><li><p>rm:backup:is a directory  遇到目录会略过</p></li><li><p>rm: remove ‘myfiles.txt’ ? Y</p></li><li><p>删除文件时会询问,可按 Y 或 N 键表示允许或拒绝删除文件</p></li></ul></blockquote><p>12、**-r 参数**：递归删除（连子目录一同删除，这是一个相当常用的参数）</p><blockquote><ul><li><p>rm -r test ：删除 test 目录（含 test 目录下所有文件和子目录）</p></li><li><p>rm -r *：删除所有文件（含当前目录所有文件、所有子目录和子目录下的文件） </p></li><li><p>一般在删除目录时 r 和 f 一起用，避免麻烦</p></li><li><p>rm -rf test ：强行删除、不加询问</p></li></ul></blockquote><p>13、<strong>grep</strong>：功能：在文件中搜索匹配的字符并进行输出</p><blockquote><ul><li><p>格式：grep[参数] &lt;要找的字串&gt; &lt;要寻找字 串的源文件&gt;</p></li><li><p>greplinux test.txt：搜索 test.txt 文件中字符串 linux 并输出</p></li></ul></blockquote><p>14、<strong>ln 命令</strong></p><blockquote><ul><li><p>功能：在文件和目录之间建立链接</p></li><li><p>格式：ln [参数] &lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p></li><li><p>链接分“软链接”和“硬链接”</p></li><li><p>1.软链接:</p></li><li><p>ln–s /usr/share/do doc ：创建一个链接文件 doc,并指向目录/usr/share/do</p></li><li><p>2.硬链接:</p></li><li><p>ln /usr/share/test hard：创建一个硬链接文件 hard，这时对于 test 文件对应 的存储区域来说，又多了一个文件指向它</p></li></ul></blockquote><h2 id="26-系统常用命令"><a href="#26-系统常用命令" class="headerlink" title="26. 系统常用命令"></a>26. 系统常用命令</h2><h3 id="26-1、显示命令"><a href="#26-1、显示命令" class="headerlink" title="26.1、显示命令"></a>26.1、显示命令</h3><blockquote><ul><li><p>date:查看或设置当前系统的时间：格式化显示时间：+%Y–%m–%d；</p></li><li><p>date -s:设置当前系统的时间</p></li><li><p>hwclock(clock)：显示硬件时钟时间(需要管理员权限)；</p></li><li><p>cal：查看日历 格式 cal [参数] 月年</p></li><li><p>cal：显示当月的日历 cal7 2023：显示 2023 年 7 月的日历</p></li><li><p>cal- y 2023：显示 2023年的日历</p></li><li><p>uptime：查看系统运行时间</p></li></ul></blockquote><h3 id="26-2、输出查看命令"><a href="#26-2、输出查看命令" class="headerlink" title="26.2、输出查看命令"></a>26.2、输出查看命令</h3><blockquote><ul><li><p>echo：显示输入的内容 追加文件 echo “文件名” &gt;&gt; 文件名.txt</p></li><li><p>cat：显示文件内容,也可以将数个文件合并成一个文件。格式：格式：cat[参数]&lt;文件名&gt;</p></li><li><p>cat test.txt：显示 test.txt 文件内容</p></li><li><p>cat test.txt | more ：逐页显示 test.txt 文件中的内容</p></li><li><p>cat test.txt &gt;&gt; test1.txt ：将 test.txt 的内容附加到 test1.txt 文件之后</p></li><li><p>cat test.txt test2.txt &gt;readme.txt 　: 将 test.txt 和 test2.txt 文件合并成 readme.txt 文件</p></li><li><p>head:显示文件的头几行（默认 10 行） -n:指定显示的行数格式：head -n 文件名</p></li><li><p>tail：显示文件的末尾几行（默认 10 行）-n：指定显示的行数 -f：追踪显示文件更新 （一般用于查看日志，命令不会退出，而是持续显示新加入的内容）格式：格式：tail[参数]&lt;文件名&gt;</p></li><li><p>tail-10 /etc/passwd ：显示/etc/passwd/文件的倒数 10 行内容</p></li><li><p>tail+10 /etc/passwd ：显示/etc/passwd/文件从第 10 行开始到末尾的内容</p></li><li><p>more：用于翻页显示文件内容（只能向下翻页）</p></li><li><p>more 命令是一般用于要显示的内容会超过一个画面长度的情况。为了避免画 面显示时瞬间就闪过去，用户可以使用 more 命令，让画面在显示满一页时暂停，此时可按空格键继续显示下一个画面，或按 Q 键停止显示。</p></li><li><p>ls -al |more：以长格形式显示 etc 目录下的文件列表，显示满一个画面便暂停，可 按空格键继续显示下一画面，或按 Q 键跳离</p></li><li><p>less：翻页显示文件内容（带上下翻页）按下上键分页，按 q 退出、‘</p></li><li><p>less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同 的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来卷动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 Q 键即可。</p></li><li><p>ls -al | less：以长格形式列出/etc 目录中所有的内容。用户可按上下键浏览或按 Q 键跳离</p></li></ul></blockquote><h3 id="26-3、查看硬件信息"><a href="#26-3、查看硬件信息" class="headerlink" title="26.3、查看硬件信息"></a>26.3、查看硬件信息</h3><blockquote><ul><li><p>Ispci：查看 PCI 设备 -v：查看详细信息</p></li><li><p>Isusb：查看 USB 设备 -v：查看详细信息</p></li><li><p>Ismod：查看加载的模块(驱动)</p></li></ul></blockquote><h3 id="26-4、关机、重启"><a href="#26-4、关机、重启" class="headerlink" title="26.4、关机、重启"></a>26.4、关机、重启</h3><blockquote><ul><li><p>shutdown 关闭、重启计算机</p></li><li><p>shutdown[关机、重启]时间 -h 关闭计算机 -r：重启计算机</p><ul><li>如：<ul><li>立即关机：shutdown -h now</li><li>10 分钟后关机：shutdown -h +10</li><li>23:30 分关机：shutdown -h 23:30</li><li>立即重启：shutdown -r now</li></ul></li></ul></li><li><p>poweroff：立即关闭计算机</p></li><li><p>reboot：立即重启计算机</p></li></ul></blockquote><h3 id="26-5、归档、压缩"><a href="#26-5、归档、压缩" class="headerlink" title="26.5、归档、压缩"></a>26.5、归档、压缩</h3><blockquote><ul><li><p>zip:压缩文件 zip liuyazhuang.zip myfile 格式为：“zip 压缩后的 zip 文件文件名”</p></li><li><p>unzip：解压文件 unzip liuyazhuang.zip</p></li><li><p>gzip：压缩文件 gzip 文件名</p></li><li><p>tar：归档文件</p></li><li><p>tar -cvf out.tar liuyazhuang 打包一个归档（将文件”liuyazhuang”打包成一个归档）</p></li><li><p>tar -xvf liuyazhuang.tar 释放一个归档（释放 liuyazhuang.tar 归档）</p></li><li><p>tar -cvzf backup.tar.gz/etc</p></li><li><p>-z 参数将归档后的归档文件进行 gzip 压缩以减少大小。</p></li><li><p>-c：创建一个新 tar 文件</p></li><li><p>-v：显示运行过程的信息</p></li><li><p>-f：指定文件名</p></li><li><p>-z：调用 gzip 压缩命令进行压缩</p></li><li><p>-t：查看压缩文件的内容</p></li><li><p>-x：解开 tar 文件</p></li><li><p>tar -cvf test.tar *：将所有文件打包成 test.tar,扩展名.tar 需自行加上</p></li><li><p>tar -zcvf test.tar.gz *：将所有文件打包成 test.tar,再用 gzip 命令压缩</p></li><li><p>tar -tf test.tar ：查看 test.tar 文件中包括了哪些文件</p></li><li><p>tar -xvf test.tar 将 test.tar 解开</p></li><li><p>tar -zxvf foo.tar.gz 解压缩</p></li><li><p>gzip 各 gunzip 命令</p></li><li><p>gziptest.txt ：压缩文件时，不需要任何参数</p></li><li><p>gizp–l test.txt.gz：显示压缩率</p></li></ul></blockquote><h3 id="26-6、查找"><a href="#26-6、查找" class="headerlink" title="26.6、查找"></a>26.6、查找</h3><blockquote><ul><li><p>locate：快速查找文件、文件夹：locate keyword</p></li><li><p>此命令需要预先建立数据库，数据库默认每天更新一次，可用 updatedb 命令手工建立、更新数据库。</p></li><li><p>find 查找位置查找参数</p><ul><li>如：<ul><li>find . -name<em>XXX</em>查找当前目录下名称中含有”XXX”的文件</li><li>find / -name *.conf 查找根目录下（整个硬盘）下后缀为.conf 的文件</li><li>find / -perm 777 查找所有权限是 777 的文件</li><li>find / -type d 返回根目录下所有的目录</li><li>find . -name “a*”-exec ls -l {} ;</li><li>find 功能：用来寻找文件或目录。</li><li>格式：find [&lt;路径&gt;][匹配条件]</li><li>find / -name httpd.conf 搜索系统根目录下名为 httpd.conf 的文件</li></ul></li></ul></li></ul></blockquote><h3 id="26-7、ctrl-c-终止当前的命令"><a href="#26-7、ctrl-c-终止当前的命令" class="headerlink" title="26.7、ctrl+c :终止当前的命令"></a>26.7、ctrl+c :终止当前的命令</h3><h3 id="26-8、who-或-w-命令"><a href="#26-8、who-或-w-命令" class="headerlink" title="26.8、who 或 w 命令"></a>26.8、who 或 w 命令</h3><blockquote><ul><li><p>功能：查看当前系统中有哪些用户登录</p></li><li><p>格式：who/w[参数]</p></li></ul></blockquote><h3 id="26-9、dmesg-命令"><a href="#26-9、dmesg-命令" class="headerlink" title="26.9、dmesg 命令"></a>26.9、dmesg 命令</h3><ul><li><blockquote><p>功能：显示系统诊断信息、操作系统版本号、物理内存的大小以及其它信息</p></blockquote></li></ul><h3 id="26-10、df-命令"><a href="#26-10、df-命令" class="headerlink" title="26.10、df 命令"></a>26.10、df 命令</h3><ul><li><blockquote><p>功能：用于查看文件系统的各个分区的占用情况</p></blockquote></li></ul><h3 id="26-11、du-命令"><a href="#26-11、du-命令" class="headerlink" title="26.11、du 命令"></a>26.11、du 命令</h3><blockquote><ul><li><p>功能：查看某个目录中各级子目录所使用的硬盘空间数</p></li><li><p>格式：du [参数] &lt;目录名&gt;</p></li></ul></blockquote><h3 id="26-12、free-命令"><a href="#26-12、free-命令" class="headerlink" title="26.12、free 命令"></a>26.12、free 命令</h3><ul><li><blockquote><p>功能：用于查看系统内存，虚拟内存（交换空间）的大小占用情况</p></blockquote></li></ul><h2 id="27-VIM"><a href="#27-VIM" class="headerlink" title="27. VIM"></a>27. VIM</h2><p>VIM 是一款功能强大的命令行文本编辑器，在 Linux 中通过 vim 命令可以启动 vim 编辑器。</p><p>一般使用 vim + 目标文件路径 的形式使用 vim</p><p>如果目标文件存在，则 vim 打开目标文件，如果目标文件不存在，则 vim 新建并打开该文件</p><p>:q：退出 vim 编辑器</p><p><strong>VIM 模式</strong></p><p>vim 拥有三种模式：</p><p><strong>（1）命令模式（常规模式）</strong></p><p>vim 启动后，默认进入命令模式，任何模式都可以通过 esc 键回到命令模式（可以多按几次），命令模式下可以键入不同的命令完成选择、复制、粘贴、撤销等操作。</p><p>命名模式常用命令如下：</p><blockquote><ul><li><p>i : 在光标前插入文本</p></li><li><p>o:在当前行的下面插入新行</p></li><li><p>dd:删除整行</p></li><li><p>yy：将当前行的内容放入缓冲区（复制当前行）</p></li><li><p>n+yy :将 n 行的内容放入缓冲区（复制 n 行）</p></li><li><p>p:将缓冲区中的文本放入光标后（粘贴）</p></li><li><p>u：撤销上一个操作</p></li><li><p>r:替换当前字符</p></li><li><p>/ 查找关键字</p></li></ul></blockquote><p><strong>（2）插入模式</strong></p><p>在命令模式下按 “ i “键，即可进入插入模式，在插入模式可以输入编辑文本内容，使用 esc 键可以返回命令模式。</p><p><strong>（3）ex 模式</strong></p><p>在命令模式中按” : “键可以进入 ex 模式，光标会移动到底部，在这里可以保存修改或退出 vim.</p><p>ext 模式常用命令如下：</p><blockquote><ul><li><p>:w ：保存当前的修改</p></li><li><p>:q ：退出</p></li><li><p>:q! ：强制退出，保存修改</p></li><li><p>:x :保存并退出，相当于:wq</p></li><li><p>:set number 显示行号</p></li><li><p>:! 系统命令 执行一个系统命令并显示结果</p></li><li><p>:sh ：切换到命令行，使用 ctrl+d 切换回 vim</p></li></ul></blockquote><h2 id="28-软件包管理命令-RPM"><a href="#28-软件包管理命令-RPM" class="headerlink" title="28. 软件包管理命令(RPM)"></a>28. 软件包管理命令(RPM)</h2><h3 id="28-1、软件包的安装"><a href="#28-1、软件包的安装" class="headerlink" title="28.1、软件包的安装"></a>28.1、软件包的安装</h3><p>使用 RPM 命令的安装模式可以将软件包内所有的组件放到系统中的正确路径</p><p>命令:</p><blockquote><ul><li>rpm –ivh xxx-2.6.2-8.i386.rpm</li><li>i：作用 rpm 的安装模式 </li><li>v: 校验文件信息 </li><li>h: 以＃号显示安装进度</li></ul></blockquote><h3 id="28-2、软件包的删除"><a href="#28-2、软件包的删除" class="headerlink" title="28.2、软件包的删除"></a>28.2、软件包的删除</h3><p>删除模式会将指定软件包的内容全部删除，但并不包括已更改过的配置文件，删除 RPM 软件包</p><p>命令：</p><ul><li><blockquote><p>rpm –e xxx</p></blockquote></li></ul><p>注意：</p><ul><li><blockquote><p>这里必须使用软件名“xxx”或”xxx-2.6.2-8 而不是使用当初安装时的软件包名.xxx-2.6.2-8.i386.rpm</p></blockquote></li></ul><h3 id="28-3、软件包升级"><a href="#28-3、软件包升级" class="headerlink" title="28.3、软件包升级"></a>28.3、软件包升级</h3><p>升级模式会安装用户所指定的更新版本，并删除已安装在系统中的相同软件包，升级软件包</p><p>命令：</p><ul><li><blockquote><p>rpm –Uvh xxx-2.6.2-8.i386.rpm –Uvh：升级参数</p></blockquote></li></ul><h3 id="28-4、软件包更新"><a href="#28-4、软件包更新" class="headerlink" title="28.4、软件包更新"></a>28.4、软件包更新</h3><p>更新模式下，rpm 命令会检查在命令行中所指定的软件包是否比系统中原有的软件 包更新。如果情况属实，rpm 命令会自动更新指定的软件包；反之，若系统中并没有指定软件包的较旧版本，rpm 命令并不会安装此软件包。而在升级模式下，不管系统中是否有较旧的版本，rpm 命令都会安装指定的软件包。</p><ul><li><blockquote><p>rpm –Fvhxxx-2.6.2-8.i386.rpm -Fvh：更新参数</p></blockquote></li></ul><h3 id="28-5、软件包查询"><a href="#28-5、软件包查询" class="headerlink" title="28.5、软件包查询"></a>28.5、软件包查询</h3><p>若要获取 RPM 软件包的相关信息，可以使用查询模式。</p><blockquote><ul><li>使用-q 参数可查询一个已安装的软件包的内容<ul><li>rpm –q xxx</li></ul></li><li>查询软件包所安装的位置<ul><li>rpm –ql package-name</li><li>rpm –ql xv (l 参数：显示文件列表)</li></ul></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>&lt;Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存溢出-String</title>
    <link href="/2023/06/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-String/"/>
    <url>/2023/06/20/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-String/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="内存溢出-String"><a href="#内存溢出-String" class="headerlink" title="内存溢出-String"></a>内存溢出-String</h1><h3 id="JDK1-6方法举例："><a href="#JDK1-6方法举例：" class="headerlink" title="JDK1.6方法举例："></a>JDK1.6方法举例：</h3><p>String.substring(int beginIndex, int endIndex);源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a string that is a substring of this string. The</span><br><span class="hljs-comment">     * substring begins at the specified &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; and</span><br><span class="hljs-comment">     * extends to the character at index &#123;<span class="hljs-doctag">@code</span> endIndex - 1&#125;.</span><br><span class="hljs-comment">     * Thus the length of the substring is &#123;<span class="hljs-doctag">@code</span> endIndex-beginIndex&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Examples:</span><br><span class="hljs-comment">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment">     * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment">     * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment">     * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      beginIndex   the beginning index, inclusive.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>      endIndex     the ending index, exclusive.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>     the specified substring.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>  IndexOutOfBoundsException  if the</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is negative, or</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125; is larger than the length of</span><br><span class="hljs-comment">     *             this &#123;<span class="hljs-doctag">@code</span> String&#125; object, or</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is larger than</span><br><span class="hljs-comment">     *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> bedinIndex, <span class="hljs-type">int</span> endIndex)</span>&#123;<br>    <span class="hljs-keyword">if</span>(beginIndex &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(endIndex &gt; count)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(beginIndex &gt; endIndex)&#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex - beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="hljs-built_in">this</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(offset + beginIndex, endIndex - beginIndex, value);<br>&#125;<br></code></pre></td></tr></table></figure><p>由源码分析可看出，substring方法在使用时，会构造一个新的String对象，问题所在也在此。</p><p>JDK1.6 String构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String(<span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count, <span class="hljs-type">char</span>[] value)&#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>    <span class="hljs-built_in">this</span>.offset = offset;<br>    <span class="hljs-built_in">this</span>.count = count;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.6中，String类的构造函数创建时非简单拷贝对象，而是将整个value引用。问题导致较大字符串就算不再被引用，内存也不会释放。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456789&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.substring(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">return</span> b;<br></code></pre></td></tr></table></figure><p>此处，字符串a只是临时的，而真正所用到的字符串b的内存数组，其实是从字符串a中共享所得。虽然字符串a本身可被回收，但其内存数据却不可释放，导致内存泄露。</p><h3 id="JDK1-8源码分析"><a href="#JDK1-8源码分析" class="headerlink" title="JDK1.8源码分析"></a>JDK1.8源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a string that is a substring of this string. The</span><br><span class="hljs-comment"> * substring begins at the specified &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; and</span><br><span class="hljs-comment"> * extends to the character at index &#123;<span class="hljs-doctag">@code</span> endIndex - 1&#125;.</span><br><span class="hljs-comment"> * Thus the length of the substring is &#123;<span class="hljs-doctag">@code</span> endIndex-beginIndex&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * Examples:</span><br><span class="hljs-comment"> * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment"> * &quot;hamburger&quot;.substring(4, 8) returns &quot;urge&quot;</span><br><span class="hljs-comment"> * &quot;smiles&quot;.substring(1, 5) returns &quot;mile&quot;</span><br><span class="hljs-comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      beginIndex   the beginning index, inclusive.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      endIndex     the ending index, exclusive.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>     the specified substring.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@exception</span>  IndexOutOfBoundsException  if the</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is negative, or</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125; is larger than the length of</span><br><span class="hljs-comment"> *             this &#123;<span class="hljs-doctag">@code</span> String&#125; object, or</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> beginIndex&#125; is larger than</span><br><span class="hljs-comment"> *             &#123;<span class="hljs-doctag">@code</span> endIndex&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(beginIndex);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (endIndex &gt; value.length) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(endIndex);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> endIndex - beginIndex;<br>    <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(subLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ((beginIndex == <span class="hljs-number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="hljs-built_in">this</span><br>            : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(value, beginIndex, subLen);<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK1.8 String构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Allocates a new &#123;<span class="hljs-doctag">@code</span> String&#125; that contains characters from a subarray</span><br><span class="hljs-comment"> * of the character array argument. The &#123;<span class="hljs-doctag">@code</span> offset&#125; argument is the</span><br><span class="hljs-comment"> * index of the first character of the subarray and the &#123;<span class="hljs-doctag">@code</span> count&#125;</span><br><span class="hljs-comment"> * argument specifies the length of the subarray. The contents of the</span><br><span class="hljs-comment"> * subarray are copied; subsequent modification of the character array does</span><br><span class="hljs-comment"> * not affect the newly created string.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  value</span><br><span class="hljs-comment"> *         Array that is the source of characters</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  offset</span><br><span class="hljs-comment"> *         The initial offset</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  count</span><br><span class="hljs-comment"> *         The length</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  IndexOutOfBoundsException</span><br><span class="hljs-comment"> *          If the &#123;<span class="hljs-doctag">@code</span> offset&#125; and &#123;<span class="hljs-doctag">@code</span> count&#125; arguments index</span><br><span class="hljs-comment"> *          characters outside the bounds of the &#123;<span class="hljs-doctag">@code</span> value&#125; array</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">String</span><span class="hljs-params">(<span class="hljs-type">char</span> value[], <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(count);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;<br>            <span class="hljs-built_in">this</span>.value = <span class="hljs-string">&quot;&quot;</span>.value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>    <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringIndexOutOfBoundsException</span>(offset + count);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在JDK1.8中，当我们需要一个子字符串的时候，substring 生成了一个新的字符串，这个字符串通过构造函数的 Arrays.copyOfRange 函数进行构造。此优化在JDK1.7时就已实现，新的实现虽然损失了性能，而且浪费了一些存储空间，但却保证了字符串的内部数组可以和字符串对象一起被回收，从而防止发生内存泄漏。</p><p><img src="https://raw.githubusercontent.com/oCo0c0/oCo0c0.github.io/main/img/avatar.png" alt="图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>&lt;JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存溢出 JVM调优</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stream流操作</title>
    <link href="/2023/06/10/JAVA%20Stream%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/06/10/JAVA%20Stream%E6%B5%81%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="JAVA-Stream流操作"><a href="#JAVA-Stream流操作" class="headerlink" title="JAVA Stream流操作"></a>JAVA Stream流操作</h1><ul><li><p>Stream流操作分为<strong>3种类型</strong>：</p><ul><li><p>创建Stream</p></li><li><p>Stream中间处理</p></li><li><p>终止Steam</p></li></ul></li></ul><h3 id="Stream特性"><a href="#Stream特性" class="headerlink" title="Stream特性"></a>Stream特性</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1.stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。<br>2.stream不会改变数据源，通常情况下会产生一个新的集合或一个值。<br>3.stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。<br></code></pre></td></tr></table></figure><h3 id="Stream特点"><a href="#Stream特点" class="headerlink" title="Stream特点"></a>Stream特点</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.</span>代码简洁：函数编程写出的代码简洁且意图明确，使用stream接口让你从此告别<span class="hljs-keyword">for</span>循环。<br><span class="hljs-number">2.</span>多核友好：Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下方法。<br><span class="hljs-number">3.</span><span class="hljs-built_in">Stream</span>不存储数据。<br><span class="hljs-number">4.</span><span class="hljs-built_in">Stream</span>不会改变源对象。相反，他们会返回一个持有结果的新<span class="hljs-built_in">Stream</span>。<br><span class="hljs-number">5.</span><span class="hljs-built_in">Stream</span>是惰性求值的（延迟执行）<br></code></pre></td></tr></table></figure><h3 id="Stream创建"><a href="#Stream创建" class="headerlink" title="Stream创建"></a>Stream创建</h3><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1.创建 Stream一个数据源（如： 集合、数组）， 获取一个流。<br>2.中间操作一个中间操作链，对数据源的数据进行处理。<br>3.终止操作(终端操作)一个终止操作，执行中间操作链，并产生结果 。<br></code></pre></td></tr></table></figure><h4 id="创建示例"><a href="#创建示例" class="headerlink" title="创建示例"></a>创建示例</h4><ul><li>通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//获取一个顺序流</span><br>Stream&lt;String&gt; stream = list.stream();<br><span class="hljs-comment">//获取一个并行流</span><br>Stream&lt;String&gt; parallelStream = list.parallelStream();<br></code></pre></td></tr></table></figure><ul><li>使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">IntStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> Arrays.stream(array);<br></code></pre></td></tr></table></figure><ul><li>使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>stream.forEach(System.out::println);<br>Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">3</span>).limit(<span class="hljs-number">4</span>);<br>stream2.forEach(System.out::println);<br>Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="hljs-number">3</span>);<br>stream3.forEach(System.out::println);<br></code></pre></td></tr></table></figure><h4 id="开始管道"><a href="#开始管道" class="headerlink" title="开始管道"></a>开始管道</h4><ul><li>主要负责新建一个Stream流，或者基于现有的数组、List、Set、Map等集合类型对象创建出新的Stream流。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>stream()</td><td>创建出一个新的stream串行流对象</td></tr><tr><td>parallelStream()</td><td>创建出一个可并行执行的stream流对象</td></tr><tr><td>Stream.of()</td><td>通过给定的一系列元素创建一个新的Stream串行流对象</td></tr></tbody></table><h4 id="中间管道"><a href="#中间管道" class="headerlink" title="中间管道"></a>中间管道</h4><ul><li>负责对Stream进行处理操作，并返回一个新的Stream对象，中间管道操作可以进行<strong>叠加</strong>。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>filter()</td><td>按照条件过滤符合要求的元素， 返回新的stream流</td></tr><tr><td>map()</td><td>将已有元素转换为另一个对象类型，一对一逻辑，返回新的stream流</td></tr><tr><td>flatMap()</td><td>将已有元素转换为另一个对象类型，一对多逻辑，即原来一个元素对象可能会转换为1个或者多个新类型的元素，返回新的stream流</td></tr><tr><td>limit()</td><td>仅保留集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>skip()</td><td>跳过集合前面指定个数的元素，返回新的stream流</td></tr><tr><td>concat()</td><td>将两个流的数据合并起来为1个新的流，返回新的stream流</td></tr><tr><td>distinct()</td><td>对Stream中所有元素进行去重，返回新的stream流</td></tr><tr><td>sorted()</td><td>对stream中所有的元素按照指定规则进行排序，返回新的stream流</td></tr><tr><td>peek()</td><td>对stream流中的每个元素进行逐个遍历处理，返回处理后的stream流</td></tr></tbody></table><h4 id="终止管道"><a href="#终止管道" class="headerlink" title="终止管道"></a>终止管道</h4><ul><li>顾名思义，通过终止管道操作之后，Stream流将<strong>会结束</strong>，最后可能会执行某些逻辑处理，或者是按照要求返回某些执行后的结果数据。</li></ul><table><thead><tr><th><strong>流方法</strong></th><th>功能说明</th></tr></thead><tbody><tr><td>count()</td><td>返回stream处理后最终的元素个数</td></tr><tr><td>max()</td><td>返回stream处理后的元素最大值</td></tr><tr><td>min()</td><td>返回stream处理后的元素最小值</td></tr><tr><td>findFirst()</td><td>找到第一个符合条件的元素时则终止流处理</td></tr><tr><td>findAny()</td><td>找到任何一个符合条件的元素时则退出流处理，这个<strong>对于串行流时与findFirst相同，对于并行流时比较高效</strong>，任何分片中找到都会终止后续计算逻辑</td></tr><tr><td>anyMatch()</td><td>返回一个boolean值，类似于isContains(),用于判断是否有符合条件的元素</td></tr><tr><td>allMatch()</td><td>返回一个boolean值，用于判断是否所有元素都符合条件</td></tr><tr><td>noneMatch()</td><td>返回一个boolean值， 用于判断是否所有元素都不符合条件</td></tr><tr><td>collect()</td><td>将流转换为指定的类型，通过Collectors进行指定</td></tr><tr><td>toArray()</td><td>将流转换为数组</td></tr><tr><td>iterator()</td><td>将流转换为Iterator对象</td></tr><tr><td>foreach()</td><td>无返回值，对元素进行逐个遍历，然后执行给定的处理逻辑</td></tr></tbody></table><h2 id="Stream方法使用"><a href="#Stream方法使用" class="headerlink" title="Stream方法使用"></a>Stream方法使用</h2><h4 id="map和flatMap"><a href="#map和flatMap" class="headerlink" title="map和flatMap"></a>map和flatMap</h4><ul><li><p>map与flatMap都是用于转换已有的元素为其它元素，区别点在于：</p><ul><li><p>map <strong>必须是一对一的</strong>，即每个元素都只能转换为1个新的元素</p></li><li><p>flatMap <strong>可以是一对多的</strong>，即每个元素都可以转换为1个或者多个新的元素</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringToIntMap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;105&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;469&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>);<br>    <span class="hljs-comment">// 使用流操作</span><br>    List&lt;User&gt; results = ids.stream()<br>            .map(id -&gt; &#123;<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                user.setId(id);<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;)<br>            .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>[User&#123;id=<span class="hljs-string">&#x27;205&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;105&#x27;</span>&#125;,<br> User&#123;id=<span class="hljs-string">&#x27;308&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;469&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;627&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;193&#x27;</span>&#125;, <br> User&#123;id=<span class="hljs-string">&#x27;111&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stringToIntFlatmap</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; sentences = Arrays.asList(<span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-string">&quot;coco&quot;</span>);<br>    <span class="hljs-comment">// 使用流操作</span><br>    List&lt;String&gt; results = sentences.stream()<br>            .flatMap(sentence -&gt; Arrays.stream(sentence.split(<span class="hljs-string">&quot; &quot;</span>)))<br>            .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>[hello, world, coco]<br></code></pre></td></tr></table></figure><ul><li>flatMap操作的时候是先将每个元素处理并返回一个新的Stream，然后将多个Stream展开合并为了一个完整的新的Stream。</li></ul><h4 id="peek和foreach"><a href="#peek和foreach" class="headerlink" title="peek和foreach"></a>peek和foreach</h4><ul><li><p>对元素进行遍历然后逐个的进行处理。</p></li><li><p>peek属于中间方法，只能作为管道中途的一个处理步骤，而没法直接执行得到结果，其后面必须还要有其它终止操作的时候才会被执行；</p></li><li><p>foreach属于终止方法，可以直接执行相关操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPeekAndforeach</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; sentences = Arrays.asList(<span class="hljs-string">&quot;hello world&quot;</span>,<span class="hljs-string">&quot;coco&quot;</span>);<br>    <span class="hljs-comment">// 演示点1：仅peek操作，最终不会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before peek----&quot;</span>);<br>    sentences.stream().peek(sentence -&gt; System.out.println(sentence));<br>    System.out.println(<span class="hljs-string">&quot;----after peek----&quot;</span>);<br>    <span class="hljs-comment">// 演示点2：仅foreach操作，最终会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before foreach----&quot;</span>);<br>    sentences.stream().forEach(sentence -&gt; System.out.println(sentence));<br>    System.out.println(<span class="hljs-string">&quot;----after foreach----&quot;</span>);<br>    <span class="hljs-comment">// 演示点3：peek操作后面增加终止操作，peek会执行</span><br>    System.out.println(<span class="hljs-string">&quot;----before peek and count----&quot;</span>);<br>    sentences.stream().peek(sentence -&gt; System.out.println(sentence)).count();<br>    System.out.println(<span class="hljs-string">&quot;----after peek and count----&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>----before peek----<br>----after peek----<br>----before foreach----<br>hello world<br>coco<br>----after foreach----<br>----before peek and count----<br>hello world<br>coco<br>----after peek and count----<br></code></pre></td></tr></table></figure><h4 id="filter、sorted、distinct、limit"><a href="#filter、sorted、distinct、limit" class="headerlink" title="filter、sorted、distinct、limit"></a>filter、sorted、distinct、limit</h4><ul><li>都是常用的Stream的中间操作方法,可以根据需要选择一个或者多个进行组合使用，或者同时使用多个相同方法的组合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetTargetUsers</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Dept&gt; ids = Arrays.asList(<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;99&quot;</span>,<span class="hljs-string">&quot;999&quot;</span>,<span class="hljs-string">&quot;9999&quot;</span>,<span class="hljs-string">&quot;99999&quot;</span>)<br>        .stream()<br>        <span class="hljs-comment">// 使用filter过滤掉不符合条件的数据</span><br>        .filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-comment">// 通过distinct对存量元素进行去重操作</span><br>        .distinct()<br>        <span class="hljs-comment">// 通过map操作将字符串转成整数类型</span><br>        .map(Integer::valueOf)<br>        <span class="hljs-comment">// 指定按照数字大小正序排列</span><br>        .sorted(Comparator.comparingInt(o -&gt; o))<br>        <span class="hljs-comment">// 使用limit截取排在前3位的元素</span><br>        .limit(<span class="hljs-number">3</span>)<br>        <span class="hljs-comment">// 使用map将id转为Dept对象类型</span><br>        .map(id -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(id))<br>        <span class="hljs-comment">// 使用collect终止操作将最终处理后的数据收集到list中</span><br>        .collect(Collectors.toList());<br>    System.out.println(results);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="简单结果终止方法"><a href="#简单结果终止方法" class="headerlink" title="简单结果终止方法"></a>简单结果终止方法</h4><ul><li>count、max、min、findAny、findFirst、anyMatch、allMatch、nonneMatch,结果形式是数字、布尔值或者Optional对象值等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleStopOptions</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>);<br>    <span class="hljs-comment">// 统计stream操作后剩余的元素个数</span><br>    System.out.println(ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>).count());<br>    <span class="hljs-comment">// 判断是否有元素值等于205</span><br>    System.out.println(ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>).anyMatch(<span class="hljs-string">&quot;205&quot;</span>::equals));<br>    <span class="hljs-comment">// findFirst操作</span><br>    ids.stream().filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>            .findFirst()<br>            .ifPresent(s -&gt; System.out.println(<span class="hljs-string">&quot;findFirst:&quot;</span> + s));<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-number">6</span><br><span class="hljs-literal">true</span><br>findFirst:<span class="hljs-number">205</span><br></code></pre></td></tr></table></figure><p><strong>一旦被执行了终止操作之后，后续便不可以再读这个流执行其他的操作</strong></p><h4 id="结果收集终止方法"><a href="#结果收集终止方法" class="headerlink" title="结果收集终止方法"></a>结果收集终止方法</h4><ul><li><p>结果数据：</p><ul><li>一个集合类，比如List、Set或者HashMap等;</li><li>StringBuilder对象，支持将多个字符串进行拼接处理并输出拼接后结果;</li><li>一个可以记录个数或者计算总和的对象（数据批量运算统计）。</li></ul></li></ul><h5 id="◆生成集合"><a href="#◆生成集合" class="headerlink" title="◆生成集合"></a>◆生成集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCollectStopOptions</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Dept&gt; ids = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">17</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">22</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dept</span>(<span class="hljs-number">23</span>));<br>    <span class="hljs-comment">// collect成list</span><br>    List&lt;Dept&gt; collectList = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toList());<br>    System.out.println(<span class="hljs-string">&quot;collectList:&quot;</span> + collectList);<br>    <span class="hljs-comment">// collect成Set</span><br>    Set&lt;Dept&gt; collectSet = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toSet());<br>    System.out.println(<span class="hljs-string">&quot;collectSet:&quot;</span> + collectSet);<br>    <span class="hljs-comment">// collect成HashMap，key为id，value为Dept对象</span><br>    Map&lt;Integer, Dept&gt; collectMap = ids.stream().filter(dept -&gt; dept.getId() &gt; <span class="hljs-number">20</span>)<br>            .collect(Collectors.toMap(Dept::getId, dept -&gt; dept));<br>    System.out.println(<span class="hljs-string">&quot;collectMap:&quot;</span> + collectMap);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="◆生成拼接字符串"><a href="#◆生成拼接字符串" class="headerlink" title="◆生成拼接字符串"></a>◆生成拼接字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCollectJoinStrings</span><span class="hljs-params">()</span> &#123;<br>    List&lt;String&gt; ids = Arrays.asList(<span class="hljs-string">&quot;205&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;308&quot;</span>, <span class="hljs-string">&quot;49&quot;</span>, <span class="hljs-string">&quot;627&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>, <span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-string">&quot;193&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">joinResult</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>    System.out.println(<span class="hljs-string">&quot;拼接后：&quot;</span> + joinResult);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="◆数据批量数学运算"><a href="#◆数据批量数学运算" class="headerlink" title="◆数据批量数学运算"></a>◆数据批量数学运算</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNumberCalculate</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; ids = Arrays.asList(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>);<br>    <span class="hljs-comment">// 计算平均值</span><br>    <span class="hljs-type">Double</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.averagingInt(value -&gt; value));<br>    System.out.println(<span class="hljs-string">&quot;平均值：&quot;</span> + average);<br>    <span class="hljs-comment">// 数据统计信息</span><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">summary</span> <span class="hljs-operator">=</span> ids.stream().collect(Collectors.summarizingInt(value -&gt; value));<br>    System.out.println(<span class="hljs-string">&quot;数据统计信息：&quot;</span> + summary);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="并行Stream"><a href="#并行Stream" class="headerlink" title="并行Stream"></a>并行Stream</h4><h5 id="◆Stream-API代替for循环"><a href="#◆Stream-API代替for循环" class="headerlink" title="◆Stream API代替for循环"></a>◆Stream API代替for循环</h5><ul><li>省略</li></ul><h5 id="◆将数组转换为管道流"><a href="#◆将数组转换为管道流" class="headerlink" title="◆将数组转换为管道流"></a>◆将数组转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] array = &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>Stream&lt;String&gt; nameStrs2 = Stream.of(array);<br>Stream&lt;String&gt; nameStrs3 = Stream.of(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="◆将集合类对象转换为管道流"><a href="#◆将集合类对象转换为管道流" class="headerlink" title="◆将集合类对象转换为管道流"></a>◆将集合类对象转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;&quot;</span>);<br>Stream&lt;String&gt; streamFromList = list.stream();<br>Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(list);<br>Stream&lt;String&gt; streamFromSet = set.stream();<br></code></pre></td></tr></table></figure><h5 id="◆将文本文件转换为管道流"><a href="#◆将文本文件转换为管道流" class="headerlink" title="◆将文本文件转换为管道流"></a>◆将文本文件转换为管道流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="hljs-string">&quot;file.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h5 id="◆filter与谓语逻辑"><a href="#◆filter与谓语逻辑" class="headerlink" title="◆filter与谓语逻辑"></a>◆filter与谓语逻辑</h5><ul><li>Predicate接口</li></ul><h5 id="◆and语法（并集）"><a href="#◆and语法（并集）" class="headerlink" title="◆and语法（并集）"></a>◆and语法（并集）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.and(Employee.genderM))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆or语法（交集）"><a href="#◆or语法（交集）" class="headerlink" title="◆or语法（交集）"></a>◆or语法（交集）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.or(Employee.genderM))<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆negate语法（取反）"><a href="#◆negate语法（取反）" class="headerlink" title="◆negate语法（取反）"></a>◆negate语法（取反）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Employee&gt; filtered = employees.stream()<br>        .filter(Employee.ageGreaterThan70.or(Employee.genderM).negate())<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="Stream管道流的map操作"><a href="#Stream管道流的map操作" class="headerlink" title="Stream管道流的map操作"></a>Stream管道流的map操作</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 全部转换成大写</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;Coco&quot;</span>, <span class="hljs-string">&quot;Liming&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-string">&quot;lisa&quot;</span>);<br>List&lt;String&gt; collect = list.stream().map(String::toUpperCase).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="处理非字符串类型集合元素"><a href="#处理非字符串类型集合元素" class="headerlink" title="处理非字符串类型集合元素"></a>处理非字符串类型集合元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; lengths = alpha.stream()<br>        .map(String::length)<br>        .collect(Collectors.toList());<br><span class="hljs-comment">// [6, 4, 7, 5]</span><br>Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .mapToInt(String::length);<br><span class="hljs-number">6</span><br><span class="hljs-number">4</span><br><span class="hljs-number">7</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="处理对象数据格式转换"><a href="#处理对象数据格式转换" class="headerlink" title="处理对象数据格式转换"></a>处理对象数据格式转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将每一个Employee的年龄增加一岁</span><br><span class="hljs-comment">// 将性别中的“M”换成“male”，F换成Female</span><br> List&lt;Employee&gt; maped = list.stream()<br>            .peek(e -&gt; &#123;<br>                e.setAge(e.getAge() + <span class="hljs-number">1</span>);<br>                e.setGender(e.getGender().equals(<span class="hljs-string">&quot;M&quot;</span>)?<span class="hljs-string">&quot;male&quot;</span>:<span class="hljs-string">&quot;female&quot;</span>);<br>            &#125;).collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; words = Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;word&quot;</span>);<br><span class="hljs-comment">// map处理</span><br>words.stream()<br>        .map(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)));<br><span class="hljs-comment">// 输出</span><br>[[h,e,l,l,o],[w,o,r,l,d]]<br><span class="hljs-comment">// flatMap处理</span><br>words.stream()<br>        .flatMap(w -&gt; Arrays.stream(w.split(<span class="hljs-string">&quot;&quot;</span>)));<br><span class="hljs-comment">// 输出</span><br>[h,e,l,l,o,w,o,r,l,d]<br></code></pre></td></tr></table></figure><h3 id="状态与并行操作"><a href="#状态与并行操作" class="headerlink" title="状态与并行操作"></a>状态与并行操作</h3><h4 id="中间操作：有状态与无状态"><a href="#中间操作：有状态与无状态" class="headerlink" title="中间操作：有状态与无状态"></a>中间操作：有状态与无状态</h4><ul><li><p>filter与map操作，不需要管道流的前面后面元素相关，所以不需要额外的记录元素之间的关系。输入一个元素，获得一个结果。</p></li><li><p>sorted是排序操作、distinct是去重操作。像这种操作都是和别的元素相关的操作，我自己无法完成整体操作。就像班级点名就是无状态的，喊到你你就答到就可以了。如果是班级同学按大小个排序，那就不是你自己的事了，你得和周围的同学比一下身高并记住，你记住的这个身高比较结果就是一种“状态”。所以这种操作就是有状态操作。</p><h5 id="◆Limit与Skip管道数据截取"><a href="#◆Limit与Skip管道数据截取" class="headerlink" title="◆Limit与Skip管道数据截取"></a>◆Limit与Skip管道数据截取</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; limitN = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .limit(<span class="hljs-number">2</span>)<br>        .collect(Collectors.toList());<br>List&lt;String&gt; skipN = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .skip(<span class="hljs-number">2</span>)<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><ul><li><p>limt方法传入一个整数n，用于截取管道中的前n个元素。经过管道处理之后的数据是：[Monkey, Lion]。</p></li><li><p>skip方法与limit方法的使用相反，用于跳过前n个元素，截取从n到末尾的元素。经过管道处理之后的数据是：[Giraffe, Lemur]。</p><h5 id="◆Distinct元素去重"><a href="#◆Distinct元素去重" class="headerlink" title="◆Distinct元素去重"></a>◆Distinct元素去重</h5></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; uniqueAnimals = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>)<br>    .distinct()<br>    .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆Sorted排序"><a href="#◆Sorted排序" class="headerlink" title="◆Sorted排序"></a>◆Sorted排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; alphabeticOrder = Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>)<br>        .sorted()<br>        .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h5 id="◆串行、并行与顺序"><a href="#◆串行、并行与顺序" class="headerlink" title="◆串行、并行与顺序"></a>◆串行、并行与顺序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.of(<span class="hljs-string">&quot;Monkey&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Giraffe&quot;</span>, <span class="hljs-string">&quot;Lemur&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>)<br>    .parallel()<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure><ul><li>parallel()函数表示对管道中的元素进行并行处理,元素的顺序无法保证。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Comparator接口</span><br>list.stream().sorted(Comparator.naturalOrder());<br><span class="hljs-comment">// Comparator.naturalOrder()-&gt;自然排序</span><br><span class="hljs-comment">// Comparator.reverseOrder()-&gt;倒序排序</span><br></code></pre></td></tr></table></figure><ul><li>对象字段排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(Comparator.comparing(User::getAge));<br><span class="hljs-comment">// 倒序</span><br>users.sort(Comparator.comparing(User::getAge).reversed());<br></code></pre></td></tr></table></figure><ul><li>Comparator链对List排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(<br>        Comparator.comparing(User::getGender)<br>        .thenComparing(User::getAge)<br>        .reversed()<br>);<br><span class="hljs-comment">// 都是正序 ，不加reversed</span><br><span class="hljs-comment">// 都是倒序，最后面加一个reserved</span><br><span class="hljs-comment">// 先是倒序（加reserved），然后正序</span><br><span class="hljs-comment">// 先是正序（加reserved），然后倒序（加reserved）</span><br></code></pre></td></tr></table></figure><h3 id="函数式接口Comparator"><a href="#函数式接口Comparator" class="headerlink" title="函数式接口Comparator"></a>函数式接口Comparator</h3><h4 id="只能有一个抽象方法的接口"><a href="#只能有一个抽象方法的接口" class="headerlink" title="只能有一个抽象方法的接口"></a><strong>只能有一个抽象方法的接口</strong></h4><h5 id="◆函数式接口的特点"><a href="#◆函数式接口的特点" class="headerlink" title="◆函数式接口的特点"></a>◆函数式接口的特点</h5><ul><li>接口有且仅有一个抽象方法；</li><li>允许定义静态非抽象方法；</li><li>允许定义默认defalut非抽象方法（default方法也是java8才有的，见下文）；</li><li>允许java.lang.Object中的public方法，如：equals方法；</li><li>FunctionInterface注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错,见源码查看。</li><li><strong>lambda表达式是只实现接口中唯一的抽象方法的匿名实现类</strong>。</li></ul><h5 id="◆default关键字"><a href="#◆default关键字" class="headerlink" title="◆default关键字"></a>◆default关键字</h5><ul><li><p>java8之前</p><ul><li>接口是不能有方法的实现，所有方法全都是抽象方法</li><li>实现接口就必须实现接口里面的所有方法</li><li>问题：<strong>当一个接口有很多的实现类的时候,修改这个接口就变成了一个非常麻烦的事,需要修改这个接口的所有实现类</strong>。</li></ul></li><li><p>java8引入default方法</p><ul><li><p>default方法可以有自己的默认实现，即有方法体。</p></li><li><p>接口实现类可以不去实现default方法，并且可以使用default方法。</p></li></ul></li></ul><h5 id="◆JDK中的函数式接口举例"><a href="#◆JDK中的函数式接口举例" class="headerlink" title="◆JDK中的函数式接口举例"></a>◆JDK中的函数式接口举例</h5><ul><li><p>java.lang.Runnable,</p></li><li><p>java.util.Comparator,</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.util.function包下的接口，如Consumer、Predicate、Supplier等</p></li></ul><h5 id="◆自定义Comparator排序"><a href="#◆自定义Comparator排序" class="headerlink" title="◆自定义Comparator排序"></a>◆自定义Comparator排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">users.sort(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User u1, User u2)</span> &#123;<br>        <span class="hljs-keyword">if</span>(u1.getAge() == u2.getAge())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge() &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// lambda</span><br>users.sort((u1,u2) -&gt; &#123;<br>    <span class="hljs-keyword">if</span>(u1.getAge() == u2.getAge())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> u1.getAge() - u2.getAge() &gt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="查找与匹配元素"><a href="#查找与匹配元素" class="headerlink" title="查找与匹配元素"></a>查找与匹配元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// anyMatch 一个符合就可以</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan70</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(Employee.ageGreaterThan70);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan72</span> <span class="hljs-operator">=</span> employees.stream().anyMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">72</span>);<br><span class="hljs-comment">// allMatch 全部符合</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeThan10</span> <span class="hljs-operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="hljs-number">10</span>);<br><span class="hljs-comment">// noneMatch 全部不符合</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isExistAgeLess18</span> <span class="hljs-operator">=</span> employees.stream().noneMatch(e -&gt; e.getAge() &lt; <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><h4 id="元素查找与Optional"><a href="#元素查找与Optional" class="headerlink" title="元素查找与Optional"></a>元素查找与Optional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查找第一个年龄大于40的员工</span><br>Optional&lt;Employee&gt; employeeOptional = employees.stream()<br>    .filter(e -&gt; e.getAge() &gt; <span class="hljs-number">40</span>).findFirst();<br></code></pre></td></tr></table></figure><ul><li>Optional类代表一个值存在或者不存在</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">isPresent() 将在 Optional 包含值的时候返回 true,否则返回 false;<br>ifPresent(Consumer block) 会在值存在的时候执行给定的代码块;<br>T get() 会在值存在时返回值，否则?出一个 NoSuchElement 异常;<br>T orElse(T other) 会在值存在时返回值,否则返回一个默认值;<br>findFirst用于查找第一个符合“匹配规则”的元素，返回值为Optional;<br>findAny用于查找任意一个符合“匹配规则”的元素，返回值为Optional。<br></code></pre></td></tr></table></figure><h3 id="元素归约"><a href="#元素归约" class="headerlink" title="元素归约"></a>元素归约</h3><ul><li><p>Stream.reduce用来实现集合元素的归约，reduce函数有三个参数：</p><ul><li>Identity标识：一个元素，它是归约操作的初始值，如果流为空，则为默认结果。</li><li>Accumulator累加器：具有两个参数的函数：归约运算的部分结果和流的下一个元素。</li><li>Combiner合并器（可选）：当归约并行化时，或当累加器参数的类型与累加器实现的类型不匹配时，用于合并归约操作的部分结果的函数。累加器：阶段累加结果作为累加器的第一个参数；集合遍历元素作为累加器的第二个参数。</li><li>reduce初始值为0，累加器可以是lambda表达式，也可以是方法引用。</li></ul></li></ul><h4 id="Integer类型归约"><a href="#Integer类型归约" class="headerlink" title="Integer类型归约"></a>Integer类型归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers<br>        .stream()<br>        .reduce(<span class="hljs-number">0</span>, (subtotal, element) -&gt; subtotal + element);<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers<br>        .stream()<br>        .reduce(<span class="hljs-number">0</span>, Integer::sum);<br><span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure><h4 id="String类型归约"><a href="#String类型归约" class="headerlink" title="String类型归约"></a>String类型归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; letters = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> letters<br>        .stream()<br>        .reduce(<span class="hljs-string">&quot;&quot;</span>, (partialString, element) -&gt; partialString + element);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> letters<br>        .stream()<br>        .reduce(<span class="hljs-string">&quot;&quot;</span>, String::concat);<br><span class="hljs-comment">// abcde</span><br></code></pre></td></tr></table></figure><h4 id="复杂对象归约"><a href="#复杂对象归约" class="headerlink" title="复杂对象归约"></a>复杂对象归约</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算所有的员工的年龄总和。</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees.stream().map(Employee::getAge).reduce(<span class="hljs-number">0</span>,Integer::sum);<br></code></pre></td></tr></table></figure><h4 id="Combiner合并器的使用"><a href="#Combiner合并器的使用" class="headerlink" title="Combiner合并器的使用"></a>Combiner合并器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees.stream()<br>        .reduce(<span class="hljs-number">0</span>,(totalAge,emp) -&gt; totalAge + emp.getAge(),Integer::sum); <br><span class="hljs-comment">// 并行</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> employees<br>        .parallelStream()<br>        .map(Employee::getAge)<br>        .reduce(<span class="hljs-number">0</span>,Integer::sum,Integer::sum);<br></code></pre></td></tr></table></figure><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收集为Set，Set会去重</span><br>Set&lt;String&gt; collectToSet = Stream.of(...).collect(Collectors.toSet());<br><span class="hljs-comment">// 收集为List</span><br>List&lt;String&gt; collectToList = Stream.of(...).collect(Collectors.toList());<br><span class="hljs-comment">// 通用的收集</span><br>LinkedList&lt;String&gt; collectToCollection = Stream.of(...)<br>    .collect(Collectors.toCollection(LinkedList::<span class="hljs-keyword">new</span>));<br><span class="hljs-comment">// 收集到Array</span><br>String[] toArray = Stream.of(...).toArray(String[]::<span class="hljs-keyword">new</span>);<br><span class="hljs-comment">// 收集到Map</span><br>Map&lt;String, Integer&gt; toMap = Stream.of(...)<br>.distinct()<br>.collect(Collectors.toMap(<br>       Function.identity(),   <span class="hljs-comment">// key</span><br>       s -&gt; (<span class="hljs-type">int</span>) s.chars().distinct().count()<span class="hljs-comment">// value</span><br>));<br><span class="hljs-comment">// 分组收集groupingBy</span><br>Map&lt;Character, List&lt;String&gt;&gt; groupingByList = Stream.of(...)<br>.collect(Collectors.groupingBy(<br>       s -&gt; 条件, 收集器<br>));<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断管道中是否包含2，结果是: true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">containsTwo</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).anyMatch(i -&gt; i == <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 管道中元素数据总计结果nrOfAnimals: 4</span><br><span class="hljs-type">long</span> <span class="hljs-variable">nrOfAnimals</span> <span class="hljs-operator">=</span> Stream.of(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>).count();<br><br><span class="hljs-comment">// 管道中元素数据累加结果sum: 6</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).sum();<br><br><span class="hljs-comment">// 管道中元素数据平均值average: OptionalDouble[2.0]</span><br><span class="hljs-type">OptionalDouble</span> <span class="hljs-variable">average</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).average();<br><br><span class="hljs-comment">// 管道中元素数据最大值max: 3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).max().orElse(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 全面统计的结果statistics: IntSummaryStatistics&#123;count=3, sum=6, min=1, average=2.000000, max=3&#125;</span><br><span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).summaryStatistics();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;流</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/2023/05/27/mybatis/"/>
    <url>/2023/05/27/mybatis/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="用来循环容器的标签forEach-查看例子"><a href="#用来循环容器的标签forEach-查看例子" class="headerlink" title="用来循环容器的标签forEach,查看例子"></a><strong>用来循环容器的标签forEach,查看例子</strong></h3><ul><li><p>foreach元素的属性主要有item，index，collection，open，separator，close。</p><ul><li><p>item：集合中元素迭代时的别名，</p></li><li><p>index：集合中元素迭代时的索引</p></li><li><p>open：常用语where语句中，表示以什么开始，比如以’(‘开始</p></li><li><p>separator：表示在每次进行迭代时的分隔符，</p></li><li><p>close 常用语where语句中，表示以什么结束，</p></li></ul></li></ul><ul><li><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p><ul><li><p>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</p></li><li><p>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</p></li><li><p>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</p></li></ul></li></ul><ul><li><p>针对最后一条，我们来看一下官方说法：</p></li><li><blockquote><p>注意 你可以将一个 List 实例或者数组作为参数对象传给 MyBatis，当你这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以“list”作为键，而数组实例的键将是“array”。</p></blockquote><p>所以，不管是多参数还是单参数的list,array类型，都可以封装为map进行传递。如果传递的是一个List，则mybatis会封装为一个list为key，list值为object的map，如果是array，则封装成一个array为key，array的值为object的map，如果自己封装呢，则colloection里放的是自己封装的map里的key值</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">//mapper中我们要为这个方法传递的是一个容器,将容器中的元素一个一个的//拼接到xml的方法中就要使用这个forEach这个标签了public List<span class="hljs-tag">&lt;<span class="hljs-name">Entity</span>&gt;</span> queryById(List<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> userids);<br>    //对应的xml中如下<br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseReslutMap&quot;</span> &gt;</span><br>    select * FROM entity<br>    where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;userids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;userid&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;userid&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="concat模糊查询"><a href="#concat模糊查询" class="headerlink" title="concat模糊查询"></a><strong>concat模糊查询</strong></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">//比如说我们想要进行条件查询,但是几个条件不是每次都要使用,那么我们就可以//通过判断是否拼接到sql中       <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BascResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;entity&quot;</span>&gt;</span><br>    SELECT * from entity<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null&quot;</span>&gt;</span><br>                name like concat(&#x27;%&#x27;,concat(#&#123;name&#125;,&#x27;%&#x27;))<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="choose-when-otherwise-标签"><a href="#choose-when-otherwise-标签" class="headerlink" title="choose (when, otherwise)标签"></a><strong>choose (when, otherwise)标签</strong></h3><p>choose标签是按顺序判断其内部when标签中的test条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的sql。类似于Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。</p><p>例如下面例子，同样把所有可以限制的条件都写上，方面使用。choose会从上到下选择一个when标签的test为true的sql执行。安全考虑，我们使用where将choose包起来，放置关键字多于错误。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  choose(判断参数) - 按顺序将实体类 User 第一个不为空的属性作为：where条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_user&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.yiibai.pojo.User&quot;</span>&gt;</span><br>      SELECT *<br>        FROM User u<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username !=null &quot;</span>&gt;</span><br>                    u.username LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;username, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;sex != null and sex != &#x27;&#x27; &quot;</span>&gt;</span><br>                    AND u.sex = #&#123;sex, jdbcType=INTEGER&#125;<br>                &lt;/when &gt;<br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age != null &quot;</span>&gt;</span><br>                    AND u.age = #&#123;age, jdbcType=INTEGER&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>          <br>                <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>          <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>      <br>         <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="selectKey-标签"><a href="#selectKey-标签" class="headerlink" title="selectKey 标签"></a><strong>selectKey 标签</strong></h3><p>在insert语句中，在Oracle经常使用序列、在MySQL中使用函数来自动生成插入表的主键，而且需要方法能返回这个生成主键。使用myBatis的selectKey标签可以实现这个效果。</p><p>下面例子，使用mysql数据库自定义函数nextval(‘student’)，用来生成一个key，并把他设置到传入的实体类中的studentId属性上。所以在执行完此方法后，边可以通过这个实体类获取生成的key。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 插入学生 自动主键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;createStudentAutoKey&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;liming.student.manager.data.model.StudentEntity&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;studentId&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;studentId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span>&gt;</span><br>        select nextval(&#x27;student&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span>&gt;</span><br>    INSERT INTO<br>M_STUDENT(STUDENT_ID,STUDENT_SEX,STUDENT_BIRTHDAY,STUDENT_PHOTO,CLASS_ID,PLACE_ID)   VALUES (#&#123;studentId&#125;,#&#123;studentName&#125;,#&#123;studentSex&#125;,#&#123;studentBirthday&#125;,#&#123;studentPhoto,javaType=byte[],jdbcType=BLOB,typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,#&#123;classId&#125;,#&#123;placeId&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调用接口方法，和获取自动生成key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>entity.setStudentName(<span class="hljs-string">&quot;黎明你好&quot;</span>);<br>entity.setStudentSex(<span class="hljs-number">1</span>);<br>entity.setStudentBirthday(DateUtil.parse(<span class="hljs-string">&quot;1985-05-28&quot;</span>));<br>entity.setClassId(<span class="hljs-string">&quot;20000001&quot;</span>);<br>entity.setPlaceId(<span class="hljs-string">&quot;70000001&quot;</span>);<br><span class="hljs-built_in">this</span>.dynamicSqlMapper.createStudentAutoKey(entity);<br>System.out.println(<span class="hljs-string">&quot;新增学生ID: &quot;</span> + entity.getStudentId());<br></code></pre></td></tr></table></figure><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a><strong>if标签</strong></h3><p>if标签可用在许多类型的sql语句中，我们以查询为例。首先看一个很普通的查询：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 查询学生list，like姓名 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListLikeName&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;StudentEntity&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;studentResultMap&quot;</span>&gt;</span><br>    SELECT * from M_STUDENT ms<br>    WHERE ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName&#125;),&#x27;%&#x27;) <br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>但是此时如果studentName为null，此语句很可能报错或查询结果为空。此时我们使用if动态sql语句先进行判断，如果值为null或等于空字符串，我们就不进行此条件的判断，增加灵活性。</p><p>参数为实体类StudentEntity。将实体类中所有的属性均进行判断，如果不为空则执行判断条件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 2 if(判断参数) - 将实体类不为空的属性作为where条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;liming.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID, ms.STUDENT_NAME, ms.STUDENT_SEX, ms.STUDENT_BIRTHDAY,      ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID <br>    FROM M_STUDENT ms<br>    WHERE<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>        ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>        AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>        AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>        AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span>      <br>        AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用时比较灵活， new一个这样的实体类，我们需要限制那个条件，只需要附上相应的值就会where这个条件，相反不去赋值就可以不在where中判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>    entity.setStudentName(<span class="hljs-string">&quot;&quot;</span>);<br>    entity.setStudentSex(<span class="hljs-number">1</span>);<br>    entity.setStudentBirthday(DateUtil.parse(<span class="hljs-string">&quot;2023-05-28&quot;</span>));                 <br>    entity.setClassId(<span class="hljs-string">&quot;20000001&quot;</span>);<br> entity.setPlaceId(<span class="hljs-string">&quot;70000001&quot;</span>);<br> List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentList(entity);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>     System.out.println(e.toString());<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="if-where-的条件判断"><a href="#if-where-的条件判断" class="headerlink" title="if + where 的条件判断"></a><strong>if + where 的条件判断</strong></h3><p>当where中的条件使用的if标签较多时，这样的组合可能会导致错误。我们以在3.1中的查询语句为例子，当java代码按如下方法调用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">StudentEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentEntity</span>();<br>    entity.setStudentName(<span class="hljs-literal">null</span>);<br>    entity.setStudentSex(<span class="hljs-number">1</span>);<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentList(entity);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上面例子，参数studentName为null，将不会进行STUDENT_NAME列的判断，则会直接导“WHERE AND”关键字多余的错误SQL。</p><p>这时我们可以使用where动态语句来解决。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><p>上面例子修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 3 select - where/if(判断参数) - 将实体类不为空的属性作为where条件 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,    ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>            ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="if-set实现修改语句"><a href="#if-set实现修改语句" class="headerlink" title="if + set实现修改语句"></a><strong>if + set实现修改语句</strong></h3><p>当update语句中没有使用if标签时，如果有一个参数为null，都会导致错误。</p><p>当在update语句中使用if标签时，如果前面的if没有执行，则或导致逗号多余错误。使用set标签可以将动态的配置SET 关键字，和剔除追加到条件末尾的任何不相关的逗号。使用if+set标签修改后，如果某项为null则不进行更新，而是保持数据库原值。</p><p>如下示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 4 if/set(判断参数) - 将实体类不为空的属性更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    UPDATE M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName != null and studentName != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_NAME = #&#123;studentName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_SEX = #&#123;studentSex&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            ms.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentPhoto != null &quot;</span>&gt;</span><br>            ms.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.CLASS_ID = #&#123;classId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.PLACE_ID = #&#123;placeId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    WHERE ms.STUDENT_ID = #&#123;studentId&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="if-trim代替where-set标签"><a href="#if-trim代替where-set标签" class="headerlink" title="if + trim代替where/set标签"></a><strong>if + trim代替where/set标签</strong></h3><p>trim是更灵活的去处多余关键字的标签，他可以实践where和set的效果。</p><h4 id="trim代替where"><a href="#trim代替where" class="headerlink" title="trim代替where"></a><strong>trim代替where</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.1 if/trim代替where(判断参数) -将实体类不为空的属性作为where条件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,       ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND|OR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName !=null &quot;</span>&gt;</span><br>            ms.STUDENT_NAME LIKE CONCAT(CONCAT(&#x27;%&#x27;, #&#123;studentName, jdbcType=VARCHAR&#125;),&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_SEX = #&#123;studentSex, jdbcType=INTEGER&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>            AND ms.STUDENT_BIRTHDAY = #&#123;studentBirthday, jdbcType=DATE&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != null and classId!= &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classId, jdbcType=VARCHAR&#125;  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classEntity != null and classEntity.classId !=null and classEntity.classId !=&#x27; &#x27; &quot;</span>&gt;</span><br>            AND ms.CLASS_ID = #&#123;classEntity.classId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != null and placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeEntity != null and placeEntity.placeId != null and placeEntity.placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.PLACE_ID = #&#123;placeEntity.placeId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentId != null and studentId != &#x27;&#x27; &quot;</span>&gt;</span><br>            AND ms.STUDENT_ID = #&#123;studentId, jdbcType=VARCHAR&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="trim代替set"><a href="#trim代替set" class="headerlink" title="trim代替set"></a><strong>trim代替set</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 5.2 if/trim代替set(判断参数) - 将实体类不为空的属性更新 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;wtl.student.manager.data.model.StudentEntity&quot;</span>&gt;</span><br>    UPDATE M_STUDENT ms<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentName != null and studentName != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_NAME = #&#123;studentName&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentSex != null and studentSex != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.STUDENT_SEX = #&#123;studentSex&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentBirthday != null &quot;</span>&gt;</span><br>        ms.STUDENT_BIRTHDAY = #&#123;studentBirthday&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;studentPhoto != null &quot;</span>&gt;</span><br>            ms.STUDENT_PHOTO = #&#123;studentPhoto, javaType=byte[], jdbcType=BLOB, typeHandler=org.apache.ibatis.type.BlobTypeHandler&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;classId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.CLASS_ID = #&#123;classId&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;placeId != &#x27;&#x27; &quot;</span>&gt;</span><br>            ms.PLACE_ID = #&#123;placeId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    WHERE ms.STUDENT_ID = #&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a><strong>foreach</strong></h3><p>对于动态SQL 非常必须的，主是要迭代一个集合，通常是用于IN 条件。List 实例将使用“list”做为键，数组实例以“array” 做为键。</p><p>foreach元素是非常强大的，它允许你指定一个集合，声明集合项和索引变量，它们可以用在元素体内。它也允许你指定开放和关闭的字符串，在迭代之间放置分隔符。这个元素是很智能的，它不会偶然地附加多余的分隔符。</p><blockquote><p>注意：你可以传递一个List实例或者数组作为参数对象传给MyBatis。当你这么做的时候，MyBatis会自动将它包装在一个Map中，用名称在作为键。List实例将会以“list”作为键，而数组实例将会以“array”作为键。</p></blockquote><p>这个部分是对关于XML配置文件和XML映射文件的而讨论的。下一部分将详细讨论Java API，所以你可以得到你已经创建的最有效的映射。</p><h4 id="参数为array示例的写法"><a href="#参数为array示例的写法" class="headerlink" title="参数为array示例的写法"></a><strong>参数为array示例的写法</strong></h4><p>接口的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title function_">getStudentListByClassIds_foreach_array</span><span class="hljs-params">(String[] classIds)</span>;<br></code></pre></td></tr></table></figure><p>动态SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 7.1 foreach(循环array参数) - 作为where中in的条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListByClassIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,     ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    WHERE ms.CLASS_ID IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;classIds&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>        #&#123;classIds&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码，查询学生中，在20000001、20000002这两个班级的学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>    String[] classIds = &#123; <span class="hljs-string">&quot;20000001&quot;</span>, <span class="hljs-string">&quot;20000002&quot;</span> &#125;;<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentListByClassIds(classIds);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参数为list示例的写法"><a href="#参数为list示例的写法" class="headerlink" title="参数为list示例的写法"></a><strong>参数为list示例的写法</strong></h4><p>接口的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;StudentEntity&gt; <span class="hljs-title function_">getStudentListByClassIds</span><span class="hljs-params">(List&lt;String&gt; classIdList)</span>;<br></code></pre></td></tr></table></figure><p>动态SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 7.2 foreach(循环List&lt;String&gt;参数) - 作为where中in的条件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentListByClassIds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;resultMap_studentEntity&quot;</span>&gt;</span><br>    SELECT ms.STUDENT_ID,ms.STUDENT_NAME,ms.STUDENT_SEX,ms.STUDENT_BIRTHDAY,     ms.STUDENT_PHOTO,ms.CLASS_ID,ms.PLACE_ID<br>    FROM M_STUDENT ms<br>    WHERE ms.CLASS_ID IN<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;classIdList&quot;</span>  <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>          #&#123;classIdList&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码，查询学生中，在20000001、20000002这两个班级的学生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectList</span><span class="hljs-params">()</span> &#123;<br>    ArrayList&lt;String&gt; classIdList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>    classIdList.add(<span class="hljs-string">&quot;20000001&quot;</span>);<br>    classIdList.add(<span class="hljs-string">&quot;20000002&quot;</span>);<br>    List&lt;StudentEntity&gt; list = <span class="hljs-built_in">this</span>.dynamicSqlMapper.getStudentListByClassIds(classIdList);<br>    <span class="hljs-keyword">for</span> (StudentEntity e : list) &#123;<br>        System.out.println(e.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>sql片段标签<code>&lt;sql&gt;</code>：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性</p><p>需要配置的属性：id=”” &gt;&gt;&gt;表示需要改sql语句片段的唯一标识</p><p>引用：通过<code>&lt;include refid=&quot;&quot; /&gt;</code>标签引用，refid=”” 中的值指向需要引用的<code>&lt;sql&gt;</code>中的id=“”属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义sql片段--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderAndItem&quot;</span>&gt;</span>   t1.order_id,t1.cid,t1.address,t1.create_date,t1.item,t2.item,t2.product_id,t2.count<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findOrderAndItemsByOid&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>&gt;</span><br>    select  <span class="hljs-comment">&lt;!--引用sql片段--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;orderAndItem&quot;</span> /&gt;</span><br>    from table1 t1<br>    join table2 t2 on t1.item = t2.item<br>    where t1.order_id = #&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口优化</title>
    <link href="/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
    <url>/2023/05/20/%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="接口优化方案总结"><a href="#接口优化方案总结" class="headerlink" title="接口优化方案总结"></a><strong>接口优化方案总结</strong></h2><p>近期接口优化的一些总结：</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="1-批处理"><a href="#1-批处理" class="headerlink" title="1.批处理"></a><strong>1.批处理</strong></h3><p>批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//for循环单笔入库</span><br>list.stream().forEatch(l -&gt; &#123;<br>insert();<br>&#125;);<br><span class="hljs-comment">//批量入库batchInsert();</span><br></code></pre></td></tr></table></figure><h3 id="2-异步处理"><a href="#2-异步处理" class="headerlink" title="2. 异步处理"></a><strong>2. 异步处理</strong></h3><p>异步思想：针对耗时比较长且不是结果必须的逻辑，我们可以考虑放到异步执行，这样能降低接口耗时。</p><h3 id="3-空间换时间"><a href="#3-空间换时间" class="headerlink" title="3. 空间换时间"></a><strong>3. 空间换时间</strong></h3><p>合理使用缓存，针对一些频繁使用且不频繁变更的数据，可以提前缓存起来，需要时直接查缓存，避免频繁地查询数据库或者重复计算。需要注意空间换时间也是一把双刃剑，需要综合考虑使用场景，缓存带来的数据一致性问题也挺令人头疼。</p><h3 id="4-预处理"><a href="#4-预处理" class="headerlink" title="4. 预处理"></a><strong>4. 预处理</strong></h3><p>预取思想，提前把查询的数据计算好，封装好，放入缓存或者表中的某个字段，用的时候会大幅提高接口性能。</p><h3 id="5-池化思想"><a href="#5-池化思想" class="headerlink" title="5. 池化思想"></a><strong>5. 池化思想</strong></h3><p>我们都用过数据库连接池，线程池等，这就是池思想的体现，它们解决的问题就是避免重复创建对象或创建连接，可以重复利用，避免不必要的损耗，因为创建销毁也会占用时间。</p><p>池化思想包含但并不局限于以上两种，总的来说池化思想的本质是<strong>预分配与循环使用</strong>。</p><h3 id="6-串行改并行"><a href="#6-串行改并行" class="headerlink" title="6. 串行改并行"></a><strong>6. 串行改并行</strong></h3><p>串行就是，当前执行逻辑必须等上一个执行逻辑结束之后才执行，并行就是两个执行逻辑互不干扰，所以并行相对来说就比较节省时间，当然是建立在没有结果参数依赖的前提下。</p><h3 id="7-索引"><a href="#7-索引" class="headerlink" title="7. 索引"></a><strong>7. 索引</strong></h3><p>加索引能大大提高数据查询效率，这个在接口设计之出也会考虑到</p><p>索引失效常见情景：</p><p>① 隐式类型转换；</p><p>② select * ；</p><p>③ 对索引进行列运算(+、-、*、/)；</p><p>④ 不满足最左匹配原则；</p><p>⑤ 使用or关键字；</p><p>⑥ not in 和 not exists；</p><p>⑦ order by 和搜索列不匹配；</p><p>⑧ 使用&lt;、&gt;、!=;</p><p>⑨ like以通配符开头(‘%xxx’)</p><h3 id="8-避免大事务"><a href="#8-避免大事务" class="headerlink" title="8. 避免大事务"></a><strong>8. 避免大事务</strong></h3><p>所谓大事务问题，就是<strong>运行时间较长的事务，</strong>由于事务一致不提交，会导致数据库连接被占用，影响到别的请求访问数据库，影响别的接口性能。事务中嵌套 RPC 调用，即非 DB 操作，这些非 DB 操作如果耗时较大的话，可能会出现大事务问题。大数据引发的问题主要有：死锁、接口超时、主从延迟等。所以为避免大事务问题，我们可以通过以下方案规避：</p><p>① RPC调用不放到事务里面;</p><p>② 查询操作尽量放到事务之外;</p><p>③ 事务中避免处理太多数据。</p><h3 id="9-优化程序结构"><a href="#9-优化程序结构" class="headerlink" title="9. 优化程序结构"></a><strong>9. 优化程序结构</strong></h3><p>程序结构问题一般出现在多次需求迭代后，代码叠加形成。会造成一些重复查询、多次创建对象等耗时问题。在多人维护一个项目时比较多见。解决起来也比较简单，我们需要针对接口整体做重构，评估每个代码块的作用和用途，调整执行顺序。</p><h3 id="10-深分页问题"><a href="#10-深分页问题" class="headerlink" title="10. 深分页问题"></a><strong>10. 深分页问题</strong></h3><p>深分页问题比较常见，分页我们一般最先想到的就是 limit，为什么会慢，如下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> orderTime <span class="hljs-keyword">desc</span> limit <span class="hljs-number">100000</span>,<span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>limit 100000,200 意味着会扫描 100200 行，然后返回 200 行，丢弃掉前 100000 行。所以执行速度很慢。一般可以采用标签记录法来优化，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> m_product <span class="hljs-keyword">where</span> product_code <span class="hljs-operator">=</span><span class="hljs-string">&#x27;WA123456&#x27;</span><br><span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <br><span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">100000</span> limit <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>这样优化的好处是命中了主键索引，无论多少页，性能都还不错，但是局限性是需要一个连续自增的字段。</p><p>避免使用select *，其实select后字段名全写，也比 * 效率高很多。</p><h3 id="11-SQL-优化"><a href="#11-SQL-优化" class="headerlink" title="11.SQL 优化"></a><strong>11.SQL 优化</strong></h3><p>sql优化能大幅提高接口的查询性能，结合索引、分页等关注点制定优化方案。</p><h3 id="12-锁粒度避免过粗"><a href="#12-锁粒度避免过粗" class="headerlink" title="12. 锁粒度避免过粗"></a><strong>12. 锁粒度避免过粗</strong></h3><p>锁一般是为了在高并发场景下保护共享资源采用的一种手段，但是如果锁的粒度太粗，会很影响接口性能。</p><p>关于锁粒度：就是要锁的范围有多大，不管是 synchronized 还是 redis 分布式锁，只需要在临界资源处加锁即可，不涉及共享资源的，不必要加锁，就好比你要上卫生间，只需要把卫生间的门锁上就可以，不需要把客厅的门也锁上。</p><p>错误的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intwrong</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>    share();<br>        notShare();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确的加锁方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//非共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notShare</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-comment">//共享资源</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">share</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">intright</span><span class="hljs-params">()</span>&#123;    <br>notShare();<br><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>share(); <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>&lt;接口调优</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储过程</title>
    <link href="/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/04/03/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="存储过程介绍"><a href="#存储过程介绍" class="headerlink" title="存储过程介绍"></a>存储过程介绍</h1><p>[TOC]</p><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h3 id="1-带参存储过程语法"><a href="#1-带参存储过程语法" class="headerlink" title="1.带参存储过程语法"></a>1.带参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字(<br>    <span class="hljs-comment">--输入参数 IN NUMBER,</span><br>    <span class="hljs-comment">--输出参数 OUT NUMBER, --可以有多个输入参数和输出参数</span><br>                <span class="hljs-comment">--输入输出 INOUT NUMBER</span><br>) <span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>     <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>      <span class="hljs-keyword">rollback</span>;<br>      dbms_output.put_line(sqlcode);<br>      dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><blockquote><ul><li>​        注意：</li><li>​            其中参数IN表示输入参数，是参数的默认模式。</li><li>​            OUT表示返回值参数，类型可以使用任意Oracle中的合法类型。</li><li>​            OUT模式定义的参数只能在过程体内部赋值，表示该参数可以将某个值传递回调用他的过程</li><li>​            IN OUT表示该参数可以向该过程中传递值，也可以将某个值传出去。</li></ul></blockquote><h3 id="2-无参存储过程语法"><a href="#2-无参存储过程语法" class="headerlink" title="2.无参存储过程语法"></a>2.无参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> 存储过程名字<br><span class="hljs-keyword">IS</span><br>    <span class="hljs-comment">--这个区间可以用来定义变量和创建游标</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br>    <span class="hljs-keyword">commit</span>; <span class="hljs-comment">--对上面的内容进行提交</span><br>exception<span class="hljs-operator">/</span><span class="hljs-operator">/</span>存储过程异常<br>   <span class="hljs-keyword">when</span> others <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">--异常处理方法，可以是打印错误，然后进行回滚等操作，下面操作一样，看自己情况决定</span><br>   <span class="hljs-keyword">rollback</span>;<br>   dbms_output.put_line(sqlcode);<br>   dbms_output.put_line(substr(sqlerrm, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>));<br><span class="hljs-keyword">END</span> 存储过程名字;<br><span class="hljs-comment">--调用存储过程</span><br>存储过程名称;<br></code></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="1-带参存储过程语法-1"><a href="#1-带参存储过程语法-1" class="headerlink" title="1.带参存储过程语法"></a>1.带参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字([<span class="hljs-keyword">in</span>,<span class="hljs-keyword">out</span>,<span class="hljs-keyword">inout</span>] 参数名 数据类型)<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><h3 id="2-无参存储过程语法-1"><a href="#2-无参存储过程语法-1" class="headerlink" title="2.无参存储过程语法"></a>2.无参存储过程语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">delimiter 自定义结束符号<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名字()<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">--定义变量/游标</span><br>    <span class="hljs-comment">--执行游标或者执行语句</span><br><span class="hljs-keyword">END</span> 自定义结束符号<br>delimiter;<br><span class="hljs-comment">--调用存储过程</span><br><span class="hljs-keyword">call</span> 存储过程名称；<br></code></pre></td></tr></table></figure><h3 id="流程控制-判断语句"><a href="#流程控制-判断语句" class="headerlink" title="流程控制-判断语句"></a>流程控制-判断语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">if 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br>elseif 条件语句<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> if;<br></code></pre></td></tr></table></figure><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">case</span> 参数<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">1</span>;<br><span class="hljs-keyword">when</span> 条件<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> 执行语句<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span> <span class="hljs-keyword">case</span>;<br></code></pre></td></tr></table></figure><h3 id="流程控制-循环语句"><a href="#流程控制-循环语句" class="headerlink" title="流程控制-循环语句"></a>流程控制-循环语句</h3><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>while 循环条件<br>do 循环体;<br><span class="hljs-keyword">end</span> while 标签;<br></code></pre></td></tr></table></figure><h4 id="repeat语句"><a href="#repeat语句" class="headerlink" title="repeat语句"></a>repeat语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签：<br>repeat 循环体;<br>until 条件表达式<br><span class="hljs-keyword">end</span> repeat 标签;<br></code></pre></td></tr></table></figure><h4 id="loop语句"><a href="#loop语句" class="headerlink" title="loop语句"></a>loop语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">标签:<br>loop 循环体;<br>if 条件表达式 <span class="hljs-keyword">then</span><br>leave 标签;<br><span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span> loop;<br>loop<br>    执行语句;<br>    exit <span class="hljs-keyword">when</span> <span class="hljs-operator">&lt;</span>条件语句<span class="hljs-operator">&gt;</span> <span class="hljs-comment">--条件满足，退出循环语句;</span><br><span class="hljs-keyword">end</span> loop;<br></code></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">for</span> 循环计数器 <span class="hljs-keyword">in</span> [REVERSE] 下限 .. 上限 loop<br>要执行的语句;<br><span class="hljs-keyword">end</span> loop [循环标签];<br>每循环一次，循环变量自动加<span class="hljs-number">1</span>；使用关键字REVERSE，循环变量自动减<span class="hljs-number">1</span>。<br><span class="hljs-keyword">in</span> REVERSE 后面的数字必须是从小到大的顺序，而且必须是整数，不能是变量或表达式,也可以使用EXIT退出循环，见loop语句。<br></code></pre></td></tr></table></figure><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><h4 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h4><blockquote><ul><li>MySQL:<ul><li>declare 游标名称 cursor for 传给游标的结果集;</li><li>open 游标名称;</li><li>fetch 游标名称 into 自定义变量;</li><li>close 游标名称;</li></ul></li><li>Oracle:<ul><li>cursor 游标名称 is 传给游标的结果集;</li><li>open 游标名称;</li><li>fetch 游标名称 into 自定义变量;</li><li>close 游标名称;</li></ul></li></ul></blockquote><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table><thead><tr><th align="left">类别描述</th><th align="left">MySQL</th><th align="left">Oracle</th><th align="left">注解</th></tr></thead><tbody><tr><td align="left">创建存储过程/函数语句</td><td align="left">DROP PROCEDURE IF EXISTS <code>存储过程名称</code>;<br/>create procedure 存储过程名称()<br/>DROP FUNCTION IF EXISTS <code>函数名称</code>;<br/>CREATE  FUNCTION <code>函数名称</code>()<br/> RETURNS varchar(1000)</td><td align="left">create or replace procedure 存储过程名称（） is<br/>create or replace function 函数名称()<br/>RETURN VARCHAR2</td><td align="left">1.在创建存储过程时如果存在同名的存储过程,会删除老的存储过程. <br/>  Oracle使用create or replace.<br/>  MySQL使用先删除老的存储过程,然后再创建新的存储过程.<br/>2. Oracle存储过程可以定义在package中,也可以定义在Procedures中. 如果定义在包中,一个包中可以包含多个存储过程和方法.如果定义在Procedures中,存储过程中不可以定义多个存储过程. <br/>   MySQL存储过程中不可以定义多个存储过程.</td></tr><tr><td align="left">传参</td><td align="left">存储过程名称(参数类型  参数  参数属性)</td><td align="left">存储过程名称(参数  参数类型  参数属性)</td><td align="left">1. oracle存储过程参数可以定义为表的字段类型.<br/>   Mysql存储过程不支持这种定义方法.需要定义变量的实际类型和长度.<br/>2. oracle 参数类型in/out/inout写在参数名后面. <br/>   Mysql  参数类型in/out/inout写在参数名前面.<br/>3. oracle 参数类型in/out/inout 都必须写.<br/>   Mysql  参数类型默认in,可省略，out或inout不可省略.</td></tr><tr><td align="left">包</td><td align="left">多个存储过程或函数</td><td align="left">create or replace package/package body package name</td><td align="left">oracle可以创建包,包中可以包含多个存储过程和方法. <br/>mysql没有包，需分别创建存储过程和方法. 每个存储过程或方法都需要放在一个文件中.</td></tr><tr><td align="left">存储过程返回语句</td><td align="left">LEAVE  xx;</td><td align="left">return;</td><td align="left">oracle存储过程和方法都可以使用return退出当前过程和方法. <br/>Mysql存储过程中只能使用leave退出当前存储过程.不可以使用return. <br/>Mysql方法可以使用return退出当前方法.</td></tr><tr><td align="left">声明变量的位置</td><td align="left">begin…end内</td><td align="left">begin之前</td><td align="left"></td></tr><tr><td align="left">调用方式</td><td align="left">call 存储过程名称();</td><td align="left">存储过程名称();</td><td align="left"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>&lt;数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储过程 Oracle MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
